import { Prerequisites } from "/snippets/get-started/prerequisites/call-others-api.jsx";
import { AccountAndAppSteps } from "/snippets/get-started/prerequisites/account-app-steps.jsx";

<Prerequisites
  createAuth0ApplicationStep={{
    applicationType: "Single Page Web Applications",
    callbackUrl: "http://localhost:5173/auth/callback",
    logoutUrl: "http://localhost:5173",
    allowedWebOrigins: "http://localhost:5173",
  }}
  refreshTokenGrantStep={{
    applicationName: "Single Page Web Application",
  }}
  createAuth0ApiStep={{}}
  createResourceServerClientStep={{}}
  tokenExchangeGrantStep={{
    applicationName: "Single Page Web Application",
  }}
/>

### Key differences from Next.js approach

This React SPA implementation differs from the <a href="/get-started/call-others-apis-on-users-behalf#vercel-ai-%2B-next-js" target="_blank">Next.js example</a> in a few important ways:

1. **Token Vault Access Token Exchange**: Instead of using refresh tokens, the React SPA implementation exchanges the SPA's access token for a third-party access token.
2. **Client-Side Authorization**: Client login and step-up authorization are handled client-side using `@auth0/auth0-spa-js`.
3. **Resource Server Client**: Requires a special Resource Server Client configured for token exchange with Token Vault.
4. **Interrupt Handling**: The React client manages tool access errors and step-up authorization using interrupts that trigger a pop-up for re-authorization.

### Prepare React SPA + Hono API

**Recommended**: To use this example, clone the [Auth0 AI JS](https://github.com/auth0-lab/auth0-ai-js.git) repository:

```bash wrap lines
git clone https://github.com/auth0-lab/auth0-ai-js.git
cd auth0-ai-js/examples/calling-apis/spa-with-backend-api/react-hono-ai-sdk
```

### Install dependencies

In the root directory of your project, you have the following client and server dependencies:

**Client dependencies:**

- `@auth0/auth0-spa-js`: Auth0 SPA SDK for client-side authentication
- `@auth0/ai-vercel`: [Auth0 AI SDK for Vercel AI](https://github.com/auth0-lab/auth0-ai-js/tree/main/packages/ai-vercel) built for AI agents
- `ai`: Core [Vercel AI SDK](https://sdk.vercel.ai/docs) module

**Server dependencies:**

- `@hono/node-server`: Node.js server adapter for Hono
- `hono`: Lightweight web framework
- `ai`: Core [Vercel AI SDK](https://sdk.vercel.ai/docs) module
- `@ai-sdk/openai`: [OpenAI](https://sdk.vercel.ai/providers/ai-sdk-providers/openai) provider
- `googleapis`: Node.js client for Google APIs
- `jose`: JavaScript Object Signing and Encryption library for JWT verification
To install all the client and server dependencies, navigate to the root directory of your project and run the following command:
```bash wrap lines
# Install all client & server dependencies from the root directory of the project.
npm install
```

### Update the environment files

Add separate `.env` files with environment variables for the client and server.

#### Client (client/.env)

```bash .env wrap lines
VITE_AUTH0_DOMAIN=your-auth0-domain
VITE_AUTH0_CLIENT_ID=your-spa-client-id
VITE_AUTH0_AUDIENCE=your-api-identifier
VITE_API_URL=http://localhost:3001
```

#### Server (server/.env)

```bash .env wrap lines
AUTH0_DOMAIN=your-auth0-domain
AUTH0_AUDIENCE=your-api-identifier
AUTH0_CLIENT_ID=your-resource-server-client-id
AUTH0_CLIENT_SECRET=your-resource-server-client-secret
OPENAI_API_KEY=your-openai-api-key
PORT=3001
```

### Configure the SPA for step-up authorization

Unlike the <a href="/get-started/call-others-apis-on-users-behalf#vercel-ai-%2B-next-js" target="_blank">Next.js example</a>, which uses refresh tokens, this React SPA approach uses **access tokens** for token exchange with Token Vault. The SPA handles step-up authorization using Auth0 SPA SDK's `loginWithPopup()` method to display the consent screen and allow the user to grant additional permissions.

Create `client/src/components/FederatedConnectionPopup.tsx`:

```tsx client/src/components/FederatedConnectionPopup.tsx wrap lines
import { getAuth0Client } from "../lib/auth0";
import { Button } from "./ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "./ui/card";

import type { Auth0InterruptionUI } from "@auth0/ai-vercel/react";
interface FederatedConnectionPopupProps {
  interrupt: Auth0InterruptionUI;
}

export function FederatedConnectionPopup({
  interrupt,
}: FederatedConnectionPopupProps) {
  const [isLoading, setIsLoading] = useState(false);

  const { connection, requiredScopes, resume } = interrupt;

  // Use Auth0 SPA SDK to request additional connection/scopes
  const startFederatedLogin = useCallback(async () => {
    try {
      setIsLoading(true);

      // Filter out empty scopes
      const validScopes = requiredScopes.filter(
        (scope: string) => scope && scope.trim() !== ""
      );

      const auth0Client = getAuth0Client();

      // Use getTokenWithPopup for step-up authorization to request additional scopes
      await auth0Client.getTokenWithPopup({
        authorizationParams: {
          prompt: "consent", // Required for Google Calendar scopes
          connection: connection, // e.g., "google-oauth2"
          connection_scope: validScopes.join(" "), // Google-specific scopes
          access_type: "offline",
        },
      });

      // The Auth0 client should automatically use the new token, but we should trigger
      // a refresh to ensure the latest token is cached.
      await auth0Client.getTokenSilently();

      setIsLoading(false);

      // Resume the interrupted tool after successful authorization
      if (typeof resume === "function") {
        resume();
      }
    } catch (error) {
      setIsLoading(false);

      if (typeof resume === "function") {
        resume();
      }
    }
  }, [connection, requiredScopes, resume]);

  if (isLoading) {
    return (
      <Card className="w-full">
        <CardContent className="flex items-center justify-center p-6">
          <div className="text-center">
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary mx-auto mb-2"></div>
            <p className="text-sm text-muted-foreground">
              Connecting to {connection.replace("-", " ")}...
            </p>
          </div>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card className="w-full border-yellow-200 bg-yellow-50">
      <CardHeader>
        <CardTitle className="text-lg text-yellow-800">
          Authorization Required
        </CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        <p className="text-sm text-yellow-700">
          To access your {connection.replace("-", " ")} data, you need to authorize this application.
        </p>
        <p className="text-xs text-yellow-600">
          Required permissions:{" "}
          {requiredScopes
            .filter((scope: string) => scope && scope.trim() !== "")
            .join(", ")}
        </p>
        <Button onClick={startFederatedLogin} className="w-full">
          Authorize {connection.replace("-", " ")}
        </Button>
      </CardContent>
    </Card>
  );
}
```

#### Create tools with integrated Token Vault support for retrieving third-party access tokens

Next, create a tool that accesses Token Vault to fetch a Google access token to list all the Google Calendars a user has access to.

Create `server/src/lib/tools/listUserCalendars.ts`:

```ts server/src/lib/tools/listUserCalendars.ts wrap lines
import { tool } from "ai";
import { google } from "googleapis";
import { z } from "zod";

import { getAccessTokenForConnection } from "@auth0/ai-vercel";

import type { ToolWrapper } from "@auth0/ai-vercel";

/**
 * Tool: listUserCalendars
 * Lists all calendars the user has access to.
 * Uses the enhanced @auth0/ai SDK for token exchange with Token Vault.
 */
export const createListUserCalendarsTool = (
  googleCalendarWrapper: ToolWrapper
) =>
  googleCalendarWrapper(
    tool({
      description: "List all calendars the user has access to",
      parameters: z.object({}),
      execute: async () => {
        // Get the access token from Token Vault using the enhanced SDK
        const token = getAccessTokenForConnection();

        const calendar = google.calendar("v3");
        const auth = new google.auth.OAuth2();
        auth.setCredentials({ access_token: token });

        const res = await calendar.calendarList.list({ auth });

        const calendars =
          res.data.items?.map((cal) => ({
            id: cal.id,
            name: cal.summary,
            accessRole: cal.accessRole,
          })) ?? [];

        return calendars;
      },
    })
  );
```

#### Configure the API server with Google connection wrapper for calendar tools

Instantiate an instance of `Auth0AI` with a pre-configured resource client. Then, create a wrapper for the Google Calendar Tool that sets up the token exchange. This allows you to directly exchange an Auth0 access token for a Google access token from Token Vault with the necessary Calendar scopes.

Create `server/src/lib/auth0.ts`:

```ts server/src/lib/auth0.ts wrap lines
import { SUBJECT_TOKEN_TYPES } from "@auth0/ai";
import { Auth0AI } from "@auth0/ai-vercel";

import type { Context } from "hono";

import type { ToolWrapper } from "@auth0/ai-vercel";
// Create an Auth0AI instance configured with reserver client credentials
const auth0AI = new Auth0AI({
  auth0: {
    domain: process.env.AUTH0_DOMAIN!,
    clientId: process.env.AUTH0_CUSTOM_API_CLIENT_ID!, // Resource server client ID for token exchange
    clientSecret: process.env.AUTH0_CUSTOM_API_CLIENT_SECRET!, // Resource server client secret
  },
});

// Enhanced token exchange with Token Vault, setup with access token support
// This demonstrates the new API pattern where access tokens can be used directly
export const createGoogleCalendarTool = (c: Context): ToolWrapper => {
  const accessToken = c.get("auth")?.token;
  if (!accessToken) {
    throw new Error("Access token not available in auth context");
  }
  return auth0AI.withTokenForConnection({
    accessToken: async () => accessToken,
    subjectTokenType: SUBJECT_TOKEN_TYPES.SUBJECT_TYPE_ACCESS_TOKEN,
    connection: process.env.GOOGLE_CONNECTION_NAME || "google-oauth2",
    scopes: [
      "https://www.googleapis.com/auth/calendar.calendarlist.readonly", // Read-only access to calendar list
      "https://www.googleapis.com/auth/calendar.events.readonly", // Read-only access to events
    ],
  });
};
```

### Create Hono API Chat API server with interrupt handling

Create an AI-powered chat server using Hono, the Auth0 AI SDK, and the Vercel AI SDK that allows a user to chat with an AI assistant that can access their Google Calendar.

The Auth0 AI SDK's `withInterruptions()` function wraps the Vercel AI SDK's `streamText()` function, enabling the Hono server to handle interrupts, which are special responses from Token Vault. An interrupt is sent if a tool call requires a new or updated access token, for example, if a user needs to re-authenticate or a new permission is needed.

Create `server/src/index.ts`:

```ts server/src/index.ts wrap lines
import {
  createDataStreamResponse,
  generateId,
  streamText,
  ToolExecutionError,
} from "ai";
import { Hono } from "hono";
import { cors } from "hono/cors";
import { decodeJwt } from "jose";

import { openai } from "@ai-sdk/openai";
import { setAIContext } from "@auth0/ai-vercel";
import { InterruptionPrefix, withInterruptions } from "@auth0/ai-vercel/interrupts";
import { Auth0Interrupt } from "@auth0/ai/interrupts";
import { serve } from "@hono/node-server";

import { listUserCalendars } from "./lib/tools/listUserCalendars";
import { jwtAuthMiddleware } from "./middleware/auth";

import type { ApiResponse } from "shared/dist";

export const app = new Hono().post("/chat", jwtAuthMiddleware(), async (c) => {
    // auth middleware adds the auth context to the request
    const auth = c.get("auth");

    const { messages: requestMessages } = await c.req.json();

    // Generate a thread ID for this conversation
    const threadID = generateId();

    // Set AI context for the tools to access
    setAIContext({ threadID });

    // Create the Google Calendar wrapper with auth context
    const googleCalendarWrapper = createGoogleCalendarTool(c);

    // Create tools with the auth context
    const listUserCalendars = createListUserCalendarsTool(googleCalendarWrapper);

    // Use the messages from the request directly
    const tools = { listUserCalendars };

    // note: you can see more examples of Hono API consumption with AI SDK here:
    // https://ai-sdk.dev/cookbook/api-servers/hono?utm_source=chatgpt.com#hono

    return createDataStreamResponse({
      execute: withInterruptions(
        async (dataStream) => {
          const result = streamText({
            model: openai("gpt-4o-mini"),
            system:
              "You are a helpful calendar assistant! You can help users with their calendar events and schedules. Keep your responses concise and helpful.",
            messages: requestMessages,
            maxSteps: 5,
            tools,
          });

          result.mergeIntoDataStream(dataStream, {
            sendReasoning: true,
          });
        },
        { messages: requestMessages, tools }
      ),
      onError: (error: any) => {
        // Handle Auth0 AI interrupts
        if (
          error.cause instanceof Auth0Interrupt ||
          error.cause instanceof FederatedConnectionInterrupt
        ) {
          const serializableError = {
            ...error.cause.toJSON(),
            toolCall: {
              id: error.toolCallId,
              args: error.toolArgs,
              name: error.toolName,
            },
          };

          return `${InterruptionPrefix}${JSON.stringify(serializableError)}`;
        }

        return "Oops! An error occurred.";
      },
    });
  });

// Start the server for Node.js
const port = Number(process.env.PORT) || 3000;

console.log(`ðŸš€ Server starting on port ${port}`);
serve({ fetch: app.fetch, port });

console.log(`âœ… Server running on http://localhost:${port}`);
```

### Implement interrupt handling in React

Update your chat component to handle step-up auth interrupts:

```tsx client/src/components/Chat.tsx wrap lines highlight={3,5,12,18-33,49-65, 124-126}
import { Loader2, Send, Trash2 } from "lucide-react";
import { useChat } from "@ai-sdk/react";
import { useInterruptions } from "@auth0/ai-vercel/react";
import { useAuth0 } from "../hooks/useAuth0";
import { FederatedConnectionPopup } from "./FederatedConnectionPopup";
import { Button } from "./ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "./ui/card";
import { Input } from "./ui/input";

import type { Message } from "ai";

const InterruptionPrefix = "AUTH0_AI_INTERRUPTION:";
const SERVER_URL = import.meta.env.VITE_SERVER_URL;

export function Chat() {
  const { getToken } = useAuth0();

  const chatHelpers = useInterruptions((errorHandler) =>
    useChat({
      api: `${SERVER_URL}/chat`,
      fetch: async (url: string | URL | Request, init?: RequestInit) => {
        const token = await getToken();
        return fetch(url, {
          ...init,
          headers: {
            "Content-Type": "application/json",
            ...init?.headers,
            Authorization: `Bearer ${token}`,
          },
        });
      },
    })
  );

  const {
    messages,
    input,
    handleInputChange,
    handleSubmit,
    isLoading,
    error,
    setMessages,
    toolInterrupt,
  } = chatHelpers;

  // Filter out interrupted tool calls from messages
  let displayMessages = messages;

  if (toolInterrupt) {
    displayMessages = messages.map((message) => ({
      ...message,
      parts: message.parts?.map((part) =>
        part.type === "tool-invocation" &&
        part.toolInvocation.toolCallId === toolInterrupt.toolCall?.id
          ? {
              ...part,
              toolInvocation: {
                ...part.toolInvocation,
                state: "call",
              },
            }
          : part
      ),
    }));
  }

  const clearMessages = () => {
    setMessages([]);
  };

  return (
    <Card className="w-full max-w-2xl mx-auto">
      <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
        <CardTitle className="text-lg font-semibold">
          Calendar Assistant
        </CardTitle>
        {messages.length > 0 && (
          <Button
            variant="outline"
            size="sm"
            onClick={clearMessages}
            className="h-8 w-8 p-0"
          >
            <Trash2 className="h-4 w-4" />
          </Button>
        )}
      </CardHeader>
      <CardContent className="space-y-4">
        {/* Messages */}
        <div className="space-y-4 max-h-96 overflow-y-auto">
          {displayMessages.length === 0 ? (
            <div className="text-center text-muted-foreground py-8">
              <p className="text-sm">Ask me about your calendar events!</p>
              <p className="text-xs mt-1">
                Try: "What meetings do I have today?" or "Show me my upcoming
                events"
              </p>
            </div>
          ) : (
            displayMessages.map((message) => (
              <MessageBubble key={message.id} message={message} />
            ))
          )}
          {isLoading && (
            <div className="flex justify-start">
              <div className="bg-muted rounded-lg px-3 py-2 max-w-[80%] flex items-center gap-2">
                <Loader2 className="h-4 w-4 animate-spin" />
                <span className="text-sm text-muted-foreground">
                  Thinking...
                </span>
              </div>
            </div>
          )}
        </div>

        {/* Error message - hide if it's an Auth0 interrupt (we show the popup instead) */}
        {error && !error.message.startsWith(InterruptionPrefix) && (
          <div className="bg-destructive/10 text-destructive text-sm p-3 rounded-lg">
            Error: {error.message}
          </div>
        )}

        {/* Step-Up Auth Interrupt Handling */}
        {toolInterrupt && (
          <FederatedConnectionPopup interrupt={toolInterrupt} />
        )}

        {/* Input form */}
        <form onSubmit={handleSubmit} className="flex gap-2">
          <Input
            value={input}
            onChange={handleInputChange}
            placeholder="Ask about your calendar..."
            disabled={isLoading}
            className="flex-1"
          />
          <Button
            className="h-10"
            type="submit"
            disabled={isLoading || !input.trim()}
          >
            <Send className="h-4 w-4" />
          </Button>
        </form>
      </CardContent>
    </Card>
  );
}

function MessageBubble({ message }: { message: Message }) {
  const isUser = message.role === "user";

  return (
    <div className={`flex ${isUser ? "justify-end" : "justify-start"}`}>
      <div
        className={`rounded-lg px-3 py-2 max-w-[80%] ${
          isUser ? "bg-primary text-primary-foreground" : "bg-muted"
        }`}
      >
        <p className="text-sm whitespace-pre-wrap">{message.content}</p>
      </div>
    </div>
  );
}
```

### Test your application

1. Start the client and server using Turbo: `npm run dev`.
2. Navigate to `http://localhost:5173`.
3. Log in with Google and ask your AI agent about your calendar.

The application will automatically prompt for additional calendar permissions when needed using Auth0's step-up authorization flow.

That's it! You've successfully integrated federated connections with access tokens into your React SPA + Vercel AI application.

Explore [the example app on GitHub](https://github.com/auth0-lab/auth0-ai-js/tree/main/examples/calling-apis/spa-with-backend-api/react-hono-ai-sdk).
