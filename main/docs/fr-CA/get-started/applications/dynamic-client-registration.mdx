---
title: "Enregistrement dynamique d'applications"
permalink: "dynamic-client-registration"
'description': "Apprenez à enregistrer dynamiquement des applications avec Auth0 en utilisant Management API."
'og:title': "Enregistrement dynamique d'applications"
'og:description': "Apprenez à enregistrer dynamiquement des applications avec Auth0 en utilisant Management API."
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "Enregistrement dynamique d'applications"
'twitter:description': "Apprenez à enregistrer dynamiquement des applications avec Auth0 en utilisant Management API."
---
import {AuthCodeBlock} from "/snippets/AuthCodeBlock.jsx";

import {AuthCodeGroup} from "/snippets/AuthCodeGroup.jsx";

Vous pouvez enregistrer dynamiquement des applications tierces pour votre locataire. Cette fonctionnalité est basée sur la spécification [Enregistrement dynamique du client OpenID Connect](https://openid.net/specs/openid-connect-registration-1_0.html).

## Activer l’enregistrement dynamique des clients

<Warning>

Auth0 prend en charge **Open Dynamic Registration (Enregistrement Dynamique Ouvert)**, ce qui signifie que si vous activez cette fonctionnalité, **n’importe quel utilisateur** pourra créer des applications dans votre locataire sans avoir besoin d’un jeton.

</Warning>

Par défaut, l’enregistrement dynamique d'applications est désactivé pour tous les locataires. Pour changer cela, vous devez définir le drapeau `enable_dynamic_client_registration` sur `true` dans les paramètres de votre locataire.

Pour ce faire, accédez à [Dashboard > Settings (Paramètres) > Advanced (Avancé)](https://manage.auth0.com/#/tenant/advanced) et activez l’option **Enregistrement dynamique de l’application OIDC**.

Vous pouvez également mettre à jour cet indicateur en utilisant le point de terminaison de <Tooltip href="/docs/fr-CA/glossary?term=management-api" tip="Management API
Un produit permettant aux clients d’effectuer des tâches administratives." cta="Voir le glossaire">Management API</Tooltip> [`/Tenant/patch_settings`](/docs/fr-CA/api/management/v2#!/Tenants/patch_settings).

<AuthCodeGroup>
```bash cURL
curl --request PATCH \
  --url 'https://{yourDomain}/api/v2/tenants/settings' \
  --header 'authorization: Bearer API2_ACCESS_TOKEN' \
  --header 'cache-control: no-cache' \
  --header 'content-type: application/json' \
  --data '{ "flags": { "enable_dynamic_client_registration": true } }'
```
```csharp C#
var client = new RestClient("https://{yourDomain}/api/v2/tenants/settings");
var request = new RestRequest(Method.PATCH);
request.AddHeader("content-type", "application/json");
request.AddHeader("authorization", "Bearer API2_ACCESS_TOKEN");
request.AddHeader("cache-control", "no-cache");
request.AddParameter("application/json", "{ "flags": { "enable_dynamic_client_registration": true } }", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```
```go Go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/api/v2/tenants/settings"

	payload := strings.NewReader("{ "flags": { "enable_dynamic_client_registration": true } }")

	req, _ := http.NewRequest("PATCH", url, payload)

	req.Header.Add("content-type", "application/json")
	req.Header.Add("authorization", "Bearer API2_ACCESS_TOKEN")
	req.Header.Add("cache-control", "no-cache")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java
HttpResponse<String> response = Unirest.patch("https://{yourDomain}/api/v2/tenants/settings")
  .header("content-type", "application/json")
  .header("authorization", "Bearer API2_ACCESS_TOKEN")
  .header("cache-control", "no-cache")
  .body("{ "flags": { "enable_dynamic_client_registration": true } }")
  .asString();
```
```javascript Node.JS
var axios = require("axios").default;

var options = {
  method: 'PATCH',
  url: 'https://{yourDomain}/api/v2/tenants/settings',
  headers: {
    'content-type': 'application/json',
    authorization: 'Bearer API2_ACCESS_TOKEN',
    'cache-control': 'no-cache'
  },
  data: {flags: {enable_dynamic_client_registration: true}}
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```objc Obj-C
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"content-type": @"application/json",
                           @"authorization": @"Bearer API2_ACCESS_TOKEN",
                           @"cache-control": @"no-cache" };
NSDictionary *parameters = @{ @"flags": @{ @"enable_dynamic_client_registration": @YES } };

NSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/tenants/settings"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"PATCH"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```
```php PHP
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/api/v2/tenants/settings",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "PATCH",
  CURLOPT_POSTFIELDS => "{ "flags": { "enable_dynamic_client_registration": true } }",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer API2_ACCESS_TOKEN",
    "cache-control: no-cache",
    "content-type: application/json"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python
import http.client

conn = http.client.HTTPSConnection("")

payload = "{ "flags": { "enable_dynamic_client_registration": true } }"

headers = {
    'content-type': "application/json",
    'authorization': "Bearer API2_ACCESS_TOKEN",
    'cache-control': "no-cache"
    }

conn.request("PATCH", "/{yourDomain}/api/v2/tenants/settings", payload, headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```
```ruby Ruby
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/api/v2/tenants/settings")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Patch.new(url)
request["content-type"] = 'application/json'
request["authorization"] = 'Bearer API2_ACCESS_TOKEN'
request["cache-control"] = 'no-cache'
request.body = "{ "flags": { "enable_dynamic_client_registration": true } }"

response = http.request(request)
puts response.read_body
```
```swift Swift
import Foundation

let headers = [
  "content-type": "application/json",
  "authorization": "Bearer API2_ACCESS_TOKEN",
  "cache-control": "no-cache"
]
let parameters = ["flags": ["enable_dynamic_client_registration": true]] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/tenants/settings")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "PATCH"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</AuthCodeGroup>

Vous devez mettre à jour `API2_ACCESS_TOKEN` avec un jeton valide avec la permission `update:tenant_settings`. Pour en savoir plus, lisez [Jetons d’accès à Management API](/docs/fr-CA/secure/tokens/access-tokens/management-api-access-tokens).

## Utiliser l’enregistrement dynamique des clients

Dans cette section, nous verrons comment vous pouvez enregistrer et configurer dynamiquement une application.

### Enregistrer votre application

Pour enregistrer dynamiquement une application avec Auth0, vous devez envoyer un message HTTP `POST` au point de terminaison d’enregistrement de l’application : `https://{yourDomain}/oidc/register`. Notez qu’Auth0 prend en charge **Enregistrement Open Dynamic**, ce qui signifie que le point de terminaison acceptera une demande d’enregistrement sans jeton d’accès.

Pour créer une application portant le nom `Mon application dynamique` et les URL de rappel `https://application.example.com/callback` et `https://application.example.com/callback2`, utilisez l’extrait de code suivant :

<AuthCodeGroup>
```bash cURL
curl --request POST \
  --url 'https://{yourDomain}/oidc/register' \
  --header 'content-type: application/json' \
  --data '{"client_name":"My Dynamic Application","redirect_uris": ["https://application.example.com/callback", "https://application.example.com/callback2"]}'
```
```csharp C#
var client = new RestClient("https://{yourDomain}/oidc/register");
var request = new RestRequest(Method.POST);
request.AddHeader("content-type", "application/json");
request.AddParameter("application/json", "{"client_name":"My Dynamic Application","redirect_uris": ["https://application.example.com/callback", "https://application.example.com/callback2"]}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```
```go Go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/oidc/register"

	payload := strings.NewReader("{"client_name":"My Dynamic Application","redirect_uris": ["https://application.example.com/callback", "https://application.example.com/callback2"]}")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("content-type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java
HttpResponse<String> response = Unirest.post("https://{yourDomain}/oidc/register")
  .header("content-type", "application/json")
  .body("{"client_name":"My Dynamic Application","redirect_uris": ["https://application.example.com/callback", "https://application.example.com/callback2"]}")
  .asString();
```
```javascript Node.JS
var axios = require("axios").default;

var options = {
  method: 'POST',
  url: 'https://{yourDomain}/oidc/register',
  headers: {'content-type': 'application/json'},
  data: {
    client_name: 'My Dynamic Application',
    redirect_uris: [
      'https://application.example.com/callback',
      'https://application.example.com/callback2'
    ]
  }
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```objc Obj-C
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"content-type": @"application/json" };
NSDictionary *parameters = @{ @"client_name": @"My Dynamic Application",
                              @"redirect_uris": @[ @"https://application.example.com/callback", @"https://application.example.com/callback2" ] };

NSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/oidc/register"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"POST"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```
```php PHP
$curl = curl_init();
curl_setopt_array($curl, [
CURLOPT_URL => "https://{yourDomain}/oidc/register",
CURLOPT_RETURNTRANSFER => true,
CURLOPT_ENCODING => "",
CURLOPT_MAXREDIRS => 10,
CURLOPT_TIMEOUT => 30,
CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
CURLOPT_CUSTOMREQUEST => "POST",
CURLOPT_POSTFIELDS => "{"client_name":"My Dynamic Application","redirect_uris": ["https://application.example.com/callback", "https://application.example.com/callback2"]}",
CURLOPT_HTTPHEADER => [
"content-type: application/json"
],
]);
$response = curl_exec($curl);
$err = curl_error($curl);
curl_close($curl);
if ($err) {
echo "cURL Error #:" . $err;
} else {
echo $response;
}
```
```python Python
import http.client
conn = http.client.HTTPSConnection("")
payload = "{"client_name":"My Dynamic Application","redirect_uris": ["https://application.example.com/callback", "https://application.example.com/callback2"]}"
headers = { 'content-type': "application/json" }
conn.request("POST", "/{yourDomain}/oidc/register", payload, headers)
res = conn.getresponse()
data = res.read()
print(data.decode("utf-8"))
```
```ruby Ruby
require 'uri'
require 'net/http'
require 'openssl'
url = URI("https://{yourDomain}/oidc/register")
http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE
request = Net::HTTP::Post.new(url)
request["content-type"] = 'application/json'
request.body = "{"client_name":"My Dynamic Application","redirect_uris": ["https://application.example.com/callback", "https://application.example.com/callback2"]}"
response = http.request(request)
puts response.read_body
```
```swift Swift
import Foundation
let headers = ["content-type": "application/json"]
let parameters = [
"client_name": "My Dynamic Application",
"redirect_uris": ["https://application.example.com/callback", "https://application.example.com/callback2"]
] as [String : Any]
let postData = JSONSerialization.data(withJSONObject: parameters, options: [])
let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/oidc/register")! as URL,
cachePolicy: .useProtocolCachePolicy,
timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data
let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
if (error != nil) {
print(error)
} else {
let httpResponse = response as? HTTPURLResponse
print(httpResponse)
}
})
dataTask.resume()
```
</AuthCodeGroup>

Où :

* **client_name**: nom de l’application dynamique à créer
* **redirect_uris** (obligatoire) : tableau des URL que Auth0 jugera valides à la fin d’un flux d’authentification.

Vous pouvez aussi définir une valeur pour `token_endpoint_auth_method`, qui peut être `none` ou `client_secret_post` (valeur par défaut). Utilisez `token_endpoint_auth_method: none` dans la charge utile de la demande si vous créez une application à page unique.

La réponse comprend les informations de base sur l’application.

```json lines
HTTP/1.1 201 Created
Content-Type: application/json
{
  "client_name": "My Dynamic Application",
  "client_id": "8SXWY6j3afl2CP5ntwEOpMdPxxy49Gt2",
  "client_secret": "Q5O...33P",
  "redirect_uris": [
    "https://application.example.com/callback",
    "https://application.example.com/callback2"
  ],
  "client_secret_expires_at": 0
}
```

Où :

* **client_id** : identifiant unique du client. Il s’agit de l’identifiant que vous utiliserez lors de la configuration de vos applications pour utiliser Auth0. Il est généré par le système et ne peut être modifié.
* **client_secret** : secret client alphanumérique de 64 bits. Cette valeur est utilisée par les applications pour s’authentifier auprès de l’Authentication API [`/token`](/docs/fr-CA/api/authentication#get-token) et pour signer et valider les jetons d’ID.
* **client_secret_expires_at**: heure à laquelle le `client_secret` expirera. Pour Auth0, cette valeur sera toujours égale à zéro (`0`), ce qui signifie que l’application n’expire jamais.

Notez l’ID et le secret client, car ce sont les éléments les plus importants pour l’exécution des flux d’authentification et d’autorisation. Pour en savoir plus, lisez [Flux d’authentification et d’autorisation](/docs/fr-CA/get-started/authentication-and-authorization-flow).

N’oubliez pas non plus que les développeurs tiers ne sont pas autorisés à modifier les paramètres de l’application. Si cela s’avère nécessaire, ils doivent contacter le propriétaire du locataire pour lui faire part de sa demande.

### Configuration de votre application

Maintenant que vous disposez d’un ID et d’un secret client, vous pouvez configurer votre application pour authentifier les utilisateurs avec Auth0.

Nous allons voir un exemple simple, qui montre comment appeler une API à partir d’une application web côté client, en utilisant le [Flux implicite](/docs/fr-CA/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post).

Tout d’abord, vous devez configurer votre application pour envoyer l’utilisateur à l’URL d’autorisation :

export const codeExample21 = `https://{yourDomain}/authorize?
  audience={API_AUDIENCE}&
  scope={SCOPE}&
  response_type={RESPONSE_TYPE}&
  client_id={yourClientId}&
  redirect_uri={https://yourApp/callback}&
  nonce={NONCE}
  state={OPAQUE_VALUE}`;

<AuthCodeBlock children={codeExample21} language="text" lines />

Où :

* **<Tooltip data-tooltip-id="react-containers-DefinitionTooltip-1" tip="">audience</Tooltip>** (facultatif) : API cible pour laquelle l’application demande l’accès au nom de l’utilisateur. Définissez ce paramètre si vous avez besoin d’un accès à l’API.
* **scope** (facultatif) : permissions pour lesquelles vous souhaitez demander une autorisation. Elles doivent être séparées par un espace. Vous pouvez demander l’une des [permissions standard OIDC](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims) pour les utilisateurs, telles que `profile` et `email`, des demandes personnalisées qui doivent se conformer à un format d’espace de noms, ou toute portée prise en charge par l’API cible (par exemple, `read:contacts`). Définissez ce paramètre si vous avez besoin d’un accès à l’API. Pour en savoir plus, lisez [Permissions des API](/docs/fr-CA/get-started/apis/scopes/api-scopes).
* **response_type** : type de réponse. Pour le consentement implicite, vous pouvez utiliser `token` ou `id_token token`. Cela spécifiera le type de jeton que vous recevrez à la fin du flux. Utilisez `token` pour obtenir uniquement un jeton d’accès, ou `id_token token` pour obtenir à la fois un jeton d’ID et un jeton d’accès.
* **client_id** : ID client de votre application.
* **redirect_uri** : URL vers laquelle le serveur d’autorisation (Auth0) redirigera l’agent utilisateur (navigateur) après autorisation par l’utilisateur. Le jeton d’accès (et éventuellement un jeton d’ID) sera disponible dans le fragment de hachage de cette URL. Cette URL doit être spécifiée comme URL de rappel valide dans les **Paramètres d’application** de votre application.
* **État** : valeur opaque que les applications ajoutent à la demande initiale et que le serveur d’autorisation inclut lorsqu’il redirige la demande vers l’application. Cette valeur doit être utilisée par l’application pour prévenir les attaques CSRF.
* **nombre aléatoire** : Une valeur de chaîne qui sera incluse dans la réponse du jeton d’ID d’Auth0, utilisée pour empêcher les attaques par réinsertion du jeton. Elle est nécessaire pour `response_type=id_token token`.

Par exemple :

export const codeExample22 = `<a href="https://{yourDomain}/authorize?scope=appointments%20contacts&audience=appointments:api&response_type=id_token%20token&client_id={yourClientId}&redirect_uri={https://yourApp/callback}">
  Sign In
</a>`;

<AuthCodeBlock children={codeExample22} language="html" />

Cet appel redirigera l’utilisateur vers Auth0 et, en cas d’authentification réussie, vers votre application (c’est-à-dire, vers **redirect_uri**).

Si vous avez besoin d’un accès à l’API, après l’authentification, vous devez extraire le jeton d’accès du fragment de hachage de l’URL et l’utiliser pour effectuer des appels à l’API, en le transmettant en tant que jeton `Bearer` dans l’en-tête `Authorization` de la requête HTTP.

## En savoir plus

* [Applications de première et de tierce partie](/docs/fr-CA/get-started/applications/confidential-and-public-applications/first-party-and-third-party-applications)
* [User Consent and Third-Party Applications (Consentement de l’utilisateur et applications tierces)](/docs/fr-CA/get-started/applications/confidential-and-public-applications/user-consent-and-third-party-applications)