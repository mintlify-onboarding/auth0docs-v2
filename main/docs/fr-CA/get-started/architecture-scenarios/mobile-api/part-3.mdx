---
title: "Configuration API et Mobile (Applications mobiles + API)"
permalink: "part-3"
'description': "Configuration de l’API et mobile pour le scénario d’architecture mobile + API"
'og:title': "Configuration API et Mobile (Applications mobiles + API)"
'og:description': "Configuration de l’API et mobile pour le scénario d’architecture mobile + API"
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "Configuration API et Mobile (Applications mobiles + API)"
'twitter:description': "Configuration de l’API et mobile pour le scénario d’architecture mobile + API"
---
import {AuthCodeBlock} from "/snippets/AuthCodeBlock.jsx";

import {AuthCodeGroup} from "/snippets/AuthCodeGroup.jsx";

Dans cette section, nous verrons comment nous pouvons mettre en œuvre une API pour notre scénario.

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Pour des raisons de simplicité, notre implémentation se concentrera uniquement sur l’authentification et l’autorisation. Comme vous le verrez dans les exemples, l’entrée de la feuille de temps sera codée en dur et l’API ne conservera pas l’entrée de la feuille de temps. Au lieu de cela, elle renverra simplement certaines informations.

</Callout>

## Définir les points de terminaison de l’API

Nous devons d’abord définir les points de terminaison de notre API.

<Card title="Qu’est-ce qu’un point de terminaison d’API?">

Un **point de terminaison d’API**

Par exemple, une API de restaurant pourrait avoir des points de terminaison tels que `/orders` et `/customers`. Une application qui se connecte à cette API peut effectuer des opérations CRUD (create, read, update, delete) en appelant un point de terminaison d’API à l’aide de la méthode HTTP associée (`POST`, `GET`, `PUT`, `PATCH` ou `DELETE`).

</Card>

Pour cette implémentation, nous ne définirons que deux points de terminaison : un pour récupérer une liste de toutes les feuilles de temps d’un employé, et un autre pour permettre à un employé de créer une nouvelle entrée de feuille de temps.

Une requête `HTTP GET` au point de terminaison `/timesheets` permettra à un utilisateur de récupérer ses feuilles de temps, et une requête `HTTP POST` au point de terminaison `/timesheets` permettra à un utilisateur d’ajouter une nouvelle feuille de temps.

Voir l’implémentation dans [Node.js](https://auth0.com/docs/architecture-scenarios/application/mobile-api/api-implementation-nodejs#1-define-the-api-endpoints)

### Sécuriser les points de terminaison

Lorsqu’une API reçoit une requête avec un jeton d’accès porteur dans l’en-tête, la première chose à faire est de valider le jeton. Cette validation consiste en une série d’étapes, et si l’une de ces étapes échoue, la requête doit être rejetée avec un message d’erreur `Missing or invalid token` envoyé à l’application appelante.

Les validations que l’API doit effectuer sont les suivantes :

* Vérifier que le jeton <Tooltip href="/docs/fr-CA/glossary?term=json-web-token" tip="Jeton Web JSON (JWT)
Format standard de jeton d’ID (et souvent de jeton d’accès) utilisé pour représenter en toute sécurité des demandes entre deux parties." cta="Voir le glossaire">JWT</Tooltip> est bien formé
* Vérifier la signature
* Valider les demandes standard

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

[JWT.io](https://jwt.io/) fournit une liste de bibliothèques qui peuvent faire la plupart du travail pour vous : analyser le JWT, vérifier la signature et les demandes.

</Callout>

Une partie du processus de validation consiste également à vérifier les permissions du client, mais nous aborderons cette question séparément dans le prochain paragraphe de ce document.

Pour en savoir plus sur la validation des jetons d’accès, consultez [Valider les jetons d’accès](https://auth0.com/docs/tokens/guides/validate-access-tokens).

Voir l’implémentation dans [Node.js](https://auth0.com/docs/architecture-scenarios/application/mobile-api/api-implementation-nodejs#2-secure-the-api-endpoints)

### Vérifier les permissions du client

Nous avons maintenant vérifié que le jeton JWT est valide. La dernière étape consiste à vérifier que le client dispose des permissions requises pour accéder aux ressources protégées.

Pour ce faire, l’API doit vérifier les permissions du jeton JWT décodé en consultant l’objet [permissions](https://auth0.com/docs/scopes). Cette demande fait partie de la charge utile et il s’agit d’une liste de chaînes séparées par des espaces.

Voir l’implémentation dans [Node.js](https://auth0.com/docs/architecture-scenarios/application/mobile-api/api-implementation-nodejs#3-check-the-client-permissions)

### Déterminer l’identité utilisateur

Pour les deux points de terminaison (récupération de la liste des feuilles de temps et ajout d’une nouvelle feuille de temps), nous devrons déterminer l’identité utilisateur.

Pour récupérer la liste des feuilles de temps, cela permet de s’assurer que nous renvoyons uniquement les feuilles de temps appartenant à l’utilisateur qui fait la demande, et pour ajouter une nouvelle feuille de temps, cela permet de s’assurer que la feuille de temps est associée à l’utilisateur qui fait la demande.

L’une des demandes standard de JWT est la demande `sub` qui détermine le demandeur qui fait l’objet de la demande. Dans le cas du flux d’autorisation implicite, cette demande contiendra l’identité utilisateur, qui sera l’identifiant unique de l’utilisateur Auth0. Vous pouvez l’utiliser pour associer n’importe quelle information dans des systèmes externes à un utilisateur particulier.

Vous pouvez également utiliser une demande personnalisée pour ajouter au jeton d’accès un autre attribut de l’utilisateur, tel que son adresse courriel, et l’utiliser pour identifier l’utilisateur de manière unique.

Voir l’implémentation dans [Node.js](https://auth0.com/docs/architecture-scenarios/application/mobile-api/api-implementation-nodejs#4-determine-the-user-identity)

## Implémenter l’application mobile

Dans cette section, nous verrons comment implémenter une application mobile pour notre scénario.

[Voir l’implémentation dans Android.](https://auth0.com/docs/architecture-scenarios/application/mobile-api/mobile-implementation-android#1-set-up-the-application)

### Autoriser l’utilisateur

Pour autoriser l’utilisateur, nous implémenterons le [Flux de code d’autorisation avec Proof Key for Code Exchange (PKCE)](https://auth0.com/docs/flows/guides/auth-code-pkce/call-api-auth-code-pkce). L’application mobile devrait premièrement envoyer l’utilisateur vers [l’URL d’autorisation](https://auth0.com/docs/api/authentication#authorization-code-grant-pkce-) en plus du `code_challenge` et de la méthode utilisée pour le générer :

export const codeExample1 = `https://{yourDomain}/authorize?
    audience=API_AUDIENCE&
    scope=SCOPE&
    response_type=code&
    client_id={yourClientId}&
    code_challenge=CODE_CHALLENGE&
    code_challenge_method=S256&
    redirect_uri=https://YOUR_APP/callback`;

<AuthCodeBlock children={codeExample1} language="text" lines />

La demande `GET` vers l’URL d’autorisation devrait inclure les valeurs suivantes :

<table class="table"><thead>
<tr>
<th>Paramètre</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>client_id</strong></td>
<td>La valeur de votre ID client Auth0. Vous pouvez la récupérer dans les paramètres de votre application, dans [Auth0 Dashboard] (https://manage.auth0.com/#/applications).</td>
</tr>
<tr>
<td><strong>audience</strong></td>
<td>La valeur de votre identifiant d’API. Vous pouvez la récupérer dans les paramètres de votre API, dans <a href="https://manage.auth0.com/#/apis">Auth0 Dashboard</a>.</td>
</tr>
<tr>
<td><strong>scope</strong></td>
<td>Les <a href="/docs/fr-CA/scopes">permissions</a> qui déterminent les demandes à retourner dans le jeton d’ID et le jeton d’accès. Par exemple, une permission `openid` retournera un jeton d’ID dans la réponse. Dans notre exemple d’application mobile, nous utilisons les permissions suivantes : `create:timesheets read:timesheets openid profile email offline_access`. Ces permissions permettent à l’application mobile d’appeler l’API, d’obtenir une valeur <dfn id="react-containers-DefinitionTooltip-1"><span class="tooltip-portal-underlined-word" data-react-universal-portal="">Jeton d’actualisation</span></dfn> et de retourner les demandes `name`, `picture`, et `email` de l’utilisateur dans le jeton d’ID.</td>
</tr>
<tr>
<td><strong>response_type</strong></td>
<td>Indique le flux d’authentification à utiliser. Pour une application mobile utilisant PKCE, il devrait être défini sur `code`.</td>
</tr>
<tr>
<td><strong>code_challenge</strong></td>
<td>Le défi-réponse de code généré par le vérificateur de code. Vous trouverez des instructions sur la génération d’un défi-réponse de code <a href="/docs/fr-CA/flows/guides/auth-code-pkce/call-api-auth-code-pkce#authorize-the-user#create-a-code-verifier">ici</a>.</td>
</tr>
<tr>
<td><strong>code_challenge_method</strong></td>
<td>Méthode utilisée pour générer le défi-réponse. Auth0 prend en charge seulement `S256`.</td>
</tr>
<tr>
<td><strong>redirect_uri</strong></td>
<td>L’URL vers lequel Auth0 redirigera le navigateur une fois la permission accordée par l’utilisateur. Le code d’autorisation sera indiqué dans le paramètre d’URL du code. Cette URL doit être définie en tant qu’URL de rappel valide dans vos <a href="https://manage.auth0.com/#/applications">paramètres de l’application</a>.</td>
</tr>
</tbody>
</table>

[Voir l’implémentation dans Android.](https://auth0.com/docs/architecture-scenarios/application/mobile-api/mobile-implementation-android#2-authorize-the-user)

### Obtenir les identifiants

Après une demande réussie à l’URL d’autorisation, vous devriez recevoir la réponse suivante :

export const codeExample2 = `HTTP/1.1 302 Found
Location: https://{yourDomain}/callback?code=AUTHORIZATION_CODE`;

<AuthCodeBlock children={codeExample2} language="text" lines />

Ensuite vous pouvez échanger le `authorization_code` de la réponse pour un jeton d’accès qui peut être utilisé pour appeler votre API. Réalisez une demande `POST` à l’[URL du jeton](/docs/fr-CA/api/authentication#authorization-code-pkce-) incluant les données suivantes :

<AuthCodeGroup>
```bash cURL
curl --request POST \
  --url 'https://{yourDomain}/oauth/token' \
  --header 'content-type: application/x-www-form-urlencoded' \
  --data grant_type=authorization_code \
  --data 'client_id={yourClientId}' \
  --data code_verified=YOUR_GENERATED_CODE_VERIFIER \
  --data code=YOUR_AUTHORIZATION_CODE \
  --data 'redirect_uri=https://{https://yourApp/callback}'
```
```csharp C#
var client = new RestClient("https://{yourDomain}/oauth/token");
var request = new RestRequest(Method.POST);
request.AddHeader("content-type", "application/x-www-form-urlencoded");
request.AddParameter("application/x-www-form-urlencoded", "grant_type=authorization_code&client_id={yourClientId}&code_verified=YOUR_GENERATED_CODE_VERIFIER&code=YOUR_AUTHORIZATION_CODE&redirect_uri=https%3A%2F%2F{https://yourApp/callback}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```
```go Go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/oauth/token"

	payload := strings.NewReader("grant_type=authorization_code&client_id={yourClientId}&code_verified=YOUR_GENERATED_CODE_VERIFIER&code=YOUR_AUTHORIZATION_CODE&redirect_uri=https%3A%2F%2F{https://yourApp/callback}")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("content-type", "application/x-www-form-urlencoded")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java
HttpResponse response = Unirest.post("https://{yourDomain}/oauth/token")
  .header("content-type", "application/x-www-form-urlencoded")
  .body("grant_type=authorization_code&client_id={yourClientId}&code_verified=YOUR_GENERATED_CODE_VERIFIER&code=YOUR_AUTHORIZATION_CODE&redirect_uri=https%3A%2F%2F{https://yourApp/callback}")
  .asString();
```
```javascript Node.JS
var axios = require("axios").default;

var options = {
  method: 'POST',
  url: 'https://{yourDomain}/oauth/token',
  headers: {'content-type': 'application/x-www-form-urlencoded'},
  data: new URLSearchParams({
    grant_type: 'authorization_code',
    client_id: '{yourClientId}',
    code_verified: 'YOUR_GENERATED_CODE_VERIFIER',
    code: 'YOUR_AUTHORIZATION_CODE',
    redirect_uri: 'https://{https://yourApp/callback}'
  })
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```objc Obj-C
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"content-type": @"application/x-www-form-urlencoded" };

NSMutableData *postData = [[NSMutableData alloc] initWithData:[@"grant_type=authorization_code" dataUsingEncoding:NSUTF8StringEncoding]];
[postData appendData:[@"&client_id={yourClientId}" dataUsingEncoding:NSUTF8StringEncoding]];
[postData appendData:[@"&code_verified=YOUR_GENERATED_CODE_VERIFIER" dataUsingEncoding:NSUTF8StringEncoding]];
[postData appendData:[@"&code=YOUR_AUTHORIZATION_CODE" dataUsingEncoding:NSUTF8StringEncoding]];
[postData appendData:[@"&redirect_uri=https://{https://yourApp/callback}" dataUsingEncoding:NSUTF8StringEncoding]];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/oauth/token"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"POST"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```
```php PHP
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/oauth/token",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "POST",
  CURLOPT_POSTFIELDS => "grant_type=authorization_code&client_id={yourClientId}&code_verified=YOUR_GENERATED_CODE_VERIFIER&code=YOUR_AUTHORIZATION_CODE&redirect_uri=https%3A%2F%2F{https://yourApp/callback}",
  CURLOPT_HTTPHEADER => [
    "content-type: application/x-www-form-urlencoded"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python
import http.client

conn = http.client.HTTPSConnection("")

payload = "grant_type=authorization_code&client_id={yourClientId}&code_verified=YOUR_GENERATED_CODE_VERIFIER&code=YOUR_AUTHORIZATION_CODE&redirect_uri=https%3A%2F%2F{https://yourApp/callback}"

headers = { 'content-type': "application/x-www-form-urlencoded" }

conn.request("POST", "/{yourDomain}/oauth/token", payload, headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```
```ruby Ruby
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/oauth/token")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Post.new(url)
request["content-type"] = 'application/x-www-form-urlencoded'
request.body = "grant_type=authorization_code&client_id={yourClientId}&code_verified=YOUR_GENERATED_CODE_VERIFIER&code=YOUR_AUTHORIZATION_CODE&redirect_uri=https%3A%2F%2F{https://yourApp/callback}"

response = http.request(request)
puts response.read_body
```
```swift Swift
import Foundation

let headers = ["content-type": "application/x-www-form-urlencoded"]

let postData = NSMutableData(data: "grant_type=authorization_code".data(using: String.Encoding.utf8)!)
postData.append("&client_id={yourClientId}".data(using: String.Encoding.utf8)!)
postData.append("&code_verified=YOUR_GENERATED_CODE_VERIFIER".data(using: String.Encoding.utf8)!)
postData.append("&code=YOUR_AUTHORIZATION_CODE".data(using: String.Encoding.utf8)!)
postData.append("&redirect_uri=https://{https://yourApp/callback}".data(using: String.Encoding.utf8)!)

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/oauth/token")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</AuthCodeGroup>

<table class="table"><thead>
<tr>
<th>Paramètre</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>grant_type</strong></td>
<td>Ce paramètre doit être défini sur `authorization_code`.</td>
</tr>
<tr>
<td><strong>client_id</strong></td>
<td>La valeur de votre ID client Auth0. Vous pouvez le récupérer dans les paramètres de votre application sur le <a href="https://manage.auth0.com/#/applications">Auth0 Dashboard</a>.</td>
</tr>
<tr>
<td><strong>code_verifier</strong></td>
<td>Clé cryptographiquement aléatoire utilisée pour générer le `code_challenge` transmis à <a href="/docs/fr-CA/api/authentication#authorization-code-grant-pkce-">authorization URL</a> (`/authorize`).</td>
</tr>
<tr>
<td><strong>code</strong></td>
<td>Le `authorization_code` reçu de l’appel d’autorisation précédent.</td>
</tr>
<tr>
<td><strong>redirect_uri</strong></td>
<td>L’URL doit correspondre au `redirect_uri` de la section précédente à `/authorize`.</td>
</tr>
</tbody>
</table>

La réponse de l’URL du jeton comprendra :

```json lines
{
  "access_token": "eyJz93a...k4laUWw",
  "refresh_token": "GEbRxBN...edjnXbL",
  "id_token": "eyJ0XAi...4faeEoQ",
  "token_type": "Bearer",
  "expires_in":86400
}
```

* **access_token**: Un jeton d’accès pour l’API, spécifié par l’objet `audience`.
* **refresh_token**: Un [jeton d’actualisation](/docs/fr-CA/tokens/concepts/refresh-tokens) ne sera présent que si vous avez inclus la permission `offline_access` ET activé **Autoriser l’accès hors ligne** pour votre API dans le Dashboard.
* **id_token** : Un jeton d’ID JWT contenant des informations de profil utilisateur.
* **token_type** : Un lien contenant le type de jeton, ce sera toujours un jeton du porteur.
* **expires_in** : Temps en secondes avant l’expiration du jeton d’accès.

Vous devrez stocker les identifiants ci-dessus dans le stockage local pour pouvoir appeler votre API et récupérer le profil utilisateur.

[Voir l’implémentation dans Android](https://auth0.com/docs/architecture-scenarios/application/mobile-api/mobile-implementation-android#store-credentials).

### Obtenez le profil utilisateur

Pour récupérer le [Profil utilisateur](https://auth0.com/docs/api/authentication?http#user-profile), votre application mobile peut décoder le [jeton d’ID](https://auth0.com/docs/tokens/concepts/id-tokens) à l’aide de l’une des [bibliothèques JWT](https://jwt.io/#libraries-io). Ceci est réalisé en [vérifiant la signature](https://auth0.com/docs/tokens/guides/validate-id-token#verify-the-signature) et en [vérifiant les demandes](https://auth0.com/docs/tokens/guides/validate-id-token#verify-the-claims) du jeton. Une fois le jeton d’ID validé, vous pouvez accéder sa charge utile contenant les informations suivantes sur l’utilisateur :

```json lines
{
  "email_verified": false,
  "email": "test.account@userinfo.com",
  "clientID": "q2hnj2iu...",
  "updated_at": "2016-12-05T15:15:40.545Z",
  "name": "test.account@userinfo.com",
  "picture": "https://s.gravatar.com/avatar/dummy.png",
  "user_id": "auth0|58454...",
  "nickname": "test.account",
  "created_at": "2016-12-05T11:16:59.640Z",
  "sub": "auth0|58454..."
}
```

[Voir l’implémentation dans Android.](https://auth0.com/docs/architecture-scenarios/application/mobile-api/mobile-implementation-android#3-get-the-user-profile)

### Afficher les éléments de l’interface utilisateur de manière conditionnelle en fonction de la permission

Selon la permission de l’utilisateur visible dans l’objet `scope`, vous pouvez afficher ou masquer certains éléments de l’interface utilisateur. Pour déterminer la permission accordée à un utilisateur, vous devrez inspecter la `permission` octroyée quand l’utilisateur a été authentifié. Il s’agira d’un lien contenant toutes les permissions, vous devez donc l’inspecter pour voir s’il contient la `permission` requise et, sur cette base, prendre la décision d’afficher ou non un élément d’interface utilisateur particulier.

[Voir l’implémentation dans Android](https://auth0.com/docs/architecture-scenarios/application/mobile-api/mobile-implementation-android#4-display-ui-elements-conditionally-based-on-scope)

### Appeler l’API

Pour accéder aux ressources sécurisées à partir de votre API, le jeton d’accès de l’utilisateur authentifié doit être inclus dans les demandes qui lui sont envoyées. Pour ce faire, il faut envoyer le jeton d’accès dans un en-tête `Authorization` à l’aide du schéma `Bearer`.

[Voir l’implémentation dans Android.](https://auth0.com/docs/architecture-scenarios/application/mobile-api/mobile-implementation-android#5-call-the-api)

### Renouveler le jeton

<Warning>

Les applications doivent stocker les jetons d’actualisation en toute sécurité car ils n’expirent pas et permettent à un utilisateur de rester authentifié pratiquement indéfiniment. Si les jetons d’actualisation sont compromis ou ne vous sont plus utiles, vous pouvez les révoquer à l’aide de l’[Authentication API](/docs/fr-CA/api/authentication#revoke-refresh-token).

</Warning>

Pour actualiser votre jeton d’accès, effectuez une demande `POST` au point de terminaison `/oauth/token` à l’aide du jeton d’actualisation de votre résultat d’autorisation.

Un [Jeton d’actualisation](https://auth0.com/docs/tokens/concepts/refresh-tokens) ne sera présent que si vous avez inclus la permission `offline_access` dans la demande d’autorisation précédente et activé **Autoriser l’accès hors ligne** pour votre API dans le Dashboard.

Votre demande devrait comprendre :

<AuthCodeGroup>
```bash cURL
curl --request POST \
  --url 'https://{yourDomain}/oauth/token' \
  --header 'content-type: application/x-www-form-urlencoded'
```
```csharp C#
var client = new RestClient("https://{yourDomain}/oauth/token");
var request = new RestRequest(Method.POST);
request.AddHeader("content-type", "application/x-www-form-urlencoded");
IRestResponse response = client.Execute(request);
```
```go Go
package main

import (
	"fmt"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/oauth/token"

	req, _ := http.NewRequest("POST", url, nil)

	req.Header.Add("content-type", "application/x-www-form-urlencoded")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java
HttpResponse response = Unirest.post("https://{yourDomain}/oauth/token")
  .header("content-type", "application/x-www-form-urlencoded")
  .asString();
```
```javascript Node.JS
var axios = require("axios").default;

var options = {
  method: 'POST',
  url: 'https://{yourDomain}/oauth/token',
  headers: {'content-type': 'application/x-www-form-urlencoded'}
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```objc Obj-C
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"content-type": @"application/x-www-form-urlencoded" };

NSData *postData = [[NSData alloc] initWithData:[@"undefined" dataUsingEncoding:NSUTF8StringEncoding]];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/oauth/token"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"POST"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```
```php PHP
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/oauth/token",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "POST",
  CURLOPT_HTTPHEADER => [
    "content-type: application/x-www-form-urlencoded"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python
import http.client

conn = http.client.HTTPSConnection("")

headers = { 'content-type': "application/x-www-form-urlencoded" }

conn.request("POST", "/{yourDomain}/oauth/token", headers=headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```
```ruby Ruby
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/oauth/token")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Post.new(url)
request["content-type"] = 'application/x-www-form-urlencoded'

response = http.request(request)
puts response.read_body
```
```swift Swift
import Foundation

let headers = ["content-type": "application/x-www-form-urlencoded"]

let postData = NSData(data: "undefined".data(using: String.Encoding.utf8)!)

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/oauth/token")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</AuthCodeGroup>

<table class="table"><thead>
<tr>
<th>Paramètre</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>grant_type</strong></td>
<td>Doit être réglé sur `refresh_token`.</td>
</tr>
<tr>
<td><strong>client_id</strong></td>
<td>La valeur de l’ID client Auth0. Vous pouvez l’obtenir dans les paramètres de votre application, dans <a href="https://manage.auth0.com/#/applications">Auth0 Dashboard</a>.</td>
</tr>
<tr>
<td><strong>refresh_token</strong></td>
<td>Le jeton d’actualisation à utiliser, à partir du résultat de l’authentification précédente.</td>
</tr>
</tbody>
</table>

La réponse comprendra le nouveau jeton d’accès :

```json lines
{
  "access_token": "eyJz93a...k4laUWw",
  "refresh_token": "GEbRxBN...edjnXbL",
  "id_token": "eyJ0XAi...4faeEoQ",
  "token_type": "Bearer",
  "expires_in":86400
}
```

[Voir l’implémentation dans Android.](https://auth0.com/docs/architecture-scenarios/application/mobile-api/mobile-implementation-android#store-the-credentials)