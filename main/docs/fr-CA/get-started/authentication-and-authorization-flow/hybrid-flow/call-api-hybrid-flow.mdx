---
title: "Appeler votre API à l’aide du flux hybride"
permalink: "call-api-hybrid-flow"
'description': "Découvrez comment exécuter le flux hybride afin que votre application puisse utiliser un jeton d’ID pour accéder aux informations sur l’utilisateur tout en obtenant un code d’autorisation pouvant être échangé contre un jeton d’accès."
'og:title': "Appeler votre API à l’aide du flux hybride"
'og:description': "Découvrez comment exécuter le flux hybride afin que votre application puisse utiliser un jeton d’ID pour accéder aux informations sur l’utilisateur tout en obtenant un code d’autorisation pouvant être échangé contre un jeton d’accès."
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "Appeler votre API à l’aide du flux hybride"
'twitter:description': "Découvrez comment exécuter le flux hybride afin que votre application puisse utiliser un jeton d’ID pour accéder aux informations sur l’utilisateur tout en obtenant un code d’autorisation pouvant être échangé contre un jeton d’accès."
---
import {AuthCodeBlock} from "/snippets/AuthCodeBlock.jsx";

import {AuthCodeGroup} from "/snippets/AuthCodeGroup.jsx";

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Ce tutoriel vous aidera à appeler votre propre API à l’aide du flux Hybride. Pour en savoir plus sur le fonctionnement du flux et pourquoi l’utiliser, voir [Flux hybride](/docs/fr-CA/get-started/authentication-and-authorization-flow/hybrid-flow).

</Callout>

Auth0 permet à votre application d’implémenter facilement le flux de code d’autorisation en utilisant :

* [Authentication API](/docs/fr-CA/api/authentication) : Si vous préférez créer votre propre solution, poursuivez la lecture pour savoir comment appeler notre API directement.

## Prérequis

**Avant de commencer ce tutoriel :**

* [Enregistrez votre application auprès d’Auth0](/docs/fr-CA/get-started/auth0-overview/create-applications/regular-web-apps).

  + Sélectionnez le **Type d’application** approprié.
  + Ajoutez une **URL de rappel autorisée** de `{https://yourApp/callback}`.
  + Assurez-vous que les **Types d’autorisation** de votre application englobent **Implicit** (Implicite) et le **code d’autorisation**. Pour en savoir plus, lisez [Mettre à jour les types d’autorisation](/docs/fr-CA/get-started/applications/update-grant-types).
  + Si vous souhaitez que votre application puisse utiliser des jetons d’actualisation, assurez-vous que les **types d’autorisation** de l’application comprennent le **jeton d’actualisation**. Pour en savoir plus, lisez [Mettre à jour les types d’autorisation](/docs/fr-CA/get-started/applications/update-grant-types). Pour en savoir plus sur les jetons d’actualisation, lisez [Jetons d’actualisation](/docs/fr-CA/secure/tokens/refresh-tokens).
* [Enregistrez votre application auprès d’Auth0](/docs/fr-CA/get-started/auth0-overview/set-up-apis)

  + Si vous voulez que votre API reçoive des jetons d’actualisation afin d’obtenir de nouveaux jetons lorsque les précédents expirent, activez **Autoriser l’accès hors ligne**.

## Étapes

1. [Autoriser l’utilisateur](#authorize-user) :
   Demandez l’autorisation de l’utilisateur et redirigez-le vers votre application à l’aide d’un code d’autorisation.
2. [Demande de jetons](#request-tokens) :
   Échange d’un code d’autorisation contre des jetons.
3. [Appel d’API](#call-api) :
   Servez-vous du jeton d’accès récupéré pour appeler votre API.
4. [Jetons d’actualisation](#refresh-tokens) :
   Utilisez un jeton d’actualisation pour demander de nouveaux jetons lorsque les jetons existants expirent.

Facultatif : [Découvrez des cas d’utilisation](#sample-use-cases)

### Autoriser l’utilisateur

Cette étape peut comprendre un ou plusieurs des procédés suivant :

* Authentifier l’utilisateur
* Redirection de l’utilisateur vers un fournisseur d’identité pour gérer l’authentification
* Vérification des sessions actives d’authentification unique (<Tooltip href="/docs/fr-CA/glossary?term=single-sign-on" tip="Authentification unique (SSO)
Service qui, après qu’un utilisateur se soit connecté à une application, le connecte automatiquement à d’autres applications." cta="Voir le glossaire">SSO</Tooltip>)
* Obtenir le consentement de l’utilisateur pour le niveau de permission demandé, sauf si obtenu précédemment.

Pour autoriser l’utilisateur, votre application doit envoyer l’utilisateur à l’[URL d’autorisation](/docs/fr-CA/api/authentication#authorization-code-grant).

#### Exemple d’URL d’autorisation

export const codeExample1 = `https://{yourDomain}/authorize?
    response_type=YOUR_RESPONSE_TYPE&
    response_mode=form_post&
    client_id={yourClientId}&
    redirect_uri={https://yourApp/callback}&
    scope=SCOPE&
    audience=API_AUDIENCE&
    state=STATE&
    nonce=NONCE`;

<AuthCodeBlock children={codeExample1} language="text" lines />

##### Paramètres

Notez que pour autoriser un utilisateur lors de l’appel d’une API personnalisée, vous :

- devez inclure un paramètre d’<Tooltip data-tooltip-id="react-containers-DefinitionTooltip-1" tip="">audience</Tooltip>
- pouvez inclure des permissions supplémentaires prises en charge par l’API cible

<table class="table"><thead>
<tr>
<th>Nom du paramètre</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>`response_type`</td>
<td>Indique le type d’identifiant qu’Auth0 va retourner (code ou jeton). Pour ce flux, la valeur doit inclure `code`, mais peut aussi inclure `id_token`, `token`, ou `id_token token`. Spécifiquement, `id_token` renvoie un jeton d’ID, et `token` renvoie un jeton d’accès.</td>
</tr>
<tr>
<td>`response_mode`</td>
<td>Spécifie la méthode avec laquelle les paramètres de réponse doivent être retournés. Pour des raisons de sécurité, la valeur doit être `response_mode`. Dans ce mode, les paramètres de réponse seront chiffrés comme des valeurs de formulaire HTML qui sont transmises via la méthode HTTP POST et chiffrées dans le corps en utilisant le format `application/x-www-form-urlencoded`</td>
</tr>
<tr>
<td>`client_id`</td>
<td>L’ID client de votre application. Vous pouvez trouver cette valeur dans les <a href="https://manage.auth0.com/#/Applications/{yourClientId}/settings">paramètres de l’application</a>.</td>
</tr>
<tr>
<td>`redirect_uri`</td>
<td>URL vers laquelle Auth0 redirigera le navigateur après que l’autorisation ait été accordée par l’utilisateur. Le code d’autorisation sera disponible dans le paramètre `code` de l’URL. Vous devez spécifier cette URL en tant qu’URL de rappel valide dans les <a href="https://manage.auth0.com/#/Applications/{yourClientId}/settings">paramètre de l’application</a>. &lt;br /&amp;gt ; &lt;br /&amp;gt ; <strong>Attention:</strong> Conformément à la <a href="https://tools.ietf.org/html/rfc6749#section-3.1.2">spécification OAuth 2.0</a>, Auth0 supprime tout ce qui se trouve après le hachage et n’accepte <em>pas</em> les fragments.</td>
</tr>
<tr>
<td>`scope`</td>
<td>Indique les <a href="/docs/fr-CA/permissions">permissions</a> pour lesquels vous souhaitez demander une autorisation, ce qui dicte les demandes (ou les attributs d’utilisateur) que vous souhaitez voir renvoyées. Ils doivent être séparés par un espace. Vous pouvez demander n’importe lequel des <a href="https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims">permissions standards d’OpenID Connect (OIDC)</a> sur les utilisateurs, comme `profile` (profil) ou `email` (adresse courriel), des <a href="/docs/fr-CA/tokens/concepts/jwt-claims#custom-claims">demandes personnalisées</a> conformes à un <a href="/docs/fr-CA/tokens/guides/create-namespaced-custom-claims">format namespace</a>, ou n’importe quelles permissions prises en charge par l’API cible (par exemple,`read:contacts`). Incluez `offline_access` pour obtenir un &lt;dfn data-key=« refresh-token »&gt;Jeton d’actualisation&lt;/dfn&amp;gt ; (assurez-vous que le champ <strong>Allow Offline Access</strong> est activé dans les <a href="https://manage.auth0.com/#/applications">paramètres de l’application</a>).</td>
</tr>
<tr>
<td>`audience`</td>
<td>L’identifiant unique de l’API à laquelle votre application veut accéder. Utilisez la valeur de <strong>l’identifiant</strong> dans l’onglet <a href="/docs/fr-CA/Param%C3%A8tres">Settings</a>(https://manage.auth0.com/#/apis) pour l’API que vous avez créée dans le cadre des prérequis de ce tutoriel.</td>
</tr>
<tr>
<td>`state`</td>
<td>(recommandé) Une chaîne alphanumérique arbitraire opaque que votre application ajoute à la requête initiale qu’Auth0 inclut lorsqu’elle redirige vers votre application. Pour voir comment utiliser cette valeur pour prévenir les attaques par falsification de requête intersites , voir la section <a href="/docs/fr-CA/protocols/oauth2/mitigate-csrf-attacks">Atténuer les attaques par falsification de requête intersites avec les paramètres d’état</a>.</td>
</tr>
<tr>
<td>`nonce`</td>
<td>Une chaîne cryptographiquement aléatoire que votre application ajoute à la requête initiale et qu’Auth0 inclut dans le jeton d’ID, <a href="/docs/fr-CA/api-auth/tutorials/nonce">utilisée pour prévenir les attaques par réinsertion de jeton</a>.</td>
</tr>
<tr>
<td>`organization`</td>
<td>(facultatif) Identifiant de l’organisation à utiliser pour authentifier un utilisateur. S’il n’est pas fourni et que votre application est configurée pour <strong>afficher l’invite de l’organisation</strong>, l’utilisateur pourra entrer le nom de l’organisation lors de l’authentification.</td>
</tr>
<tr>
<td>`invitation`</td>
<td>(facultatif) Identifiant du ticket d’invitation de l’organisation. Lorsque vous <a href="/docs/fr-CA/organizations/invite-members">invitez un membre à rejoindre une organisation</a>, votre application doit gérer l’acceptation de l’invitation en transmettant les combinaisons de valeurs clés `invitations` et `organization` quand l’utilisateur accepte l’invitation.</td>
</tr>
</tbody>
</table>

Par exemple, votre code HTML pour l’URL d’autorisation lors de l’ajout d’une connexion à votre application pourrait ressembler à ceci :

export const codeExample2 = `<a href="https://{yourDomain}/authorize?
  response_type=code id_token token&
  client_id={yourClientId}&
  redirect_uri={https://yourApp/callback}&  
  scope=appointments%20contacts&
  audience=appointments:api&
  state=xyzABC123&
  nonce=eq...hPmz">
  Sign In
</a>`;

<AuthCodeBlock children={codeExample2} language="html" />

#### Réponse

Si tout se passe bien, vous recevrez une réponse `HTTP 302`. Les informations d’identification demandées sont codées dans le corps du texte :

``` lines
HTTP/1.1 302 Found
Content-Type: application/x-www-form-urlencoded
code=AUTHORIZATION_CODE&
access_token=ey...MhPw
&expires_in=7200
&token_type=Bearer
id_token=eyJ...acA&
state=xyzABC123
```

Notez que les valeurs renvoyées dépendent de ce que vous avez demandé comme `response_type`.

<table class="table"><thead>
<tr>
<th>Type de réponse</th>
<th>Composants</th>
</tr>
</thead>
<tbody>
<tr>
<td>`code  `</td>
<td>Code d’autorisation</td>
</tr>
<tr>
<td>`id_token `</td>
<td>Jeton d’ID</td>
</tr>
<tr>
<td>`token `</td>
<td>Jeton d’accès (et valeurs `expires_in` et `token_type`)</td>
</tr>
<tr>
<td>`id_token token`</td>
<td>Jeton d’ID, Jeton d’accès (et valeurs `expires_in` et `token_type`)</td>
</tr>
</tbody>
</table>

Auth0 renverra également toute valeur d’état que vous avez incluse dans votre appel à l’URL d’autorisation.

<Warning>

Le jeton d’accès que vous recevez dans le cadre de cette transaction n’est que le premier à vous être attribué. Nous vous déconseillons de l’utiliser pour appeler des API.

</Warning>

<Warning>

Validez vos jetons avant de les enregistrer. Pour en savoir plus, lisez [Valider les jetons d’ID](/docs/fr-CA/secure/tokens/id-tokens/validate-id-tokens) et [Valider les jetons d’accès](/docs/fr-CA/secure/tokens/access-tokens/validate-access-tokens).

</Warning>

Lorsque vous décodez et analysez votre jeton d’ID, vous remarquerez une demande supplémentaire, `c_hash`, qui contient un hachage du `code`. Cette demande est obligatoire lorsqu’un jeton d’ID est émis en même temps qu’un `code` et que vous devez le valider :

1. À l’aide de l’algorithme de hachage spécifié dans la demande `alg` dans l’en-tête jeton d’ID, hachez les octets de la représentation ASCII du `code`.
2. Base64url code la moitié la plus à gauche du hachage.
3. Vérifiez que le résultat correspond à la valeur `c_hash`.

### Demander des jetons

Maintenant que vous avez un code d’authentification, vous pouvez l’échanger pour des jetons. En utilisant le code d’autorisation (`code`) extrait de l’étape précédente, vous devrez `POST` sur [l’URL du jeton](/docs/fr-CA/api/authentication#authorization-code).

Le jeton d’accès que vous recevez à cette étape est celui que vous devez utiliser pour appeler votre API. Assurez-vous de le conserver séparément du jeton d’accès que vous avez reçu à l’étape précédente de ce tutoriel.

#### Exemple de POST à une URL de jeton

<AuthCodeGroup>
```bash cURL
curl --request POST \
  --url 'https://{yourDomain}/oauth/token' \
  --header 'content-type: application/x-www-form-urlencoded' \
  --data grant_type=authorization_code \
  --data 'client_id={yourClientId}' \
  --data 'client_secret={yourClientSecret}' \
  --data 'code=yourAuthorizationCode}' \
  --data 'redirect_uri={https://yourApp/callback}'
```
```csharp C#
var client = new RestClient("https://{yourDomain}/oauth/token");
var request = new RestRequest(Method.POST);
request.AddHeader("content-type", "application/x-www-form-urlencoded");
request.AddParameter("application/x-www-form-urlencoded", "grant_type=authorization_code&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&code=yourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```
```go Go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/oauth/token"

	payload := strings.NewReader("grant_type=authorization_code&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&code=yourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("content-type", "application/x-www-form-urlencoded")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java
HttpResponse response = Unirest.post("https://{yourDomain}/oauth/token")
  .header("content-type", "application/x-www-form-urlencoded")
  .body("grant_type=authorization_code&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&code=yourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}")
  .asString();
```
```javascript Node.JS
var axios = require("axios").default;

var options = {
  method: 'POST',
  url: 'https://{yourDomain}/oauth/token',
  headers: {'content-type': 'application/x-www-form-urlencoded'},
  data: new URLSearchParams({
    grant_type: 'authorization_code',
    client_id: '{yourClientId}',
    client_secret: '{yourClientSecret}',
    code: 'yourAuthorizationCode}',
    redirect_uri: '{https://yourApp/callback}'
  })
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```objc Obj-C
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"content-type": @"application/x-www-form-urlencoded" };

NSMutableData *postData = [[NSMutableData alloc] initWithData:[@"grant_type=authorization_code" dataUsingEncoding:NSUTF8StringEncoding]];
[postData appendData:[@"&client_id={yourClientId}" dataUsingEncoding:NSUTF8StringEncoding]];
[postData appendData:[@"&client_secret={yourClientSecret}" dataUsingEncoding:NSUTF8StringEncoding]];
[postData appendData:[@"&code=yourAuthorizationCode}" dataUsingEncoding:NSUTF8StringEncoding]];
[postData appendData:[@"&redirect_uri={https://yourApp/callback}" dataUsingEncoding:NSUTF8StringEncoding]];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/oauth/token"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"POST"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```
```php PHP
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/oauth/token",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "POST",
  CURLOPT_POSTFIELDS => "grant_type=authorization_code&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&code=yourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}",
  CURLOPT_HTTPHEADER => [
    "content-type: application/x-www-form-urlencoded"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python
import http.client

conn = http.client.HTTPSConnection("")

payload = "grant_type=authorization_code&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&code=yourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}"

headers = { 'content-type': "application/x-www-form-urlencoded" }

conn.request("POST", "/{yourDomain}/oauth/token", payload, headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```
```ruby Ruby
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/oauth/token")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Post.new(url)
request["content-type"] = 'application/x-www-form-urlencoded'
request.body = "grant_type=authorization_code&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&code=yourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}"

response = http.request(request)
puts response.read_body
```
```swift Swift
import Foundation

let headers = ["content-type": "application/x-www-form-urlencoded"]

let postData = NSMutableData(data: "grant_type=authorization_code".data(using: String.Encoding.utf8)!)
postData.append("&client_id={yourClientId}".data(using: String.Encoding.utf8)!)
postData.append("&client_secret={yourClientSecret}".data(using: String.Encoding.utf8)!)
postData.append("&code=yourAuthorizationCode}".data(using: String.Encoding.utf8)!)
postData.append("&redirect_uri={https://yourApp/callback}".data(using: String.Encoding.utf8)!)

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/oauth/token")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</AuthCodeGroup>

##### Paramètres

<table class="table"><thead>
<tr>
<th>Nom de paramètres</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>`grant_type`</td>
<td>Définir sur `authorization_code`.</td>
</tr>
<tr>
<td>`code`</td>
<td>`authorization_code` récupéré à l’étape précédente de ce tutoriel.</td>
</tr>
<tr>
<td>`client_id`</td>
<td>L’ID client de votre application. Vous pouvez trouver cette valeur dans les <a href="https://manage.auth0.com/#/Applications/{yourClientId}/settings">paramètres de votre application</a>.</td>
</tr>
<tr>
<td>`client_secret`</td>
<td>Le secret client de votre application. Vous pouvez trouver cette valeur dans les <a href="https://manage.auth0.com/#/Applications/{yourClientId}/settings">paramètres de votre application</a>.  Pour en savoir plus sur les méthodes d’authentification d’application disponibles, lisez <a href="/docs/fr-CA/secure/application-credentials">Identifiants d’applications</a>.</td>
</tr>
<tr>
<td>`redirect_uri`</td>
<td>L’URL de rappel valide définie dans les paramètres de votre Application. Cela doit correspondre exactement à `redirect_uri` passé à l’ URL d’autorisation à l’étape précédente de ce tutoriel. Notez que cela doit être codé URL.</td>
</tr>
</tbody>
</table>

#### Réponse

Si tout se passe bien, vous recevrez une réponse `HTTP 200` avec une charge utile contenant les valeurs `access_token`, `refresh_token`, `id_token` et`token_type` :

```javascript lines
{
  "access_token": "eyJz93a...k4laUWw",
  "refresh_token": "GEbRxBN...edjnXbL",
  "id_token": "eyJ0XAi...4faeEoQ",
  "token_type": "Bearer"
}
```

<Warning>

Validez vos jetons avant de les enregistrer. Pour en savoir plus, lisez [Valider les jetons d’ID](/docs/fr-CA/secure/tokens/id-tokens/validate-id-tokens) et [Valider les jetons d’accès](/docs/fr-CA/secure/tokens/access-tokens/validate-access-tokens).

</Warning>

Les [Jetons d’ID](/docs/fr-CA/secure/tokens/id-tokens) contiennent des informations de l’utilisateur qui doivent être décodées et extraites.

Les [jetons d’accès](/docs/fr-CA/secure/tokens/access-tokens) sont utilisés pour appeler le [point de terminaison /userinfo de l’Authentication API Auth0](/docs/fr-CA/api/authentication#get-user-info) ou une autre API. Si vous appelez votre propre API, la première chose que votre API devra faire est de [vérifier le jeton d’accès](/docs/fr-CA/secure/tokens/access-tokens/validate-access-tokens).

Les [jetons d’actualisation](/docs/fr-CA/secure/tokens/refresh-tokens) sont utilisés pour obtenir un nouveau jeton d’accès ou un nouveau jeton d’ID après l’expiration du précédent. Le `refresh_token` ne sera présent dans la réponse que si vous avez inclus la permission `offline_access` et activé **Autoriser l’accès hors ligne** pour votre API dans le Dashboard.

<Warning>

Les jetons d’actualisation doivent être stockés en toute sécurité car ils permettent aux utilisateurs de rester authentifiés pratiquement indéfiniment.

</Warning>

### Appeler l’API

Pour appeler votre API à partir d’une application Web standard (ou de cas similaires dans lesquels les informations d’identification de l’application peuvent être stockées en toute sécurité), l’application doit transmettre le jeton d’accès récupéré en tant que jeton du porteur dans l’en-tête d’autorisation de votre requête HTTP.

<AuthCodeGroup>
```bash cURL lines
curl --request GET \
  --url https://myapi.com/api \
  --header 'authorization: Bearer {accessToken}' \
  --header 'content-type: application/json'
```
```csharp C# lines
var client = new RestClient("https://myapi.com/api");
var request = new RestRequest(Method.GET);
request.AddHeader("content-type", "application/json");
request.AddHeader("authorization", "Bearer {accessToken}");
IRestResponse response = client.Execute(request);
```

```go Go lines expandable
package main

import (
	"fmt"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://myapi.com/api"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("content-type", "application/json")
	req.Header.Add("authorization", "Bearer {accessToken}")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java lines
HttpResponse response = Unirest.get("https://myapi.com/api")
  .header("content-type", "application/json")
  .header("authorization", "Bearer {accessToken}")
  .asString();
```

```javascript Node.JS lines
var axios = require("axios").default;

var options = {
  method: 'GET',
  url: 'https://myapi.com/api',
  headers: {'content-type': 'application/json', authorization: 'Bearer {accessToken}'}
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```objc Obj-C lines
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"content-type": @"application/json",
                           @"authorization": @"Bearer {accessToken}" };

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://myapi.com/api"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"GET"];
[request setAllHTTPHeaderFields:headers];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```

```php PHP lines expandable
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://myapi.com/api",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "GET",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer {accessToken}",
    "content-type: application/json"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python lines
import http.client

conn = http.client.HTTPSConnection("myapi.com")

headers = {
    'content-type': "application/json",
    'authorization': "Bearer {accessToken}"
    }

conn.request("GET", "/api", headers=headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```

```ruby Ruby lines
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://myapi.com/api")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Get.new(url)
request["content-type"] = 'application/json'
request["authorization"] = 'Bearer {accessToken}'

response = http.request(request)
puts response.read_body
```
```swift Swift lines
import Foundation

let headers = [
  "content-type": "application/json",
  "authorization": "Bearer {accessToken}"
]

let request = NSMutableURLRequest(url: NSURL(string: "https://myapi.com/api")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</AuthCodeGroup>

### Jetons d’actualisation

Vous avez déjà reçu un [jeton d’actualisation](/docs/fr-CA/secure/tokens/refresh-tokens) si vous avez suivi ce tutoriel et complété ce qui suit :

* configuré votre API pour autoriser l’accès hors ligne
* inclus la permission `offline_access` lorsque vous avez lancé la demande d’authentification via le [point de terminaison d’autorisation](/docs/fr-CA/api/authentication/reference#authorize-application).

Vous pouvez utiliser le jeton d’actualisation pour obtenir le nouveau jeton d’accès. Généralement, un utilisateur aura besoin d’un nouveau jeton d’accès uniquement après l’expiration du précédent ou lorsqu’il accède à une nouvelle ressource pour la première fois. Il est déconseillé d’appeler le point de terminaison pour obtenir un nouveau jeton d’accès à chaque fois que vous appelez une API, et Auth0 impose des limites anti-attaques qui réduiront la quantité de requêtes au point de terminaison pouvant être exécutées en utilisant le même jeton depuis la même adresse IP.

Pour actualiser votre jeton, effectuez une requête `POST` au point de terminaison `/oauth/token` dans l’Authentication API, à l’aide de `grant_type=refresh_token`.

#### Exemple de POST à une URL de jeton

<AuthCodeGroup>
```bash cURL
curl --request POST \
  --url 'https://{yourDomain}/oauth/token' \
  --header 'content-type: application/x-www-form-urlencoded' \
  --data grant_type=refresh_token \
  --data 'client_id={yourClientId}' \
  --data 'refresh_token={yourRefreshToken}'
```
```csharp C#
var client = new RestClient("https://{yourDomain}/oauth/token");
var request = new RestRequest(Method.POST);
request.AddHeader("content-type", "application/x-www-form-urlencoded");
request.AddParameter("application/x-www-form-urlencoded", "grant_type=refresh_token&client_id={yourClientId}&refresh_token=%7ByourRefreshToken%7D", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```
```go Go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/oauth/token"

	payload := strings.NewReader("grant_type=refresh_token&client_id={yourClientId}&refresh_token=%7ByourRefreshToken%7D")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("content-type", "application/x-www-form-urlencoded")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java
HttpResponse response = Unirest.post("https://{yourDomain}/oauth/token")
  .header("content-type", "application/x-www-form-urlencoded")
  .body("grant_type=refresh_token&client_id={yourClientId}&refresh_token=%7ByourRefreshToken%7D")
  .asString();
```
```javascript Node.JS
var axios = require("axios").default;

var options = {
  method: 'POST',
  url: 'https://{yourDomain}/oauth/token',
  headers: {'content-type': 'application/x-www-form-urlencoded'},
  data: new URLSearchParams({
    grant_type: 'refresh_token',
    client_id: '{yourClientId}',
    refresh_token: '{yourRefreshToken}'
  })
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```objc Obj-C
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"content-type": @"application/x-www-form-urlencoded" };

NSMutableData *postData = [[NSMutableData alloc] initWithData:[@"grant_type=refresh_token" dataUsingEncoding:NSUTF8StringEncoding]];
[postData appendData:[@"&client_id={yourClientId}" dataUsingEncoding:NSUTF8StringEncoding]];
[postData appendData:[@"&refresh_token={yourRefreshToken}" dataUsingEncoding:NSUTF8StringEncoding]];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/oauth/token"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"POST"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```
```php PHP
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/oauth/token",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "POST",
  CURLOPT_POSTFIELDS => "grant_type=refresh_token&client_id={yourClientId}&refresh_token=%7ByourRefreshToken%7D",
  CURLOPT_HTTPHEADER => [
    "content-type: application/x-www-form-urlencoded"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python
import http.client

conn = http.client.HTTPSConnection("")

payload = "grant_type=refresh_token&client_id={yourClientId}&refresh_token=%7ByourRefreshToken%7D"

headers = { 'content-type': "application/x-www-form-urlencoded" }

conn.request("POST", "/{yourDomain}/oauth/token", payload, headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```
```ruby Ruby
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/oauth/token")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Post.new(url)
request["content-type"] = 'application/x-www-form-urlencoded'
request.body = "grant_type=refresh_token&client_id={yourClientId}&refresh_token=%7ByourRefreshToken%7D"

response = http.request(request)
puts response.read_body
```
```swift Swift
import Foundation

let headers = ["content-type": "application/x-www-form-urlencoded"]

let postData = NSMutableData(data: "grant_type=refresh_token".data(using: String.Encoding.utf8)!)
postData.append("&client_id={yourClientId}".data(using: String.Encoding.utf8)!)
postData.append("&refresh_token={yourRefreshToken}".data(using: String.Encoding.utf8)!)

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/oauth/token")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</AuthCodeGroup>

##### Paramètres

<table class="table"><thead>
<tr>
<th>Nom du paramètre</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>`grant_type`</td>
<td>Définir ce paramètre à `refresh_token`.</td>
</tr>
<tr>
<td>`client_id`</td>
<td>L’ID client de votre application. Vous pouvez trouver cette valeur dans vos <a href="https://manage.auth0.com/#/Applications/{yourClientId}/settings">Paramètres d’application</a>.</td>
</tr>
<tr>
<td>`refresh_token`</td>
<td>Le jeton d’actualisation à utiliser.</td>
</tr>
<tr>
<td>`scope`</td>
<td>(facultatif) Une liste délimitée par des espaces des permissions demandées. Si elle n’est pas envoyée, les permissions originales seront utilisées; sinon vous pouvez demander un ensemble réduit de permissions. Veuillez noter que cela doit être codé URL.</td>
</tr>
</tbody>
</table>

#### Réponse

Si tout se passe bien, vous recevrez une réponse `HTTP 200` avec une charge utile contenant un nouveau `access_token`, sa durée de vie en secondes (`expires_in`), les valeurs de `permissions` accordées et le `token_type` . Si la permission du jeton initial incluait `openid`, alors la réponse inclura également un nouveau `id_token` :

```json lines
{
  "access_token": "eyJ...MoQ",
  "expires_in": 86400,
  "scope": "openid offline_access",
  "id_token": "eyJ...0NE",
  "token_type": "Bearer"
}
```

<Warning>

Validez vos jetons avant de les enregistrer. Pour en savoir plus, lisez [Valider les jetons d’ID](/docs/fr-CA/secure/tokens/id-tokens/validate-id-tokens) et [Valider les jetons d’accès](/docs/fr-CA/secure/tokens/access-tokens/validate-access-tokens).

</Warning>

### Exemples de cas d’utilisation

#### Personnalisation des jetons

Vous pouvez utiliser des règles pour modifier les permissions renvoyées des jetons d’accès et/ou ajouter des demandes aux jetons d’accès et d’ID. (Pour en savoir plus sur les règles, lisez [Règles d'Auth0](/docs/fr-CA/customize/rules).) Pour ce faire, ajoutez la règle suivante, qui s’exécutera après l’authentification de l’utilisateur :

```javascript lines
exports.onExecutePostLogin = async (event, api) => {
  // Add custom claims to Access Token and ID Token
  api.accessToken.setCustomClaim('https://foo/bar', 'value');
  api.idToken.setCustomClaim('https://fiz/baz', 'some other value');

  // Modify the scope of the Access Token
  api.accessToken.addScope('foo');
  api.accessToken.addScope('bar');
};
```

Les permissions seront disponibles dans le jeton une fois toutes les règles exécutées.

<Warning>

Auth0 renvoie les informations de profil contenues dans un format de demande structuré tel que défini par la [spécification OpenID Connect (OIDC)](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims). Cela signifie que les demandes personnalisées ajoutées aux jetons d’ID ou aux jetons d’accès doivent [respecter des directives et des restrictions](/docs/fr-CA/secure/tokens/json-web-tokens/create-custom-claims) pour éviter d’éventuels conflits.

</Warning>

## En savoir plus

* [Cadre d’applications Authorization OAuth 2.0](/docs/fr-CA/authenticate/protocols/oauth)
* [Protocole OpenID Connect](/docs/fr-CA/authenticate/protocols/openid-connect-protocol)
* [Jetons](/docs/fr-CA/secure/tokens)