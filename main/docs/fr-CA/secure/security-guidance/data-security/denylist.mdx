---
title: "Ajouter des attributs d’utilisateur à la liste rouge"
permalink: "denylist"
'description': "Décrit comment identifier les attributs utilisateur que vous ne souhaitez pas enregistrer dans les bases de données Auth0."
'og:title': "Ajouter des attributs d’utilisateur à la liste rouge"
'og:description': "Décrit comment identifier les attributs utilisateur que vous ne souhaitez pas enregistrer dans les bases de données Auth0."
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "Ajouter des attributs d’utilisateur à la liste rouge"
'twitter:description': "Décrit comment identifier les attributs utilisateur que vous ne souhaitez pas enregistrer dans les bases de données Auth0."
---
import {AuthCodeBlock} from "/snippets/AuthCodeBlock.jsx";

import {AuthCodeGroup} from "/snippets/AuthCodeGroup.jsx";

S’il existe des champs utilisateur qui ne doivent pas être stockés dans les bases de données Auth0 pour des raisons de confidentialité, vous pouvez les ajouter à la liste rouge. Pour ajouter des attributs à la liste rouge, effectuez un appel `PATCH` au point de terminaison de connexion de mise à jour de <Tooltip href="/docs/fr-CA/glossary?term=management-api" tip="Management API
Un produit permettant aux clients d’effectuer des tâches administratives." cta="Voir le glossaire">Management API</Tooltip>.

1. Obtenez un jeton d’accès valide pour accéder au [point de terminaison](/docs/fr-CA/api/management/v2#!/Connections/patch_connections_by_id)`/patch_connections_by_id`. Le jeton doit inclure la permission `update:connections`. Pour plus de détails, veuillez consulter [Jetons d’accès à Management API](/docs/fr-CA/secure/tokens/access-tokens/management-api-access-tokens).
2. Avec le jeton d’accès et la liste des attributs à refuser, appelez l’API. Voici un exemple de requête HTTP qui refuse deux attributs : l’origine ethnique et le genre. Gardez à l’esprit que vous devez récupérer l’objet options et envoyer l’objet entier dans votre requête PATCH, car il n’y a pas de « fusion » si vous ne mettez à jour qu’une ou deux valeurs.

<AuthCodeGroup>
```bash cURL
    curl --request PATCH \
--url 'https://{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID' \
--header 'authorization: Bearer YOUR_TOKEN' \
--header 'content-type: application/json' \
--data '{"options": {"non_persistent_attrs": ["ethnicity", "gender"]}}'

```
```csharp C#
    var client = new RestClient("https://{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID");
var request = new RestRequest(Method.PATCH);
request.AddHeader("authorization", "Bearer YOUR_TOKEN");
request.AddHeader("content-type", "application/json");
request.AddParameter("application/json", "{"options": {"non_persistent_attrs": ["ethnicity", "gender"]}}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);

```
```go Go
    package main

import (
  "fmt"
  "strings"
  "net/http"
  "io/ioutil"
)

func main() {

  url := "https://{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID"

  payload := strings.NewReader("{"options": {"non_persistent_attrs": ["ethnicity", "gender"]}}")

  req, _ := http.NewRequest("PATCH", url, payload)

  req.Header.Add("authorization", "Bearer YOUR_TOKEN")
  req.Header.Add("content-type", "application/json")

  res, _ := http.DefaultClient.Do(req)

  defer res.Body.Close()
  body, _ := ioutil.ReadAll(res.Body)

  fmt.Println(res)
  fmt.Println(string(body))

}

```
```java Java
    HttpResponse<String> response = Unirest.patch("https://{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID")
  .header("authorization", "Bearer YOUR_TOKEN")
  .header("content-type", "application/json")
  .body("{"options": {"non_persistent_attrs": ["ethnicity", "gender"]}}")
  .asString();

```
```javascript Node.JS
    var axios = require("axios").default;

var options = {
  method: 'PATCH',
  url: 'https://{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID',
  headers: {authorization: 'Bearer YOUR_TOKEN', 'content-type': 'application/json'},
  data: {options: {non_persistent_attrs: ['ethnicity', 'gender']}}
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});

```
```objc Obj-C
    #import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"authorization": @"Bearer YOUR_TOKEN",
                          @"content-type": @"application/json" };
NSDictionary *parameters = @{ @"options": @{ @"non_persistent_attrs": @[ @"ethnicity", @"gender" ] } };

NSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID"]
                                                      cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                  timeoutInterval:10.0];
[request setHTTPMethod:@"PATCH"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];

```
```php PHP
    $curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "PATCH",
  CURLOPT_POSTFIELDS => "{"options": {"non_persistent_attrs": ["ethnicity", "gender"]}}",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer YOUR_TOKEN",
    "content-type: application/json"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}

```
```python Python
    import http.client

conn = http.client.HTTPSConnection("")

payload = "{"options": {"non_persistent_attrs": ["ethnicity", "gender"]}}"

headers = {
    'authorization': "Bearer YOUR_TOKEN",
    'content-type': "application/json"
    }

conn.request("PATCH", "/{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID", payload, headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))

```
```ruby Ruby
    require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Patch.new(url)
request["authorization"] = 'Bearer YOUR_TOKEN'
request["content-type"] = 'application/json'
request.body = "{"options": {"non_persistent_attrs": ["ethnicity", "gender"]}}"

response = http.request(request)
puts response.read_body

```
```swift Swift
    import Foundation

let headers = [
  "authorization": "Bearer YOUR_TOKEN",
  "content-type": "application/json"
]
let parameters = ["options": ["non_persistent_attrs": ["ethnicity", "gender"]]] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "PATCH"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()

```
</AuthCodeGroup>

   Où :
   1. `{yourConnectionId}` est [l’ID de connexion](/docs/fr-CA/authenticate/identity-providers/locate-the-connection-id) pour lequel ces attributs seront refusés.
   2. `{yourToken}` est le jeton d’accès que vous avez reçu à l’étape précédente.
   3. L’objet `options.non_persistent_attrs` contient un tableau des attributs qui seront refusés. Si la demande que vous souhaitez refuser est envoyée par un fournisseur d’identité (IdP) en amont, vous devez définir la demande exactement comme elle a été envoyée par l’IdP en amont. Par exemple, pour une demande reçue comme `https://acme.com/temporary_idtoken`, l’objet de l’exemple ci-dessus `non_persistent_attrs` serait :

      ```
      {"non_persistent_attrs": ["ethnicity", "gender", "https://acme.com/temporary_idtoken"]}
      ```

      

      

## Limites

* Seuls les [champs racine](/docs/fr-CA/manage-users/user-accounts/user-profiles/user-profile-structure) (comme `user.name` ou `user.phone_number`) peuvent être refusés.

  + Si `user.name` ou `user.nickname` est refusé, il ne sera pas inclus dans les jetons.
  + Si `user.email` est refusé, la valeur ne peut pas être mappée à une demande personnalisée. Par exemple, dans une règle, `context.idToken[namespace + ’work_email’] = user.email` ne fonctionnerait pas.
* Lorsque vous refusez des attributs, ils seront toujours disponibles via des règles et des jetons sortants. Cependant, si l’une des conditions suivantes s’applique, les attributs de la liste rouge ne seront **pas** inclus dans les jetons :

  + Vous avez activé l’authentification multifacteur (MFA)
  + Vous avez effectué une redirection à l’aide de règles
  + Votre application utilise la délégation (et vous n’avez pas défini `permission = passthrough`)
  + Votre application utilise l’usurpation d’identité
  + Vous avez activé le paramètre **Utiliser Auth0 au lieu de l’IdP pour effectuer une authentification unique** (anciens locataires uniquement)
* Pour les connexions SAMLP, si vous activez le mode Debug, vos journaux contiendront des informations sur les attributs de la liste rouge

Si l’une de ces limitations est inacceptable, vous pouvez créer une [règle](/docs/fr-CA/customize/rules) pour chiffrer les données et faire en sorte que les données persistent dans l’objet `user.app_metadata`.

## En savoir plus

* [Adresses IP Auth0 pour listes d’autorisations](/docs/fr-CA/secure/security-guidance/data-security/allowlist)