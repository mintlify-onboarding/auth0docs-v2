---
title: "Créer des règles"
permalink: "create-rules"
'description': "Découvrez comment créer des règles à l’aide d’Auth0 Dashboard ou de Management API."
'og:title': "Créer des règles"
'og:description': "Découvrez comment créer des règles à l’aide d’Auth0 Dashboard ou de Management API."
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "Créer des règles"
'twitter:description': "Découvrez comment créer des règles à l’aide d’Auth0 Dashboard ou de Management API."
---
import {AuthCodeBlock} from "/snippets/AuthCodeBlock.jsx";

import {AuthCodeGroup} from "/snippets/AuthCodeGroup.jsx";

<Warning>

La date de fin de vie (EOL) des Règles et des Appels sera le **18 novembre 2026**. Ils ne sont plus disponibles pour les nouveaux locataires créés à partir du **16 octobre 2023**. Les locataires actuels ayant des hooks actifs conserveront l’accès aux produit Hooks jusqu’à la fin de leur durée de vie.

Nous vous conseillons vivement d’utiliser les Actions pour étendre Auth0. Avec les Actions, vous avez accès à des informations de type enrichies, à une documentation intégrée et à des packages `npm` publics, et vous pouvez connecter des intégrations externes qui optimisent votre expérience d’extensibilité globale. Pour en savoir plus sur ce que les Actions proposent, consultez [Comprendre comment fonctionnent Auth0 Actions](/docs/fr-ca/customize/actions/actions-overview).

Pour vous aider dans votre migration, nous proposons des guides qui vous aideront à [migrer des Règles vers les Actions](/docs/fr-ca/customize/actions/migrate/migrate-from-rules-to-actions) et à [migrer des Hooks vers les Actions](/docs/fr-ca/customize/actions/migrate/migrate-from-hooks-to-actions). Nous avons également une page dédiée à la [Migration vers les Actions](https://auth0.com/extensibility/movetoactions) qui met en évidence les comparaisons de fonctionnalités, [une démo des Actions](https://www.youtube.com/watch?v=UesFSY1klrI)  et d’autres ressources pour vous aider dans votre parcours de migration.

Pour en savoir plus sur l’obsolescence des Règles et des Appels, consultez notre article de blog : [Preparing for Rules and Hooks End of Life (Préparation à la fin de vie des règles et des crochets)](https://auth0.com/blog/preparing-for-rules-and-hooks-end-of-life/).

</Warning>

<Warning>

Comme nous prévoyons de supprimer les fonctions Règles et Hooks en 2026, vous devez créer de nouvelles Règles ou de nouveaux Hooks uniquement dans votre environnement de développement et uniquement pour tester la migration vers les Actions.

Pour apprendre à migrer vos Règles vers des Actions, consultez [Migrer des règles vers les actions](/docs/fr-ca/customize/actions/migrate/migrate-from-rules-to-actions). Pour apprendre à migrer vos Hooks vers des Actions, consultez la section [Migrer des Hooks vers les actions](/docs/fr-ca/customize/actions/migrate/migrate-from-hooks-to-actions).

</Warning>

Vous pouvez créer vos propres règles pour répondre à vos besoins particuliers en matière de fonctionnalités. Vous pouvez modifier un modèle de règle préexistant ou choisir de commencer à partir de zéro en utilisant l’un de nos exemples. Auth0 fournit un certain nombre de règles et de modèles de règles préexistants pour vous aider à atteindre votre ou vos objectif(s). Pour voir une liste, visitez notre [Répertoire de règles sur GitHub](https://github.com/auth0/rules).

## Fonctionnement des règles

Les règles sont des fonctionnalités JavaScriptqui s’exécutent lorsqu’un utilisateur s’authentifie auprès de votre application. Elles sont exécutées une fois le processus d’authentification terminé, et vous pouvez les utiliser pour personnaliser et étendre les capacités d’Auth0. Pour des raisons de sécurité, le code de vos règles s’exécute dans un bac à sable, isolé du code des autres locataires Auth0. Les règles sont également exécutées pendant le flux d’actualisation des jetons. Pour en savoir plus, lisez [Jetons d’actualisation](/docs/fr-ca/secure/tokens/refresh-tokens)

Dans Auth0, le flux de transactions d’authentific](/docs/images/tionne comme suit lorsque vous utilisez des règles :

<Frame>![Rules in the Authentication Flow diagram](/images/fr-ca/cdy7uua7fh8z/2gtBtkPChIyguA24x6enx2/ffbb8e21e86920ef9914f6fc126dc1df/flow.png)</Frame>

1. Une application lance une demande d’authentification auprès d’Auth0.
2. Auth0 transmet la demande à un fournisseur d’identité au moyen d’une connexion configurée.
3. L’utilisateur s’authentifie avec succès.
4. Le jeton d’ID et/ou d’accès passe par le pipeline de règles, puis est envoyé à l’application.

## Conditions préalables

Si vous prévoyez d’utiliser des variables globales dans votre règle, veillez à configurer d’abord les variables de vos règles. Pour en savoir plus, consultez [Configuration des variables globales pour les règles](/docs/fr-ca/customize/rules/configure-global-variables-for-rules).

## Utiliser le Dashboard

1. Accédez à [Dashboard > Pipeline Auth > Règl](/docs/images///manage.auth0.com/#/rules) et cliquez sur **Créer**.

   <Frame>![Dashboard - Auth Pipeline - Rules ](/images/fr-ca/cdy7uua7fh8z/4OiSXzc5fYgPagHdOGbfvj/a589bdf811df66658fe21c509aed610c/Dashboard_-_Auth_Pipeline_-_Rules.png)</Frame>

2. Sélectionnez un modèle de règle.

   <Frame>![Dashboard - Auth Pipeline - Rules - Template](/images/fr-ca/cdy7uua7fh8z/6IydSSjg2oQrdSzErcTYtN/d17348a98c597a74b2989c298764b9e1/dashboard-rules-create_choose-template.png)</Frame>

3. Nommez la règle, modifiez le script en fonction de vos](/docs/images/t cliquez sur **Enregistrer les modifications**.

   <Frame>![Dashboard - Auth Pipeline - Rules - Edit Rule](/images/fr-ca/cdy7uua7fh8z/5CoC6cnazv2uT1iSq6OGsm/6cb30d9479971be771313da80acc4802/Dashboard_-_Auth_Pipeline_-_Rules_-_Edit_Rule.png)</Frame>

## Utiliser Management API

Faites un appel `POST` au point de terminaison [Créer une règle](/docs/fr-ca/api/management/v2#!/Rules/post_rules). Assurez-vous de remplacer les valeurs fictives `MGMT_API_ACCESS_TOKEN`, `RULE_NAME`, `RULE_SCRIPT`, `RULE_ORDER`, and `RULE_ENABLED` avec votre jeton d’accès au <Tooltip href="/docs/fr-ca/glossary?term=management-api" tip="Management API
Un produit permettant aux clients d’effectuer des tâches administratives." cta="Voir le glossaire">Management API</Tooltip>, le nom de la règle, le script de la règle, le numéro d’ordre de la règle et la valeur activée de la règle, respectivement.

<AuthCodeGroup>
```bash cURL
curl --request POST \
  --url 'https://{yourDomain}/api/v2/rules' \
  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \
  --header 'cache-control: no-cache' \
  --header 'content-type: application/json' \
  --data '{ "name": "RULE_NAME", "script": "RULE_SCRIPT" }'
```
```csharp C#
var client = new RestClient("https://{yourDomain}/api/v2/rules");
var request = new RestRequest(Method.POST);
request.AddHeader("content-type", "application/json");
request.AddHeader("authorization", "Bearer MGMT_API_ACCESS_TOKEN");
request.AddHeader("cache-control", "no-cache");
request.AddParameter("application/json", "{ "name": "RULE_NAME", "script": "RULE_SCRIPT" }", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```
```go Go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/api/v2/rules"

	payload := strings.NewReader("{ "name": "RULE_NAME", "script": "RULE_SCRIPT" }")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("content-type", "application/json")
	req.Header.Add("authorization", "Bearer MGMT_API_ACCESS_TOKEN")
	req.Header.Add("cache-control", "no-cache")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java
HttpResponse<String> response = Unirest.post("https://{yourDomain}/api/v2/rules")
  .header("content-type", "application/json")
  .header("authorization", "Bearer MGMT_API_ACCESS_TOKEN")
  .header("cache-control", "no-cache")
  .body("{ "name": "RULE_NAME", "script": "RULE_SCRIPT" }")
  .asString();
```
```javascript Node.JS
var axios = require("axios").default;

var options = {
  method: 'POST',
  url: 'https://{yourDomain}/api/v2/rules',
  headers: {
    'content-type': 'application/json',
    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',
    'cache-control': 'no-cache'
  },
  data: {name: 'RULE_NAME', script: 'RULE_SCRIPT'}
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```objc Obj-C
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"content-type": @"application/json",
                           @"authorization": @"Bearer MGMT_API_ACCESS_TOKEN",
                           @"cache-control": @"no-cache" };
NSDictionary *parameters = @{ @"name": @"RULE_NAME",
                              @"script": @"RULE_SCRIPT" };

NSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/rules"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"POST"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```
```php PHP
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/api/v2/rules",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "POST",
  CURLOPT_POSTFIELDS => "{ "name": "RULE_NAME", "script": "RULE_SCRIPT" }",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer MGMT_API_ACCESS_TOKEN",
    "cache-control: no-cache",
    "content-type: application/json"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python
import http.client

conn = http.client.HTTPSConnection("")

payload = "{ "name": "RULE_NAME", "script": "RULE_SCRIPT" }"

headers = {
    'content-type': "application/json",
    'authorization': "Bearer MGMT_API_ACCESS_TOKEN",
    'cache-control': "no-cache"
    }

conn.request("POST", "/{yourDomain}/api/v2/rules", payload, headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```
```ruby Ruby
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/api/v2/rules")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Post.new(url)
request["content-type"] = 'application/json'
request["authorization"] = 'Bearer MGMT_API_ACCESS_TOKEN'
request["cache-control"] = 'no-cache'
request.body = "{ "name": "RULE_NAME", "script": "RULE_SCRIPT" }"

response = http.request(request)
puts response.read_body
```
```swift Swift
import Foundation

let headers = [
  "content-type": "application/json",
  "authorization": "Bearer MGMT_API_ACCESS_TOKEN",
  "cache-control": "no-cache"
]
let parameters = [
  "name": "RULE_NAME",
  "script": "RULE_SCRIPT"
] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/rules")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</AuthCodeGroup>

<table class="table"><thead>
<tr>
<th><strong>Valeur</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>`MGMT_API_ACCESS_TOKEN`</td>
<td>Jeton d’accès à Management API avec la permission `create:rules`.</td>
</tr>
<tr>
<td>`RULE_NAME`</td>
<td>Nom de la règle que vous souhaitez créer. Le nom de la règle ne peut contenir que des caractères alphanumériques, des espaces et des traits d’union; il ne peut pas commencer ou se terminer par des espaces ou des traits d’union.</td>
</tr>
<tr>
<td>`RULE_SCRIPT`</td>
<td>Script contenant le code de la règle. Il doit correspondre à ce que vous entreriez si vous créiez une nouvelle règle à l’aide du Dashboard.</td>
</tr>
<tr>
<td>`RULE_ORDER` (facultatif)</td>
<td>Entier qui représente l’ordre dans lequel la règle doit être exécutée par rapport à d’autres règles. Les règles dont le numéro est inférieur sont exécutées avant les règles dont le numéro est supérieur. Si aucun numéro d’ordre n’est fourni, la règle sera exécutée en dernier.</td>
</tr>
<tr>
<td>`RULE_ENABLED` (facultatif)</td>
<td>Valeur booléenne qui représente si la règle est activée (`true`) ou désactivée (`false`).</td>
</tr>
</tbody>
</table>

<Warning>

Nous exposons les adresses IPv6 dans nos points de terminaison publics (par exemple, `travel0.us.auth0.com`). Si une demande provient d’une machine qui prend en charge IPv6, la propriété `context.request.ip` contiendra alors une adresse IPv6. Si vous manipulez manuellement des adresses IP, nous vous suggérons d’utiliser [la bibliothèque ipaddr.js@1.9.0.](https://www.npmjs.com/package/ipaddr.js/v/1.9.0).

</Warning>

## Gestion des limites anti-attaques

Pour les règles qui font appel aux API Auth0, vous devez toujours gérer la limite anti-attaques en vérifiant l’en-tête `X-RateLimit-Remaining` et en agissant de manière appropriée lorsque le nombre renvoyé se rapproche de 0. Vous devez également ajouter une logique pour gérer les cas où vous dépassez les limites anti-attaques fournies et recevez le code d’état HTTP 429 (trop de demandes); dans ce cas, si une nouvelle tentative est nécessaire, il est préférable de prévoir un délai pour éviter d’entrer dans une boucle infinie de tentatives. Pour en savoir plus sur les limites anti-attaques, consultez la [Politique de limites anti-attaques pour les API Auth0](/docs/fr-ca/troubleshoot/customer-support/operational-policies/rate-limit-policy).

## Modules proposés

Les règles s’exécutent dans un bac à sable JavaScript configuré pour une version spécifique de Node.js.

Le bac à sable prend en charge toutes les versions du langage JavaScript (et la syntaxe associée) pour la version spécifiée de Node.js, ainsi qu’un grand nombre de modules Node.js. Pour une liste des modules de bac à sable pris en charge, consultez [Puis-je exiger : extensibilité Auth0](https://auth0-extensions.github.io/canirequire/).

## En savoir plus

* [Configuration des variables globales pour les règles](/docs/fr-ca/customize/rules/configure-global-variables-for-rules)
* [Meilleures pratiques de l’environnement des règles](/docs/fr-ca/rules-best-practices/rules-environment-best-practices)