---
title: "Rotation des secrets client"
permalink: "rotate-client-secret"
'description': "Apprenez à faire pivoter le secret client d’une application à l’aide de l’Auth0 Dashboard ou du Management API."
'og:title': "Rotation des secrets client"
'og:description': "Apprenez à faire pivoter le secret client d’une application à l’aide de l’Auth0 Dashboard ou du Management API."
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "Rotation des secrets client"
'twitter:description': "Apprenez à faire pivoter le secret client d’une application à l’aide de l’Auth0 Dashboard ou du Management API."
---
import {AuthCodeBlock} from "/snippets/AuthCodeBlock.jsx";

import {AuthCodeGroup} from "/snippets/AuthCodeGroup.jsx";

Vous pouvez modifier le secret client d’une application à l’aide de l’<Tooltip href="/docs/fr-ca/glossary?term=auth0-dashboard" tip="Auth0 Dashboard
Principal produit d’Auth0 pour configurer vos services." cta="Voir le glossaire">Auth0 Dashboard</Tooltip> ou du <Tooltip href="/docs/fr-ca/glossary?term=management-api" tip="Management API
Un produit permettant aux clients d’effectuer des tâches administratives." cta="Voir le glossaire">Management API</Tooltip>. Lorsque vous faites pivoter un secret client, vous devez mettre à jour toutes les applications autorisées avec la nouvelle valeur.

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

applications clients publiques. Pour en savoir plus, lisez [Applications confidentielles et publiques](/docs/fr-ca/get-started/applications/confidential-and-public-applications)

</Callout>

<Warning>

La rotation des nouveaux secrets peut être retardée de trente secondes au maximum. Pour minimiser les temps d’arrêt, nous vous suggérons de stocker le nouveau secret client dans le code de votre application ou dans la configuration du système comme solution de secours au secret précédent. De cette manière, si la demande de l’application cliente ne fonctionne pas avec l’ancien secret, votre application utilisera le nouveau secret.

Les secrets peuvent être stockés dans une liste (ou structure similaire) jusqu’à ce qu’ils ne soient plus nécessaires. Si vous avez la certitude qu’un ancien secret est obsolète, vous pouvez supprimer sa valeur du code de votre application.

</Warning>

## Utiliser le Dashboard

1. Dans l’Auth0 Dashboard, accédez à [Applications >](/docs/images/ons](https://manage.auth0.com/#/applications), puis sélectionnez le nom de l’application à afficher.

   <Frame>![Tableau de bord - Liste des applications](/images/fr-ca/cdy7uua7fh8z/1ecNwGgFQZxdP57p0tp3jT/f29e9dd02a5fb61311387cc3c93ac006/App_List_-_FR.png)</Frame>

2. Faites défiler en bas de la page **Paramètres**, localisez la **Zone danger**, sélectionnez **Rotation**, puis confirmez.
3. Faites défiler la page jusqu’en haut et passez à l’onglet **Identifiants**.
4. Affichez votre nouveau secret en localisant **Secret client** et en sé](/docs/images/t l’icône de l’œil.

   <Frame>![Dashboard Onglet Paramètres d’application Information de base](/images/fr-ca/cdy7uua7fh8z/2GPUw7BODYuYYH3658Upz3/061d21a8d965cec77a7bc65793a0a994/App_-_Basic_Settings_-_FR.png)</Frame>

5. Mettre à jour les applications autorisées avec la nouvelle valeur.

## Utiliser Management API

1. Appeler le point de terminaison de Management API [Faire pivoter un secret client](https://auth0.com/docs/api/management/v2#!/Clients/post_rotate_secret). Remplacer les valeurs de l’espace réservé `{yourClientId}` et `MGMT_API_ACCESS_TOKEN` par votre ID client et le jeton d’accès à Management API, respectivement.

<AuthCodeGroup>
```bash cURL
   curl --request POST \
  --url 'https://{yourDomain}/api/v2/clients/%7ByourClientId%7D/rotate-secret' \
  --header 'authorization: Bearer {yourMgmtApiAccessToken}'

```
```csharp C#
   var client = new RestClient("https://{yourDomain}/api/v2/clients/%7ByourClientId%7D/rotate-secret");
var request = new RestRequest(Method.POST);
request.AddHeader("authorization", "Bearer {yourMgmtApiAccessToken}");
IRestResponse response = client.Execute(request);

```
```go Go
   package main

import (
"fmt"
"net/http"
"io/ioutil"
)

func main() {

url := "https://{yourDomain}/api/v2/clients/%7ByourClientId%7D/rotate-secret"

req, _ := http.NewRequest("POST", url, nil)

req.Header.Add("authorization", "Bearer {yourMgmtApiAccessToken}")

res, _ := http.DefaultClient.Do(req)

defer res.Body.Close()
body, _ := ioutil.ReadAll(res.Body)

fmt.Println(res)
fmt.Println(string(body))

}

```
```java Java
   HttpResponse response = Unirest.post("https://{yourDomain}/api/v2/clients/%7ByourClientId%7D/rotate-secret")
  .header("authorization", "Bearer {yourMgmtApiAccessToken}")
  .asString();

```
```javascript Node.JS
   var axios = require("axios").default;

var options = {
  method: 'POST',
  url: 'https://{yourDomain}/api/v2/clients/%7ByourClientId%7D/rotate-secret',
  headers: {authorization: 'Bearer {yourMgmtApiAccessToken}'}
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});

```
```objc Obj-C
   #import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"authorization": @"Bearer {yourMgmtApiAccessToken}" };

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/clients/%7ByourClientId%7D/rotate-secret"]
                                                      cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                  timeoutInterval:10.0];
[request setHTTPMethod:@"POST"];
[request setAllHTTPHeaderFields:headers];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];

```
```php PHP
   $curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/api/v2/clients/%7ByourClientId%7D/rotate-secret",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "POST",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer {yourMgmtApiAccessToken}"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}

```
```python Python
   import http.client

conn = http.client.HTTPSConnection("")

headers = { 'authorization': "Bearer {yourMgmtApiAccessToken}" }

conn.request("POST", "/{yourDomain}/api/v2/clients/%7ByourClientId%7D/rotate-secret", headers=headers)

res = conn.getresponse()

data = res.read()

print(data.decode("utf-8"))

```
```ruby Ruby
   require 'uri'
require 'net/http'
require 'openssl'
url = URI("https://{yourDomain}/api/v2/clients/%7ByourClientId%7D/rotate-secret")
http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE
request = Net::HTTP::Post.new(url)
request["authorization"] = 'Bearer {yourMgmtApiAccessToken}'
response = http.request(request)
puts response.read_body

```
```swift Swift
   import Foundation

let headers = ["authorization": "Bearer {yourMgmtApiAccessToken}"]

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/clients/%7ByourClientId%7D/rotate-secret")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()

```
</AuthCodeGroup>

<table class="table"><thead>
<tr>
<th><strong>Valeur</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>`VOTRE_ID_CLIENT`</td>
<td>Identifiant de l’application à mettre à jour.</td>
</tr>
<tr>
<td>`MGMT_API_ACCESS_TOKEN`</td>
<td><a href="/docs/fr-ca/api/management/v2/tokens">Jetons d’accès à Management API</a> avec la permission `update:client_keys`.</td>
</tr>
</tbody>
</table>
2. Mettre à jour les applications autorisées avec la nouvelle valeur.

### Définir un secret client personnalisé

Vous pouvez utiliser le point de terminaison de Management API [Mettre à jour un client](https://auth0.com/docs/api/management/v2/#!/Clients/patch_clients_by_id) pour définir manuellement un secret client au lieu de demander une rotation vers un secret généré automatiquement. Votre application est configurée avec le futur secret comme remplaçant avant la rotation réelle.

```json lines
{
    curl --request PATCH \
    --url https://{TenantDomain}/api/v2/clients/{ClientID} \
    --header 'Authorization: Bearer {AccessToken}' \
    --header 'Content-Type: application/json' \
    --data '{
        "client_secret": "{CustomClientSecret}"
        }'
}
```

## En savoir plus

* [Afficher les certificats de connexion](/docs/fr-ca/get-started/tenant-settings/signing-keys/view-signing-certificates)
* [Algorithmes de signature](/docs/fr-ca/get-started/applications/signing-algorithms)
* [Modification des algorithmes de signature des applications](/docs/fr-ca/get-started/applications/change-application-signing-algorithms)