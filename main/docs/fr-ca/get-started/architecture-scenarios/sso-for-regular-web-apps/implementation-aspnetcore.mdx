---
title: "Mise en œuvre d’ASP.NET Core (Web Apps + SSO)"
permalink: "implementation-aspnetcore"
'description': "L’implémentation d’ASP.NET Core pour le scénario d’architecture d’authentification unique (SSO) pour les applications Web classiques"
'og:title': "Mise en œuvre d’ASP.NET Core (Web Apps + SSO)"
'og:description': "L’implémentation d’ASP.NET Core pour le scénario d’architecture d’authentification unique (SSO) pour les applications Web classiques"
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "Mise en œuvre d’ASP.NET Core (Web Apps + SSO)"
'twitter:description': "L’implémentation d’ASP.NET Core pour le scénario d’architecture d’authentification unique (SSO) pour les applications Web classiques"
---
import {AuthCodeBlock} from "/snippets/AuthCodeBlock.jsx";


Le code source complet de l’implémentation ASP.NET Core se trouve dans [ce répertoire GitHub](https://github.com/auth0-samples/auth0-pnp-webapp-oidc).

## Configurer le témoin et le logiciel médiateur OIDC

Pour les besoins de ce guide, nous utiliserons une simple connexion hébergée. Vous pouvez utiliser le témoin standard et le logiciel médiateur OIDC qui est disponible avec ASP.NET Core, assurez-vous donc d’installer les paquets NuGet.

``` lines
Install-Package Microsoft.AspNetCore.Authentication.Cookies
Install-Package Microsoft.AspNetCore.Authentication.OpenIdConnect
```

Configurez ensuite le logiciel médiateur OIDC et le témoin dans le pipeline du logiciel médiateur de votre application.

export const codeExample = `public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        // Add authentication services
        services.AddAuthentication(
            options => options.SignInScheme = CookieAuthenticationDefaults.AuthenticationScheme);

        // Code omitted for brevity...
    }

    public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory, IOptions<Auth0Settings> auth0Settings)
    {
        // Code omitted for brevity...

        // Add the cookie middleware
        app.UseCookieAuthentication(new CookieAuthenticationOptions
        {
            AutomaticAuthenticate = true,
            AutomaticChallenge = true
        });

        // Add the OIDC middleware
        app.UseOpenIdConnectAuthentication(new OpenIdConnectOptions("Auth0")
        {
            // Set the authority to your Auth0 domain
            Authority = "https://{yourDomain}/",

            // Configure the Auth0 Client ID and Client Secret
            ClientId = {yourClientId},
            ClientSecret = {yourClientSecret},

            // Do not automatically authenticate and challenge
            AutomaticAuthenticate = false,
            AutomaticChallenge = false,

            // Set response type to code
            ResponseType = "code",

            CallbackPath = new PathString("/signin-auth0"),

            // Configure the Claims Issuer to be Auth0
            ClaimsIssuer = "Auth0"
        });

        // Code omitted for brevity...
    }
}`;

<AuthCodeBlock children={codeExample} language="csharp" />

Comme vous pouvez le voir dans le code ci-dessus, nous avons configuré deux types différents du logiciel médiateur d’authentification.

Le premier est le logiciel médiateur de gestion des témoin qui a été enregistré avec l’appel à `UseCookieAuthentication`. Le second est le logiciel médiateur OIDC qui a été enregistré avec l’appel à `UseOpenIdConnectAuthentication`.

Une fois que l’utilisateur s’est connecté à Auth0 à l’aide du logiciel médiateur OIDC, ses informations sont automatiquement stockées dans un témoin de session. Il suffit de configurer le logiciel médiateur comme indiqué ci-dessus pour qu’il s’occupe de la gestion de la session de l’utilisateur.

Le logiciel médiateur <Tooltip href="/docs/fr-ca/glossary?term=openid" tip="OpenID
Norme ouverte d’authentification qui permet aux applications de vérifier l’identité des utilisateurs sans avoir à collecter leurs informations de connexion." cta="Voir le glossaire">OpenID</Tooltip> Connect (OIDC) extraira également toutes les demandes du jeton d’ID, qui est envoyé par Auth0 une fois que l’utilisateur s’est authentifié, et les ajoutera en tant que demandes sur le `ClaimsIdentity`.

## Mise en œuvre de la déconnexion

Vous pouvez contrôler à la fois la session de l’application et la session Auth0 en utilisant la méthode `SignOutAsync` de la classe `AuthenticationManager`, et en transmettant le schéma d’authentification à partir duquel vous souhaitez vous déconnecter.

Par exemple, pour se déconnecter du logiciel médiateur de gestion des témoins, et ainsi effacer le témoin d’authentification de votre application, vous pouvez effectuer l’appel suivant :

```csharp lines
await HttpContext.Authentication.SignOutAsync(CookieAuthenticationDefaults.AuthenticationScheme);
```

De même, vous pouvez déconnecter l’utilisateur d'Auth0 en appelant la méthode `SignOutAsync` et en transmettant `Auth0` comme schéma d’authentification à déconnecter.

```csharp lines
await HttpContext.Authentication.SignOutAsync("Auth0");
```

Pour que cela fonctionne, vous devrez cependant ajouter une configuration supplémentaire lors de l’enregistrement du logiciel médiateur OIDC en gérant l’événement `OnRedirectToIdentityProviderForSignOut`. Dans cet événement, vous devrez rediriger vers [le point de terminaison de déconnexion Auth0](https://auth0.com/docs/api/authentication/reference#logout), ce qui effacera le témoin Auth0.

```csharp lines
app.UseOpenIdConnectAuthentication(new OpenIdConnectOptions("Auth0")
{
    // Some code omitted for brevity
    Events = new OpenIdConnectEvents
    {
        OnRedirectToIdentityProviderForSignOut = context =>
        {
            context.Response.Redirect($"https://{auth0Settings.Value.Domain}/v2/logout?client_id={auth0Settings.Value.ClientId}&returnTo={context.Request.Scheme}://{context.Request.Host}/");
            context.HandleResponse();

            return Task.FromResult(0);
        }
    }
});
```

Vous devrez également vous assurer que vous ajoutez l’URL de votre application à **URL de déconnexion autorisées** de votre application dans le tableau de bord Auth0. Pour plus d’informations, reportez-vous à [Déconnexion](https://auth0.com/docs/logout).

## Mettre en oeuvre les permissions d’administration

La manière la plus simple d’intégrer les groupes dans une application ASP.NET Core est d’utiliser l’autorisation intégrée [Autorisation basée sur les rôles](https://docs.asp.net/en/latest/security/authorization/roles.html) disponible dans ASP.NET Core. Pour ce faire, nous devrons ajouter une Demande de type

``` lines
http://schemas.microsoft.com/ws/2008/06/identity/claims/role
```

pour chacun des groupes auxquels un utilisateur est assigné.

Une fois les demandes ajoutées, nous pouvons facilement nous assurer qu’une action spécifique n’est disponible que pour les utilisateurs `Admin` en décorant la demande avec l’attribut `[Authorize(Roles = "Admin")]`. Vous pouvez également vérifier si un utilisateur occupe un rôle spécifique à partir du code en appelant `User.IsInRole("Admin")` à l’intérieur de votre contrôleur.

Le logiciel médiateur ASP.NET OIDC ajoutera automatiquement toutes les demandes renvoyées dans le <Tooltip href="/docs/fr-ca/glossary?term=json-web-token" tip="Jeton Web JSON (JWT)
Format standard de jeton d’ID (et souvent de jeton d’accès) utilisé pour représenter en toute sécurité des demandes entre deux parties." cta="Voir le glossaire">JWT</Tooltip> en tant que demandes à l’identité `ClaimsIdentity`. Nous devrions donc extraire les informations de la demande `authorization`, désérialiser le corps JSON de la demande et, pour chacun des groupes, ajouter une demande `http://schemas.microsoft.com/ws/2008/06/identity/claims/role` à `ClaimsIdentity`.

```csharp lines
app.UseOpenIdConnectAuthentication(new OpenIdConnectOptions("Auth0")
{
    // Some configuration omitted for brevity

    Events = new OpenIdConnectEvents
    {
        OnTicketReceived = context =>
        {
            var options = context.Options as OpenIdConnectOptions;

            // Get the ClaimsIdentity
            var identity = context.Principal.Identity as ClaimsIdentity;
            if (identity != null)
            {
                // Add the groups as roles
                var authzClaim = context.Principal.FindFirst(c => c.Type == "authorization");
                if (authzClaim != null)
                {
                    var authorization = JsonConvert.DeserializeObject<Auth0Authorization>(authzClaim.Value);
                    if (authorization != null)
                    {
                        foreach (var group in authorization.Groups)
                        {
                            identity.AddClaim(new Claim(ClaimTypes.Role, group, ClaimValueTypes.String, options.Authority));
                        }
                    }
                }
            }

            return Task.FromResult(0);
        }
    }
});
```

Ensuite, nous pouvons ajouter une action qui permet aux Administrateurs d’approuver les feuilles de temps :

```csharp lines
[Authorize(Roles = "Admin")]
public IActionResult TimesheetApproval()
{          
    return View();
}
```

