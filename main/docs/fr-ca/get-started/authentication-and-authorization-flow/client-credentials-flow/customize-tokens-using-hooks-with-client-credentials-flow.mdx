---
title: "Personnalisation des jetons grâce aux hooks en utilisant le Flux des identifiants client"
permalink: "customize-tokens-using-hooks-with-client-credentials-flow"
'description': "Découvrez comment utiliser les hooks pour modifier les permissions et ajouter des réclamations personnalisées dans le jeton d’accès obtenu à l’aide du Flux des identifiants client."
'og:title': "Personnalisation des jetons grâce aux hooks en utilisant le Flux des identifiants client"
'og:description': "Découvrez comment utiliser les hooks pour modifier les permissions et ajouter des réclamations personnalisées dans le jeton d’accès obtenu à l’aide du Flux des identifiants client."
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "Personnalisation des jetons grâce aux hooks en utilisant le Flux des identifiants client"
'twitter:description': "Découvrez comment utiliser les hooks pour modifier les permissions et ajouter des réclamations personnalisées dans le jeton d’accès obtenu à l’aide du Flux des identifiants client."
---
import {AuthCodeBlock} from "/snippets/AuthCodeBlock.jsx";

import {AuthCodeGroup} from "/snippets/AuthCodeGroup.jsx";

<Warning>

La date de fin de vie (EOL) des Règles et des Appels sera le **18 novembre 2026**. Ils ne sont plus disponibles pour les nouveaux locataires créés à partir du **16 octobre 2023**. Les locataires actuels ayant des hooks actifs conserveront l’accès aux produit Hooks jusqu’à la fin de leur durée de vie.

Nous vous conseillons vivement d’utiliser les Actions pour étendre Auth0. Avec les Actions, vous avez accès à des informations de type enrichies, à une documentation intégrée et à des packages `npm` publics, et vous pouvez connecter des intégrations externes qui optimisent votre expérience d’extensibilité globale. Pour en savoir plus sur ce que les Actions proposent, consultez [Comprendre comment fonctionnent Auth0 Actions](/docs/fr-ca/customize/actions/actions-overview).

Pour vous aider dans votre migration, nous proposons des guides qui vous aideront à [migrer des Règles vers les Actions](/docs/fr-ca/customize/actions/migrate/migrate-from-rules-to-actions) et à [migrer des Hooks vers les Actions](/docs/fr-ca/customize/actions/migrate/migrate-from-hooks-to-actions). Nous avons également une page dédiée à la [Migration vers les Actions](https://auth0.com/extensibility/movetoactions) qui met en évidence les comparaisons de fonctionnalités, [une démo des Actions](https://www.youtube.com/watch?v=UesFSY1klrI)  et d’autres ressources pour vous aider dans votre parcours de migration.

Pour en savoir plus sur l’obsolescence des Règles et des Appels, consultez notre article de blog : [Preparing for Rules and Hooks End of Life (Préparation à la fin de vie des règles et des crochets)](https://auth0.com/blog/preparing-for-rules-and-hooks-end-of-life/).

</Warning>

<Warning>

Comme nous prévoyons de supprimer les fonctions Règles et Hooks en 2026, vous devez créer de nouvelles Règles ou de nouveaux Hooks uniquement dans votre environnement de développement et uniquement pour tester la migration vers les Actions.

Pour apprendre à migrer vos Règles vers des Actions, consultez [Migrer des règles vers les actions](/docs/fr-ca/customize/actions/migrate/migrate-from-rules-to-actions). Pour apprendre à migrer vos Hooks vers des Actions, consultez la section [Migrer des Hooks vers les actions](/docs/fr-ca/customize/actions/migrate/migrate-from-hooks-to-actions).

</Warning>

Vous pouvez modifier les permissions et ajouter des réclamations personnalisées dans les jetons émis à partir du [Flux des identifiants client](/docs/fr-ca/get-started/authentication-and-authorization-flow/client-credentials-flow) en ajoutant des [hooks](/docs/fr-ca/customize/hooks).

Les hooks vous permettent de personnaliser le comportement d’Auth0 à l’aide du code Node.js. Il s’agit de fonctions sécurisées et autonomes associées à des liens d’extensibilité HTTP particuliers de la plate-forme Auth0 (comme le Flux des identifiants client). Auth0 invoque les hooks à l’exécution pour exécuter votre logique personnalisée.

Vous pouvez gérer les hooks en utilisant Auth0 Dashboard ou Management API.

<Warning>

Bien que vous puissiez créer plusieurs hooks pour un point d’extensibilité donné, chaque point d’extensibilité ne peut avoir qu’un seul hook activé à la fois. Tous les appels ultérieurs que vous créez pour ce point d’extensibilité sont automatiquement désactivés. Vous devez donc les activer explicitement. Le hook activé sera exécuté pour toutes les applications et API.

</Warning>

## Prérequis

Avant de commencer ce tutoriel :

* [Enregistrez votre application avec Auth0](/docs/fr-ca/get-started/auth0-overview/set-up-apis)

  + [Ajoutez les permissions API appropriées](/docs/fr-ca/get-started/apis/add-api-permissions)
* [Enregistrez l’application machine-machine (M-M) avec Auth0](/docs/fr-ca/get-started/auth0-overview/create-applications/machine-to-machine-apps).

  + Sélectionnez un **type d’application** pour les **Applications machine-machine**.
  + Choisissez votre API précédemment enregistrée.
  + Autorisez l’application machine-machine (M2M) à appeler votre API.

## Étapes

1. **Créer des hooks** : Créez un hook qui permettra de personnaliser votre jeton.
2. **Tester le hook** : Testez votre nouveau hook en exécutant un Flux des identifiants client et en décodant le jeton d’accès.

### Créer un hook

Dans cet exemple, vous allez :

* ajouter une réclamation arbitraire (`https://foo.com/claim`) [au jeton d’accès](/docs/fr-ca/secure/tokens/access-tokens)
* ajouter une autorisation supplémentaire à votre API configurée

Créer un hook qui permettra de personnaliser votre jeton. Lorsqu’on vous demande de choisir un point d’extensibilité, sélectionnez `Client Credentials Exchange`, et ajoutez le code suivant dans l’éditeur :

```javascript lines
module.exports = function(client, scope, audience, context, cb) {
  var access_token = {};
  access_token['https://foo.com/claim'] = 'bar';
  access_token.scope = scope;
  access_token.scope.push('extra');
  cb(null, access_token);
};
```

<Warning>

Auth0 renvoie les informations de profil contenues dans un format de demande structuré tel que défini par la [spécification OpenID Connect (OIDC)](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims). Cela signifie que les demandes personnalisées ajoutées aux jetons d’ID ou aux jetons d’accès doivent [respecter des directives et des restrictions](/docs/fr-ca/secure/tokens/json-web-tokens/create-custom-claims) pour éviter d’éventuels conflits.

</Warning>

### Tester votre hook

Pour tester le hook que vous venez de créer, vous devez exécuter un échange d’identifiants client, obtenir le jeton d’accès, le décoder et examiner son contenu.

#### Obtenir un jeton

Pour obtenir un jeton, effectuez un appel `POST` au [point de terminaison du Flux des identifiants client](/docs/fr-ca/api/authentication#client-credentials-flow) Assurez-vous de remplacer les valeurs d’espace réservé CLIENT_ID, CLIENT_SECRET et API_IDENTIFIER par l’ID client de votre application, le secret client de votre application et l’identifiant de votre API, respectivement. Vous pouvez trouver l’ID client et le secret client dans les paramètres de votre [Application](https://manage.auth0.com/#/applications) et l’identifiant API dans les paramètres de votre [API](https://manage.auth0.com/#/apis).

<AuthCodeGroup>
```bash cURL
curl --request POST \
  --url 'https://{yourDomain}/oauth/token' \
  --header 'content-type: application/x-www-form-urlencoded' \
  --data grant_type=client_credentials \
  --data 'client_id={yourClientId}' \
  --data client_secret={yourClientSecret} \
  --data audience=YOUR_API_IDENTIFIER
```
```csharp C#
var client = new RestClient("https://{yourDomain}/oauth/token");
var request = new RestRequest(Method.POST);
request.AddHeader("content-type", "application/x-www-form-urlencoded");
request.AddParameter("application/x-www-form-urlencoded", "grant_type=client_credentials&client_id={yourClientId}&client_secret={yourClientSecret}&audience=YOUR_API_IDENTIFIER", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```
```go Go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/oauth/token"

	payload := strings.NewReader("grant_type=client_credentials&client_id={yourClientId}&client_secret={yourClientSecret}&audience=YOUR_API_IDENTIFIER")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("content-type", "application/x-www-form-urlencoded")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java
HttpResponse response = Unirest.post("https://{yourDomain}/oauth/token")
  .header("content-type", "application/x-www-form-urlencoded")
  .body("grant_type=client_credentials&client_id={yourClientId}&client_secret={yourClientSecret}&audience=YOUR_API_IDENTIFIER")
  .asString();
```
```javascript Node.JS
var axios = require("axios").default;

var options = {
  method: 'POST',
  url: 'https://{yourDomain}/oauth/token',
  headers: {'content-type': 'application/x-www-form-urlencoded'},
  data: new URLSearchParams({
    grant_type: 'client_credentials',
    client_id: '{yourClientId}',
    client_secret: '{yourClientSecret}',
    audience: 'YOUR_API_IDENTIFIER'
  })
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```objc Obj-C
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"content-type": @"application/x-www-form-urlencoded" };

NSMutableData *postData = [[NSMutableData alloc] initWithData:[@"grant_type=client_credentials" dataUsingEncoding:NSUTF8StringEncoding]];
[postData appendData:[@"&client_id={yourClientId}" dataUsingEncoding:NSUTF8StringEncoding]];
[postData appendData:[@"&client_secret={yourClientSecret}" dataUsingEncoding:NSUTF8StringEncoding]];
[postData appendData:[@"&audience=YOUR_API_IDENTIFIER" dataUsingEncoding:NSUTF8StringEncoding]];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/oauth/token"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"POST"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```
```php PHP
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/oauth/token",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "POST",
  CURLOPT_POSTFIELDS => "grant_type=client_credentials&client_id={yourClientId}&client_secret={yourClientSecret}&audience=YOUR_API_IDENTIFIER",
  CURLOPT_HTTPHEADER => [
    "content-type: application/x-www-form-urlencoded"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python
import http.client

conn = http.client.HTTPSConnection("")

payload = "grant_type=client_credentials&client_id={yourClientId}&client_secret={yourClientSecret}&audience=YOUR_API_IDENTIFIER"

headers = { 'content-type': "application/x-www-form-urlencoded" }

conn.request("POST", "/{yourDomain}/oauth/token", payload, headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```
```ruby Ruby
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/oauth/token")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Post.new(url)
request["content-type"] = 'application/x-www-form-urlencoded'
request.body = "grant_type=client_credentials&client_id={yourClientId}&client_secret={yourClientSecret}&audience=YOUR_API_IDENTIFIER"

response = http.request(request)
puts response.read_body
```
```swift Swift
import Foundation

let headers = ["content-type": "application/x-www-form-urlencoded"]

let postData = NSMutableData(data: "grant_type=client_credentials".data(using: String.Encoding.utf8)!)
postData.append("&client_id={yourClientId}".data(using: String.Encoding.utf8)!)
postData.append("&client_secret={yourClientSecret}".data(using: String.Encoding.utf8)!)
postData.append("&audience=YOUR_API_IDENTIFIER".data(using: String.Encoding.utf8)!)

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/oauth/token")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</AuthCodeGroup>

Une réponse réussie comprendra :

* un `access_token`,
* son délai d’expiration en secondes (`expires_in`),
* le type du jeton est défini comme `Bearer` (`token_type`), et
* une permission `extra` (`scope`) (qui a été ajoutée par votre hook)

``` lines
HTTP/1.1 200 OK
Content-Type: application/json
{
  "access_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImtpZCI6Ik5ESTFNa05DTVRGQlJrVTRORVF6UXpFMk1qZEVNVVEzT1VORk5ESTVSVU5GUXpnM1FrRTFNdyJ9.eyJpc3MiOiJodHRwczovL2RlbW8tYWNjb3VudC5hdXRoMC3jb20vIiwic3ViIjoic0FRSlFpQmYxREw0c2lqSVZCb2pFRUZvcmRoa0o4WUNAY2xpZW50cyIsImF1ZCI6ImRlbW8tYWNjb3VudC5hcGkiLCJleHAiOjE0ODc3NjU8NjYsImlhdCI6MTQ4NzY3OTI2Niwic2NvcGUiOiJyZWFkOmRhdGEgZXh0cmEiLCJodHRwczovL2Zvby5jb20vY2xhaW0iOiKoPXIifQ.da-48mHY_7esfLZpvHWWL8sIH1j_2mUYAB49c-B472lCdsNFvpaLoq6OKQyhnqk9_aW_Xhfkusos3FECTrLFvf-qwQK70QtwbkbVye_IuPSTAYdQ2T-XTzGDm9Nmmy5Iwl9rNYLxVs2OoCdfpVMyda0OaI0AfHBgEdKWluTP67OOnV_dF3KpuwtK3dPKWTCo2j9VCa7X1I4h0CNuM79DHhY2wO7sL8WBej7BSNA3N2TUsp_YTWWfrvsr_vVhJf-32G7w_12ms_PNFUwj2C30ZZIPWc-uEkDztyMLdI-lu9q9TLrLdr0dOhfrtfkdeJx4pUSiHdJHf42kg7UAVK6JcA",
  "expires_in": 86400,
  "scope": "extra",
  "token_type": "Bearer"
}
```

#### Décoder le jeton

Le moyen le plus simple de décoder le jeton d’accès et d’examiner son contenu est d’utiliser le [Débogueur JWT.io](https://jwt.io/#debugger-io).

Copiez votre jeton d’accès et collez-le dans l’éditeur. Le <Tooltip href="/docs/fr-ca/glossary?term=json-web-token" tip="Jeton Web JSON (JWT)
Format standard de jeton d’ID (et souvent de jeton d’accès) utilisé pour représenter en toute sécurité des demandes entre deux parties." cta="Voir le glossaire">JWT</Tooltip> est décodé automatiquement et son contenu est affiché.

Veuillez noter que les deux derniers éléments de **Charge utile** ont tous deux été définis par votre hook :

* `"scope": "extra"`
* `"https://foo.com/claim": "bar"`

## En savoir plus

* [Hooks Auth0](/docs/fr-ca/customize/hooks)
* [Flux des identifiants client](/docs/fr-ca/get-started/authentication-and-authorization-flow/client-credentials-flow)
* [Effectuer une requête à votre API à l’aide du Flux des identifiants client](/docs/fr-ca/get-started/authentication-and-authorization-flow/client-credentials-flow/call-your-api-using-the-client-credentials-flow)