---
title: "Rotation des clés de connexion"
permalink: "rotate-signing-keys"
'description': "Découvrez comment faire pivoter la clé de connexion de l’application ou de l’API de votre locataire à l’aide de Auth0 Dashboard ou de Management API."
'og:title': "Rotation des clés de connexion"
'og:description': "Découvrez comment faire pivoter la clé de connexion de l’application ou de l’API de votre locataire à l’aide de Auth0 Dashboard ou de Management API."
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "Rotation des clés de connexion"
'twitter:description': "Découvrez comment faire pivoter la clé de connexion de l’application ou de l’API de votre locataire à l’aide de Auth0 Dashboard ou de Management API."
---
import {AuthCodeBlock} from "/snippets/AuthCodeBlock.jsx";

import {AuthCodeGroup} from "/snippets/AuthCodeGroup.jsx";

Vous pouvez faire pivoter manuellement et périodiquement une clé de connexion afin de modifier la clé Web JSON (JWK) utilisée par les applications et les API pour valider les jetons. Si votre application ou API **ne** permet pas ce changement de clé et tente d’utiliser une clé de connexion expirée pour vérifier un jeton, la demande d’authentification échouera.

<Warning>

Auth0 vous recommande d’exécuter d’abord la rotation des clés de connexion sur un locataire de développement, puis de vérifier que vos applications et API fonctionnent comme prévu. Après avoir vérifié que tout fonctionne correctement, effectuez la même rotation des clés de connexion sur votre locataire de production.

</Warning>

Bien qu’Auth0 n’utilise qu’une seule clé de connexion à la fois, le document de découverte <Tooltip href="/docs/fr-ca/glossary?term=openid" tip="OpenID
Norme ouverte d’authentification qui permet aux applications de vérifier l’identité des utilisateurs sans avoir à collecter leurs informations de connexion." cta="Voir le glossaire">OpenID</Tooltip> Connect (OIDC) de votre locataire contient en permanence différentes clés. Le document de découverte OIDC inclura systématiquement la clé actuelle et la clé suivante, et il peut également inclure la clé précédente si cette dernière n’a pas encore été révoquée. Pour offrir une expérience transparente en cas d’urgence, votre application doit pouvoir utiliser n’importe laquelle des clés spécifiées dans le document. Pour en savoir plus sur les documents de découverte OpenID Connect, consultez [Localiser les ensembles de clés JSON Web](/docs/fr-ca/secure/tokens/json-web-tokens/locate-json-web-key-sets).

<Warning>

Pour vous donner le temps de mettre à jour votre application avec la nouvelle clé de connexion, tous les jetons signés avec la clé précédente resteront valides jusqu’à révocation de celle-ci. Pour en savoir plus, consultez [Révoquer les clés de connexion](/docs/fr-ca/get-started/tenant-settings/signing-keys/revoke-signing-keys).

</Warning>

Vous pouvez faire pivoter la clé de connexion de l’application de votre locataire à l’aide de <Tooltip href="/docs/fr-ca/glossary?term=auth0-dashboard" tip="Auth0 Dashboard
Principal produit d’Auth0 pour configurer vos services." cta="Voir le glossaire">Auth0 Dashboard</Tooltip> ou de <Tooltip href="/docs/fr-ca/glossary?term=management-api" tip="Management API
Un produit permettant aux clients d’effectuer des tâches administratives." cta="Voir le glossaire">Management API</Tooltip> Auth0.

## Utiliser le Dashboard

1. Allez à [Dashboard > Paramètres > Clés de connexion](https://manage.auth0.com/#](/docs/images/gning_keys).

   <Frame>![Tableau de bord Paramètres de locataire Onglet Clés d’authentification](/images/fr-ca/cdy7uua7fh8z/7r8t3EGctFmvkCgPrU0i2R/bb24776ecacfeb67abc471b125d84ef4/Signing_Keys_-_FR.png)</Frame>

2. Sous **Rotation Settings (Paramètres de rotation)**, localisez **Rotate Signing Key (Faire pivoter la clé de connexion)** et sélectionnez **Rotate Key (Faire pivoter la clé)**.
3. Cliquez sur **Rotation** pour confirmer.

   <Frame>![Tableau de bord Paramètres Clés d’authentification Onglet Confirmation de la rotation](/images/fr-ca/cdy7uua7fh8z/6Ofp24mgt8ZrvaxF2wLA5N/34f20aa70259d4f55729eb35d2ebf248/Rotate_Keys_-_FR.png)</Frame>

## Utilisation de Management API

1. Pour obtenir une liste des clés d’authentification, effectuez un appel `GET` au point de terminaison [Obtenir toutes les clés de connexion d’application](/docs/fr-ca/api/management/v2#!/Keys/get_signing_keys).
2. Pour faire pivoter la clé de connexion, effectuez un appel `POST` au point de terminaison [Rotate the Application Signing Key](/docs/fr-ca/api/management/v2#!/Keys/post_signing_keys) (Faire pivoter la clé de connexion d’application). Assurez-vous de remplacer la valeur de remplacement `MGMT_API_ACCESS_TOKEN` par votre jeton d’accès de Management API.

<AuthCodeGroup>
```bash cURL
   curl --request POST \
   --url 'https://{yourDomain}/api/v2/keys/signing/rotate' \
   --header 'authorization: Bearer {yourMgmtApiAccessToken}'

```
```csharp C#
   var client = new RestClient("https://{yourDomain}/api/v2/keys/signing/rotate");
var request = new RestRequest(Method.POST);
request.AddHeader("authorization", "Bearer {yourMgmtApiAccessToken}");
IRestResponse response = client.Execute(request);

```
```go Go
   package main

import (
   "fmt"
   "net/http"
   "io/ioutil"
)

func main() {

   url := "https://{yourDomain}/api/v2/keys/signing/rotate"

   req, _ := http.NewRequest("POST", url, nil)

   req.Header.Add("authorization", "Bearer {yourMgmtApiAccessToken}")

   res, _ := http.DefaultClient.Do(req)

   defer res.Body.Close()
   body, _ := ioutil.ReadAll(res.Body)

   fmt.Println(res)
   fmt.Println(string(body))

}

```
```java Java
   HttpResponse response = Unirest.post("https://{yourDomain}/api/v2/keys/signing/rotate")
   .header("authorization", "Bearer {yourMgmtApiAccessToken}")
   .asString();

```
```javascript Node.JS
   var axios = require("axios").default;

var options = {
method: 'POST',
url: 'https://{yourDomain}/api/v2/keys/signing/rotate',
headers: {authorization: 'Bearer {yourMgmtApiAccessToken}'}
};

axios.request(options).then(function (response) {
console.log(response.data);
}).catch(function (error) {
console.error(error);
});

```
```objc Obj-C
   #import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"authorization": @"Bearer {yourMgmtApiAccessToken}" };

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/keys/signing/rotate"]
                                                      cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"POST"];
[request setAllHTTPHeaderFields:headers];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                          completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                   NSLog(@"%@", error);
                                                } else {
                                                   NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                   NSLog(@"%@", httpResponse);
                                                }
                                          }];
[dataTask resume];

```
```php PHP
   $curl = curl_init();

curl_setopt_array($curl, [
CURLOPT_URL => "https://{yourDomain}/api/v2/keys/signing/rotate",
CURLOPT_RETURNTRANSFER => true,
CURLOPT_ENCODING => "",
CURLOPT_MAXREDIRS => 10,
CURLOPT_TIMEOUT => 30,
CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
CURLOPT_CUSTOMREQUEST => "POST",
CURLOPT_HTTPHEADER => [
   "authorization: Bearer {yourMgmtApiAccessToken}"
],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
echo "cURL Error #:" . $err;
} else {
echo $response;
}

```
```python Python
   import http.client

conn = http.client.HTTPSConnection("")

headers = { 'authorization': "Bearer {yourMgmtApiAccessToken}" }

conn.request("POST", "/{yourDomain}/api/v2/keys/signing/rotate", headers=headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))

```
```ruby Ruby
   require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/api/v2/keys/signing/rotate")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Post.new(url)
request["authorization"] = 'Bearer {yourMgmtApiAccessToken}'

response = http.request(request)
puts response.read_body

```
```swift Swift
   import Foundation

let headers = ["authorization": "Bearer {yourMgmtApiAccessToken}"]

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/keys/signing/rotate")! as URL,
                                       cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
if (error != nil) {
   print(error)
} else {
   let httpResponse = response as? HTTPURLResponse
   print(httpResponse)
}
})

dataTask.resume()

```
</AuthCodeGroup>

<table class="table"><thead>
<tr>
<th><strong>Valeur</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>`MGMT_API_ACCESS_TOKEN`</td>
<td><a href="https://auth0.com/docs/api/management/v2/tokens">Access Token for the Management API (Jeton d’accès pour Management API)</a> avec les permissions `create:signing_keys` et `update:signing_keys`.</td>
</tr>
</tbody>
</table>

## Impact de la rotation des clés

### API et passerelles API qui acceptent les jetons d’accès

La plupart des logiciels médiateurs et des passerelles API utilisent le point de terminaison JSON web key set (JWKS) pour récupérer les clés de connexion actuelles et futures à un certain intervalle. Si votre logiciel médiateur et/ou vos passerelles API ne prennent **pas** en charge ce point de terminaison et nécessitent que vous configuriez manuellement un fichier `*.cer`, vous allez devoir coordonner la rotation des clés de connexion dans Auth0 avec la reconfiguration de votre logiciel médiateur et de vos passerelles.

### Applications Web standard

Lors de la rotation de la clé de connexion dans Auth0, vous devrez coordonner la reconfiguration de vos applications qui utilisent <Tooltip href="/docs/fr-ca/glossary?term=ws-fed" tip="Web Service Federation (WS-Fed)
Protocole de gestion des identités des utilisateurs à travers les domaines." cta="Voir le glossaire">WS-Fed</Tooltip> ou <Tooltip href="/docs/fr-ca/glossary?term=security-assertion-markup-language" tip="Security Assertion Markup Language (SAML)
Protocole normalisé permettant à deux parties d’échanger des informations d’authentification sans mot de passe." cta="Voir le glossaire">SAML</Tooltip>. Cela se produit généralement lorsque vous téléversez le nouveau certificat public ou que vous reconfigurez l’application en saisissant l’URL des métadonnées WS-Fed/SAMLURL. Cela modifiera la clé JWKS, qui est utilisée par les applications pour valider les jetons. Assurez-vous que votre implémentation ne suppose pas que les clés JWKS ne sont pas modifiées.

## En savoir plus

* [Révoquer les clés de connexion](/docs/fr-ca/get-started/tenant-settings/signing-keys/revoke-signing-keys)
* [Localiser les jeux de clés Web JSON](/docs/fr-ca/secure/tokens/json-web-tokens/locate-json-web-key-sets)
* [Modification des algorithmes de signature des applications](/docs/fr-ca/get-started/applications/change-application-signing-algorithms)
* [Afficher les certificats de connexion](/docs/fr-ca/get-started/tenant-settings/signing-keys/view-signing-certificates)