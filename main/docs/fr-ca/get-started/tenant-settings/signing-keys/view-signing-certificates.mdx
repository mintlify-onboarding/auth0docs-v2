---
title: "Afficher les certificats de connexion"
permalink: "view-signing-certificates"
'description': "Explique comment afficher les secrets client et les clés de connexion à l’aide de l’Auth0 Dashboard ou de Management API."
'og:title': "Afficher les certificats de connexion"
'og:description': "Explique comment afficher les secrets client et les clés de connexion à l’aide de l’Auth0 Dashboard ou de Management API."
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "Afficher les certificats de connexion"
'twitter:description': "Explique comment afficher les secrets client et les clés de connexion à l’aide de l’Auth0 Dashboard ou de Management API."
---
import {AuthCodeBlock} from "/snippets/AuthCodeBlock.jsx";

import {AuthCodeGroup} from "/snippets/AuthCodeGroup.jsx";

Vous pouvez afficher les secrets client et les clés de connexion de l’application de votre locataire à l’aide de l’<Tooltip href="/docs/fr-ca/glossary?term=auth0-dashboard" tip="Auth0 Dashboard
Principal produit d’Auth0 pour configurer vos services." cta="Voir le glossaire">Auth0 Dashboard</Tooltip> ou de <Tooltip href="/docs/fr-ca/glossary?term=management-api" tip="Management API
Un produit permettant aux clients d’effectuer des tâches administratives." cta="Voir le glossaire">Management API</Tooltip>. La clé de connexion est utilisée pour signer les jetons d’ID, les jetons d’accès, les assertions <Tooltip href="/docs/fr-ca/glossary?term=security-assertion-markup-language" tip="Security Assertion Markup Language (SAML)
Protocole normalisé permettant à deux parties d’échanger des informations d’authentification sans mot de passe." cta="Voir le glossaire">SAML</Tooltip> et les assertions <Tooltip href="/docs/fr-ca/glossary?term=ws-fed" tip="Web Service Federation (WS-Fed)
Protocole de gestion des identités des utilisateurs à travers les domaines." cta="Voir le glossaire">WS-Fed</Tooltip> envoyées à votre application. Ces clés sont différentes de celles utilisées pour signer les interactions avec les connexions, y compris la signature des demandes SAML aux fournisseurs d’identité (<Tooltip href="/docs/fr-ca/glossary?term=idp" tip="Fournisseur d’identité (IdP)
Service de stockage et de gestion des identités numériques." cta="Voir le glossaire">IdP</Tooltip>) et le chiffrement des réponses des IdP. Par défaut, les assertions SAML pour les connexions IdP sont signées, ce que nous recommandons. Pour en savoir plus, lisez [Paramètres de configuration du fournisseur d’identités SAML](/docs/fr-ca/authenticate/protocols/saml/saml-identity-provider-configuration-settings).

## Utilisation du Dashboard

### Paramètres du locataire

1. Allez à [Tableau de bord > Paramètres > Clés de connexion](https://manage.auth0](/docs/images/ant/signing_keys).

   <Frame>![Tableau de bord Paramètres de locataire Onglet Clés d’authentification](/images/fr-ca/cdy7uua7fh8z/7r8t3EGctFmvkCgPrU0i2R/bb24776ecacfeb67abc471b125d84ef4/Signing_Keys_-_FR.png)</Frame>

2. Dans la section **Paramètres de rotation**, localisez **Liste des clés valides** et **Liste des clés révoquées**.

   1. La section **Liste des clés valides** répertorie la clé de connexion actuellement utilisée par votre locataire, ainsi que la prochaine clé de connexion qui sera attribuée si vous décidez d’effectuer une rotation de vos clés de connexion. Si vous avez déjà effectué une rotation des clés de connexion, cette section répertorie également les clés utilisées précédemment.
   2. La section **Liste des clés révoquées** répertorie les trois dernières clés révoquées de votre locataire.

### Paramètres d’application

Vous pouvez également afficher la clé de connexion et/ou le secret client d’une application en fonction du type d’algorithme de signature utilisé.

#### Si vous utilisez l’algorithme de signature RS256

1. Allez dans [Dashboard > Applications](https://manage.auth0.com/#/applications) et sélectionnez le nom de l’application à afficher.
2. Faites défiler vers le bas de l’onglet **Paramètres** et sélectionnez **Paramètres avancés**.
3. Allez dans l’onglet **Certificats** et localisez le champ **Certificat de signature**.

   <Frame>![Dashboard Applications Paramètres avancés (Advanced Settings) onglet Certificate (Certificats)](/images/fr-ca/cdy7uua7fh8z/5eB167clrfOiBEtyrMOtkn/8cb2d66db96e92a3662c7ac1b668a502/Signing_Certs_-_FR.png)</Frame>

#### Si vous utilisez l’algorithme de signature HS256

1. Allez dans [Dashboard > Applications](https://manage.auth0.com/#/applications) et sélectionnez le nom de l’application à afficher.
2. Sous **Informations de base**, localisez le champ **Secret client**.

   <Frame>![Dashboard Onglet Paramètres d’application Information de base](/images/fr-ca/cdy7uua7fh8z/2GPUw7BODYuYYH3658Upz3/061d21a8d965cec77a7bc65793a0a994/App_-_Basic_Settings_-_FR.png)</Frame>

## Utiliser Management API

### Obtenir toutes les clés de connexion

Effectuez un appel `GET` vers le point de terminaison [`/signing_keys/get_signing_keys`](/docs/fr-ca/api/management/v2#!/signing_keys/get_signing_keys). Assurez-vous de remplacer la valeur de remplacement `{yourMgmtApiAccessToken}` par votre jeton d’accès de Management API.

<AuthCodeGroup>
```bash cURL
curl --request GET \
   --url 'https://{yourDomain}/api/v2/keys/signing' \
   --header 'authorization: Bearer {yourMgmtApiAccessToken}'
```
```csharp C#
var client = new RestClient("https://{yourDomain}/api/v2/keys/signing");
var request = new RestRequest(Method.GET);
request.AddHeader("authorization", "Bearer {yourMgmtApiAccessToken}");
IRestResponse response = client.Execute(request);
```
```go Go
package main

import (
	"fmt"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/api/v2/keys/signing"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("authorization", "Bearer {yourMgmtApiAccessToken}")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java
HttpResponse response = Unirest.get("https://{yourDomain}/api/v2/keys/signing")
   .header("authorization", "Bearer {yourMgmtApiAccessToken}")
   .asString();
```
```javascript Node.JS
var axios = require("axios").default;

var options = {
  method: 'GET',
  url: 'https://{yourDomain}/api/v2/keys/signing',
  headers: {authorization: 'Bearer {yourMgmtApiAccessToken}'}
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```objc Obj-C
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"authorization": @"Bearer {yourMgmtApiAccessToken}" };

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/keys/signing"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"GET"];
[request setAllHTTPHeaderFields:headers];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```
```php PHP
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/api/v2/keys/signing",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "GET",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer {yourMgmtApiAccessToken}"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python
import http.client

conn = http.client.HTTPSConnection("")

headers = { 'authorization': "Bearer {yourMgmtApiAccessToken}" }

conn.request("GET", "/{yourDomain}/api/v2/keys/signing", headers=headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```
```ruby Ruby
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/api/v2/keys/signing")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Get.new(url)
request["authorization"] = 'Bearer {yourMgmtApiAccessToken}'

response = http.request(request)
puts response.read_body
```
```swift Swift
import Foundation

let headers = ["authorization": "Bearer {yourMgmtApiAccessToken}"]

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/keys/signing")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</AuthCodeGroup>

<table class="table"><thead>
<tr>
<th>Valeur</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>`MGMT_API_ACCESS_TOKEN`</td>
<td><a href="https://auth0.com/docs/api/management/v2/tokens">Jeton d’accès à Management API</a> avec la permission `read:signing_keys`.</td>
</tr>
</tbody>
</table>

### Obtenir une seule clé de connexion

Effectuez un appel `GET` vers le point de terminaison [`/signing_keys/get_signing_key`](/docs/fr-ca/api/management/v2#!/signing_keys/get_signing_key). Assurez-vous de remplacer les valeurs des espaces réservés `{yourKeyId}` et `{yourMgmtApiAccessToken}` par votre ID de clé de connexion et votre jeton d’accès de Management API, respectivement.

<AuthCodeGroup>
```bash cURL
curl --request GET \
   --url 'https://{yourDomain}/api/v2/keys/signing/%7ByourKeyId%7D' \
   --header 'authorization: Bearer {yourMgmtApiAccessToken}'
```
```csharp C#
var client = new RestClient("https://{yourDomain}/api/v2/keys/signing/%7ByourKeyId%7D");
var request = new RestRequest(Method.GET);
request.AddHeader("authorization", "Bearer {yourMgmtApiAccessToken}");
IRestResponse response = client.Execute(request);
```
```go Go
package main

import (
	"fmt"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/api/v2/keys/signing/%7ByourKeyId%7D"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("authorization", "Bearer {yourMgmtApiAccessToken}")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java
HttpResponse response = Unirest.get("https://{yourDomain}/api/v2/keys/signing/%7ByourKeyId%7D")
   .header("authorization", "Bearer {yourMgmtApiAccessToken}")
   .asString();
```
```javascript Node.JS
var axios = require("axios").default;

var options = {
  method: 'GET',
  url: 'https://{yourDomain}/api/v2/keys/signing/%7ByourKeyId%7D',
  headers: {authorization: 'Bearer {yourMgmtApiAccessToken}'}
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```objc Obj-C
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"authorization": @"Bearer {yourMgmtApiAccessToken}" };

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/keys/signing/%7ByourKeyId%7D"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"GET"];
[request setAllHTTPHeaderFields:headers];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```
```php PHP
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/api/v2/keys/signing/%7ByourKeyId%7D",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "GET",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer {yourMgmtApiAccessToken}"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python
import http.client

conn = http.client.HTTPSConnection("")

headers = { 'authorization': "Bearer {yourMgmtApiAccessToken}" }

conn.request("GET", "/{yourDomain}/api/v2/keys/signing/%7ByourKeyId%7D", headers=headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```
```ruby Ruby
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/api/v2/keys/signing/%7ByourKeyId%7D")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Get.new(url)
request["authorization"] = 'Bearer {yourMgmtApiAccessToken}'

response = http.request(request)
puts response.read_body
```
```swift Swift
import Foundation

let headers = ["authorization": "Bearer {yourMgmtApiAccessToken}"]

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/keys/signing/%7ByourKeyId%7D")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</AuthCodeGroup>

<table class="table"><thead>
<tr>
<th>Valeur</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>`YOUR_KEY_ID`</td>
<td>ID de la clé de connexion à afficher. Pour savoir comment trouver l’ID de votre clé de connexion, consultez <a href="https://auth0.com/docs/tokens/guides/locate-jwks">Localiser des ensembles de clés Web JSON</a>.</td>
</tr>
<tr>
<td>`MGMT_API_ACCESS_TOKEN`</td>
<td><a href="https://auth0.com/docs/api/management/v2/tokens">Jeton d’accès pour Management API</a> avec la permission `read:signing_keys`.</td>
</tr>
</tbody>
</table>

## En savoir plus

* [Révoquer les clés de connexion](/docs/fr-ca/get-started/tenant-settings/signing-keys/revoke-signing-keys)
* [Rotation des clés de connexion](/docs/fr-ca/get-started/tenant-settings/signing-keys/rotate-signing-keys)
* [Algorithmes de signature](/docs/fr-ca/get-started/applications/signing-algorithms)
* [Modification des algorithmes de signature des applications](/docs/fr-ca/get-started/applications/change-application-signing-algorithms)