---
title: "Ajouter une autorisation à votre API Ruby on Rails"
permalink: "interactive"
'description': "Ce tutoriel effectue la validation des jetons d’accès en utilisant le gem jwt dans une classe Auth0Client personnalisée."
'og:title': "Ajouter une autorisation à votre API Ruby on Rails"
'og:description': "Ce tutoriel effectue la validation des jetons d’accès en utilisant le gem jwt dans une classe Auth0Client personnalisée."
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/media/platforms/rails.png"
'twitter:title': "Ajouter une autorisation à votre API Ruby on Rails"
'twitter:description': "Ce tutoriel effectue la validation des jetons d’accès en utilisant le gem jwt dans une classe Auth0Client personnalisée."
sidebarTitle: Ruby on Rails API
---

import { Recipe, Content, Section, SideMenu, SideMenuSectionItem, SignUpForm } from "/snippets/recipe.jsx";
import { LoggedInForm } from "/snippets/Login.jsx";
import ApplicationController from "/snippets/quickstart/backend/rails/application_controller.rb.mdx";
import Auth0Client from "/snippets/quickstart/backend/rails/auth0_client.rb.mdx";
import Secured from "/snippets/quickstart/backend/rails/secured.rb.mdx";
import PublicController from "/snippets/quickstart/backend/rails/public_controller.rb.mdx";
import PrivateController from "/snippets/quickstart/backend/rails/private_controller.rb.mdx";

export const sections = [
  { id: "définir-les-autorisations", title: "Définir les autorisations" },
  { id: "installer-les-dépendances", title: "Installer les dépendances" },
  { id: "créer-une-classe-auth0client", title: "Créer une classe Auth0Client" },
  { id: "définir-un-concern-secured", title: "Définir un concern Secured" },
  { id: "inclure-la-préoccupation-secure-dans-votre-applicationcontroller", title: "Inclure la préoccupation Secure dans votre ApplicationController" },
  { id: "créer-le-point-de-terminaison-public", title: "Créer le point de terminaison public" },
  { id: "créer-les-points-de-terminaison-privés", title: "Créer les points de terminaison privés" }
]

<Recipe>
  <Content>
    Ce tutoriel effectue la validation des jetons d’accès en utilisant le gem [**jwt**](https://github.com/jwt/ruby-jwt) dans une classe `Auth0Client` personnalisée. Un concern appelé `Secured` est utilisé pour autoriser les points de terminaison qui nécessitent une authentification par le biais d’un jeton d’accès entrant.

    Si vous n’avez pas encore créé d’API dans votre Auth0 Dashboard, vous pouvez utiliser le sélecteur interactif pour créer une nouvelle API Auth0 ou sélectionner une API existante pour votre projet.

    Pour configurer votre première API via Auth0 Dashboard, consultez [notre guide de démarrage](https://auth0.com/docs/get-started/auth0-overview/set-up-apis).

    Chaque API Auth0 utilise l’identificateur API, dont votre application a besoin pour valider le jeton d’accès.

    <Info>
    **Vous ne connaissez pas Auth0?** Découvrez [Auth0](https://auth0.com/docs/overview) et [l’implémentation de l’authentification et de l’autorisation d’API](https://auth0.com/docs/api-auth) en utilisant le cadre d’applications OAuth 2.0.
    </Info>

      <Section id={sections[0].id} title={sections[0].title} stepNumber="1">
      Les autorisations vous permettent de définir comment les ressources peuvent être accessibles au nom de l’utilisateur avec un jeton d’accès donné. Par exemple, vous pouvez choisir d’accorder un accès en lecture à la ressource `messages` si les utilisateurs ont le niveau d’accès gestionnaire et un accès en écriture à cette ressource s’ils ont le niveau d’accès administrateur.

      Vous pouvez définir les autorisations autorisées dans la vue **Permissions (Autorisations)** de la section [API](https://manage.auth0.com/#/apis) d’Auth0 Dashboard.

      ![Auth0 Dashboard> Applications > APIs (API) > [Specific API (API précise)] > Onglet Permissions (Autorisations)](/images/fr-ca/cdy7uua7fh8z/1s3Yp5zqJiKiSWqbPSezNO/677a3405b2853f5fdf9e42f6e83ceba7/Quickstarts_API_-_French.png)

      <Info>
      Cet exemple utilise la permission `read:messages`.
      </Info>
      </Section>

      <Section id={sections[1].id} title={sections[1].title} stepNumber="2">
      Installer le gem **jwt**.

      ```
      gem 'jwt'
      bundle install
      ```
      </Section>

      <Section id={sections[2].id} title={sections[2].title} stepNumber="3">
      Créez une classe appelée `Auth0Client`. Cette classe décode et vérifie le jeton d’accès entrant provenant de l’en-tête `Authorization`  de la requête.

      La classe `Auth0Client` récupère la clé publique de votre locataire Auth0 et l’utilise pour vérifier la signature du jeton d’accès. La structure `Token` définit une méthode `validate_permissions` pour rechercher une `scope` particulière dans un jeton d’accès en fournissant un tableau des permissions requises et en vérifiant si elles sont présentes dans la charge utile du jeton.
      </Section>

      <Section id={sections[3].id} title={sections[3].title} stepNumber="4">
      Créez un concern appelé `Secured` qui recherche le jeton d’accès dans l’en-tête `Authorization` d’une requête entrante.

      Si le jeton est présent, `Auth0Client.validate_token` utilisera le gem `jwt` pour vérifier la signature du jeton et valider les demandes du jeton.

      Outre la vérification de la validité du jeton d’accès, concern possède un mécanisme permettant de confirmer que le jeton dispose d’une **permission** suffisante pour accéder aux ressources demandées. Dans cet exemple, nous définissons une méthode `validate_permissions` qui reçoit un bloc et vérifie les autorisations en appelant la méthode `Token.validate_permissions` de la classe `Auth0Client`.

      Pour la route `/private-scoped`, les permissions définies seront croisées avec les permissions provenant de la charge utile, afin de déterminer si elle contient un ou plusieurs éléments de l’autre tableau.
      </Section>

      <Section id={sections[4].id} title={sections[4].title} stepNumber="5">
      En ajoutant la préoccupation `Secure` à votre contrôleur d’application, vous n’aurez plus qu’à utiliser un filtre `before_action` dans le contrôleur qui requiert une autorisation.
      </Section>

      <Section id={sections[5].id} title={sections[5].title} stepNumber="6">
      Créez un contrôleur pour gérer le point de terminaison public `/api/public`.

      Le point de terminaison `/public` ne requiert aucune autorisation et aucune `before_action` n’est donc nécessaire.
      </Section>

      <Section id={sections[6].id} title={sections[6].title} stepNumber="7">
      Créez un contrôleur pour traiter les points de terminaison privés : `/api/private` et `/api/private-scoped`.

      `/api/private` est disponible pour les requêtes authentifiées contenant un jeton d’accès sans permission supplémentaire.

      `/api/private-scoped` est disponible pour les requêtes authentifiées contenant un jeton d’accès dont la permission `read:messages` est accordée.

      Les points de terminaison protégés doivent appeler la méthode `authorize` du concern `Secured`; vous devez pour cela utiliser `before_action :authorize`, ce qui assure que la méthode `Secured.authorize` est appelée avant chaque action dans le `PrivateController`.

      ### Faire un appel à votre API

      Pour appeler votre API, vous avez besoin d’un jeton d’accès. Vous pouvez obtenir un jeton d’accès à des fins de test dans la vue **Test** dans vos [API settings (Paramètres API)](https://manage.auth0.com/#/apis).

      ![Auth0 Dashboard> Applications > API > [API specifique] > Onglet Test](/images/fr-ca/cdy7uua7fh8z/6jeVBuypOGX5qMRXeJn5ow/8aa621c6d95e3f21115493a19ab05f7a/Quickstart_Example_App_-_API.png)

      Fournissez le jeton d’accès comme un en-tête `Authorization` dans vos demandes.

      <CodeGroup>
        ```bash cURL lines
        curl --request get \
        --url 'http:///%7ByourDomain%7D/api_path' \
        --header 'authorization: Bearer YOUR_ACCESS_TOKEN_HERE'
        ```

        ```csharp C# lines
        var client = new RestClient("http:///%7ByourDomain%7D/api_path");
        var request = new RestRequest(Method.GET);
        request.AddHeader("authorization", "Bearer YOUR_ACCESS_TOKEN_HERE");
        IRestResponse response = client.Execute(request);
        ```

        ```go Go lines
        package main
        import (
        "fmt"
        "net/http"
        "io/ioutil"
        )
        func main() {
        url := "http:///%7ByourDomain%7D/api_path"
        req, _ := http.NewRequest("get", url, nil)
        req.Header.Add("authorization", "Bearer YOUR_ACCESS_TOKEN_HERE")
        res, _ := http.DefaultClient.Do(req)
        defer res.Body.Close()
        body, _ := ioutil.ReadAll(res.Body)
        fmt.Println(res)
        fmt.Println(string(body))
        }
        ```

        ```java Java lines
        HttpResponse<String> response = Unirest.get("http:///%7ByourDomain%7D/api_path")
        .header("authorization", "Bearer YOUR_ACCESS_TOKEN_HERE")
        .asString();
        ```

        ```javascript Node.JS lines
        var axios = require("axios").default;
        var options = {
        method: 'get',
        url: 'http:///%7ByourDomain%7D/api_path',
        headers: {authorization: 'Bearer YOUR_ACCESS_TOKEN_HERE'}
        };
        axios.request(options).then(function (response) {
        console.log(response.data);
        }).catch(function (error) {
        console.error(error);
        });
        ```

        ```obj-c Obj-C lines
        #import <Foundation/Foundation.h>
        NSDictionary *headers = @{ @"authorization": @"Bearer YOUR_ACCESS_TOKEN_HERE" };
        NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"http:///%7ByourDomain%7D/api_path"]
                                                        cachePolicy:NSURLRequestUseProtocolCachePolicy

                                                    timeoutInterval:10.0];

        [request setHTTPMethod:@"get"];
        [request setAllHTTPHeaderFields:headers];
        NSURLSession *session = [NSURLSession sharedSession];
        NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                                completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {

                                                    if (error) {

                                                        NSLog(@&quot;%@&quot;, error);

                                                    } else {

                                                        NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;

                                                        NSLog(@&quot;%@&quot;, httpResponse);

                                                    }

                                                }];

        [dataTask resume];
        ```

        ```php PHP lines
        #import <Foundation/Foundation.h>
        NSDictionary *headers = @{ @"authorization": @"Bearer YOUR_ACCESS_TOKEN_HERE" };
        NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"http:///%7ByourDomain%7D/api_path"]
                                                        cachePolicy:NSURLRequestUseProtocolCachePolicy

                                                    timeoutInterval:10.0];

        [request setHTTPMethod:@"get"];
        [request setAllHTTPHeaderFields:headers];
        NSURLSession *session = [NSURLSession sharedSession];
        NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                                completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {

                                                    if (error) {

                                                        NSLog(@&quot;%@&quot;, error);

                                                    } else {

                                                        NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;

                                                        NSLog(@&quot;%@&quot;, httpResponse);

                                                    }

                                                }];

        [dataTask resume];
        ```

        ```python Python lines
        import http.client
        conn = http.client.HTTPConnection("")
        headers = { 'authorization': "Bearer YOUR_ACCESS_TOKEN_HERE" }
        conn.request("get", "/%7ByourDomain%7D/api_path", headers=headers)
        res = conn.getresponse()
        data = res.read()
        print(data.decode("utf-8"))
        ```

        ```ruby Ruby lines
        require 'uri'
        require 'net/http'
        url = URI("http:///%7ByourDomain%7D/api_path")
        http = Net::HTTP.new(url.host, url.port)
        request = Net::HTTP::Get.new(url)
        request["authorization"] = 'Bearer YOUR_ACCESS_TOKEN_HERE'
        response = http.request(request)
        puts response.read_body
        ```

        ```swift Swift lines
        import Foundation
        let headers = ["authorization": "Bearer YOUR_ACCESS_TOKEN_HERE"]
        let request = NSMutableURLRequest(url: NSURL(string: "http:///%7ByourDomain%7D/api_path")! as URL,
                                            cachePolicy: .useProtocolCachePolicy,

                                        timeoutInterval: 10.0)

        request.httpMethod = "get"
        request.allHTTPHeaderFields = headers
        let session = URLSession.shared
        let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
        if (error != nil) {
        print(error)

        } else {
        let httpResponse = response as? HTTPURLResponse

        print(httpResponse)

        }
        })
        dataTask.resume()
        ```
        </CodeGroup>

      <Note>
      ##### Point de contrôle
      Maintenant que vous avez configuré votre application, exécutez-la pour vérifier que :
      `GET /api/public` est disponible pour les demandes non authentifiées.
      `GET /api/private` est disponible pour les demandes authentifiées.
      `GET /api/private-scoped` est disponible pour les demandes authentifiées contenant un jeton d’accès avec la permission `read:messages`.
      </Note>
      </Section>

    ## Étapes suivantes

    Beau travail! Si vous en êtes arrivé là, vous devriez avoir la connexion, la déconnexion et les informations de profil utilisateur actives dans votre application.

    Cela conclut notre tutoriel de démarrage rapide, mais il y a tellement plus à explorer. Pour en savoir plus sur ce que vous pouvez faire avec Auth0, consultez :

    *   [Auth0 Dashboard](https://manage.auth0.com/#) : apprenez à configurer et gérer votre locataire et vos applications Auth0
    *   [Trousse SDK omniauth-auth0](https://github.com/auth0/omniauth-auth0) : explorez en détail la trousse SDK utilisée dans ce tutoriel
    *   [Auth0 Marketplace](https://marketplace.auth0.com/) : découvrez des intégrations que vous pouvez activer pour étendre les fonctionnalités d’Auth0
  </Content>

  <SideMenu sections={sections}>
      <SideMenuSectionItem id={sections[0].id}>
        <SignUpForm lang="fr"/>
      </SideMenuSectionItem>

      <SideMenuSectionItem id={sections[1].id}>
        <SignUpForm lang="fr"/>
      </SideMenuSectionItem>

      <SideMenuSectionItem id={sections[2].id}>
        <CodeGroup>
          <Secured/>
          <ApplicationController/>
          <Auth0Client/>
          <PublicController/>
          <PrivateController/>
        </CodeGroup>
      </SideMenuSectionItem>

      <SideMenuSectionItem id={sections[3].id}>
        <CodeGroup>
          <Secured/>
          <ApplicationController/>
          <Auth0Client/>
          <PublicController/>
          <PrivateController/>
        </CodeGroup>
      </SideMenuSectionItem>

      <SideMenuSectionItem id={sections[4].id}>
        <CodeGroup>
          <ApplicationController/>
          <Auth0Client/>
          <Secured/>
          <PublicController/>
          <PrivateController/>
        </CodeGroup>
      </SideMenuSectionItem>

      <SideMenuSectionItem id={sections[5].id}>
        <CodeGroup>
          <PublicController/>
          <ApplicationController/>
          <Auth0Client/>
          <Secured/>
          <PrivateController/>
        </CodeGroup>
      </SideMenuSectionItem>

      <SideMenuSectionItem id={sections[6].id}>
        <CodeGroup>
          <PrivateController/>
          <ApplicationController/>
          <Auth0Client/>
          <Secured/>
          <PublicController/>
        </CodeGroup>
      </SideMenuSectionItem>

    </SideMenu>
</Recipe>
