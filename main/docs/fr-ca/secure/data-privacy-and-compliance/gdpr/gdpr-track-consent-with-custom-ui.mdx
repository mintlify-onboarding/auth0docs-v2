---
title: "RGPD : Suivre le consentement avec l’interface utilisateur personnalisée"
permalink: "gdpr-track-consent-with-custom-ui"
'description': "Cette section décrit comment vous pouvez utiliser soit auth0.js, soit les API Auth0 pour recueillir des informations de consentement lorsque vous utilisez votre propre interface utilisateur personnalisée pour les connexions."
'og:title': "RGPD : Suivre le consentement avec l’interface utilisateur personnalisée"
'og:description': "Cette section décrit comment vous pouvez utiliser soit auth0.js, soit les API Auth0 pour recueillir des informations de consentement lorsque vous utilisez votre propre interface utilisateur personnalisée pour les connexions."
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "RGPD : Suivre le consentement avec l’interface utilisateur personnalisée"
'twitter:description': "Cette section décrit comment vous pouvez utiliser soit auth0.js, soit les API Auth0 pour recueillir des informations de consentement lorsque vous utilisez votre propre interface utilisateur personnalisée pour les connexions."
---
import {AuthCodeBlock} from "/snippets/AuthCodeBlock.jsx";

import {AuthCodeGroup} from "/snippets/AuthCodeGroup.jsx";

Dans ce tutoriel, nous allons expliquer comment utiliser auth0.js ou les API Auth0 pour obtenir des informations sur le consentement, puis enregistrer ces informations dans les métadonnées de l’utilisateur. Pour en savoir plus, lisez [Comprendre le fonctionnement des métadonnées dans les profils utilisateurs](/docs/fr-ca/manage-users/user-accounts/metadata).

Si vous préférez suivre le consentement en utilisant Lock, consultez [RGPD : Track Consent with Lock (Suivre le consentement avec Lock)](https://auth0.com/docs/secure/data-privacy-and-compliance/gdpr/gdpr-track-consent-with-lock).

Le contenu de ce document ne constitue **pas** un avis juridique et ne remplace pas l’assistance juridique. C’est à vous qu’il incombe en dernier ressort de comprendre et de respecter le RGPD, mais Auth0 vous aidera à satisfaire aux exigences du RGPD dans la mesure du possible.

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Le contenu de ces documents ne constitue pas un avis juridique et ne doit pas être considéré comme un substitut à l’assistance juridique. C’est à vous qu’il incombe en dernier ressort de comprendre et de respecter le RGPD, mais Auth0 vous aidera à satisfaire aux exigences du RGPD dans la mesure du possible.

</Callout>

## Présentation

Nous capturerons les informations de consentement dans divers scénarios et les enregistrerons dans les métadonnées de l’utilisateur.

Tous les scénarios enregistreront les propriétés suivantes dans les métadonnées de l’utilisateur :

* `consentGiven` (true/false) indique si l’utilisateur a donné son consentement (true) ou non (false);
* `consentTimestamp` (horodatage Unix) indique quand l’utilisateur a donné son consentement.

Par exemple :

```json lines
{
  "consentGiven": "true"
  "consentTimestamp": "1525101183"
}
```

Nous allons voir quatre implémentations différentes :

1. Celle qui affiche un drapeau, fonctionne pour les connexions de base de données et utilise la bibliothèque auth0.js pour créer l’utilisateur (utilisée par les applications monopages). Pour en apprendre davantage, consultez [Auth0.js v9 Reference](/docs/fr-ca/libraries/auth0js).
2. Celle qui affiche un drapeau, fonctionne pour les connexions de base de données et utilise Authentication API pour créer l’utilisateur (utilisée par les applications Web classiques).
3. Celle qui affiche un drapeau, fonctionne pour les connexions sociales et utilise Management API pour mettre à jour les informations de l’utilisateur (utilisée soit par des applications monopages ou des applications Web classiques).
4. Celle qui redirige vers une autre page où les informations sur les conditions générales et/ou la politique de confidentialité peuvent être consultées et où les informations relatives au consentement peuvent être fournies (utilisée soit par des applications monopages soit par des applications Web classiques).

## Option 1 : Utiliser auth0.js

Dans cette section, nous utiliserons une simple application monopage et personnaliserons le gadget logiciel de connexion pour ajouter un drapeau que les utilisateurs pourront utiliser pour fournir des informations relatives au consentement. Au lieu de créer une application de zéro, nous allons [utiliser l’exemple Guide rapide JavaScript](/docs/fr-ca/quickstart/spa/vanillajs) d’Auth0. Nous utiliserons également les pages Connexion universelle Auth0 afin de pouvoir implémenter une expérience de connexion universelle au lieu d’intégrer la connexion dans notre application. Pour en savoir plus sur la connexion universelle, consultez [Connexion universelle Auth0](/docs/fr-ca/authenticate/login/auth0-universal-login). Pour en savoir plus sur les différences entre la connexion universelle et la connexion intégrée, consultez [Connexion universelle centralisée par rapport à la Connexion intégrée](/docs/fr-ca/authenticate/login/universal-vs-embedded-login).

Cela fonctionne **uniquement** pour les connexions de base de données (nous utiliserons l’infrastructure Auth0, au lieu de définir notre propre base de données).

1. Accédez à [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) et créez une nouvelle application. Choisissez le type `Applications Web à page unique`. Accédez à **Paramètres** et définissez les **URL de rappel autorisées** sur `http://localhost:3000`.

   Ce champ contient l’ensemble des URL vers lesquelles Auth0 est autorisé à rediriger les utilisateurs après leur authentification. Notre exemple d’application s’exécutera sur `http://localhost:3000` : c’est la raison pour laquelle nous définissons cette valeur.
2. Copiez les valeurs **ID client** et **Domaine**. Vous en aurez bientôt besoin.
3. Accédez à [Auth0 Dashboard > Authentication (Authentification) > Database (Base de données)](https://manage.auth0.com/#/connections/database) et créez à nouveau une connexion. Cliquez sur **Create DB Connection (Créer une connexion par base de données)**, choisissez un nom pour la nouvelle connexion, puis cliquez sur **Save (Enregistrer)**. Accédez à l’onglet **Applications** de la connexion et vérifiez que l’application que vous venez de créer est bien activée.
4. [Téléchargez l’exemple d’application JavaScript à page unique](/docs/fr-ca/quickstart/spa/vanillajs).
5. [Définissez les valeurs d’ID client et de domaine](https://github.com/auth0-samples/auth0-javascript-samples/tree/master/01-Login#set-the-client-id-and-domain).
6. Accédez à [Auth0 Dashboard > Branding (Image de marque) > Universal Login (Connexion universelle](https://manage.auth0.com/#/login_settings). Dans l’onglet**Login (Connexion)**, activez le bouton bascule.
7. Dans le menu déroulant  **Default Templates (Modèles par défaut)** assurez-vous que `Custom Login Form (Formulaire de connexion personnalisé)` est sélectionné Le code est prérempli pour vous.
8. Définissez la valeur de la variable `databaseConnection` sur le nom de la connexion de base de données utilisée par votre application.

   ```javascript lines
   //code reducted for simplicity
   	var databaseConnection = 'test-db';
   	//code reducted for simplicity
   ```

   

   
9. Pour ajouter un champ pour les métadonnées `consentGiven` , ajoutez une case à cocher dans le formulaire. Dans le cadre de notre exemple, nous configurerons la case à cocher comme étant cochée par défaut et désactivée afin que l’utilisateur ne puisse pas la décocher. Vous pouvez ajuster cela en fonction des besoins de votre entreprise.

   ```javascript lines
   //code reducted for simplicity
       <div class="form-group">
         <label for="name">I consent with data processing</label>
         <input
           type="checkbox"
           id="userConsent"
           checked disabled>
       </div>
       //code reducted for simplicity
   ```

   

   
10. Modifiez la fonction d’inscription pour définir les métadonnées. Notez que nous définissons la valeur des métadonnées sur une chaîne avec la valeur `true` et non sur une valeur booléenne, et que nous utilisons `toString` pour convertir le nombre en chaîne. Cela est dû à une restriction du point de terminaison[**Signup** endpoint d’Authentication API](/docs/fr-ca/api/authentication#signup) qui n’accepte que des chaînes comme valeurs.

    ```
    //code reducted for simplicity
        webAuth.redirect.signupAndLogin({
          connection: databaseConnection,
          email: email,
          password: password,
          user_metadata: { consentGiven: 'true', consentTimestamp: Date.now().toString() }
        }, function(err) {
          if (err) displayError(err);
        });
        //code reducted for simplicity
    ```

    

    
11. Pour voir à quoi ressemblera le gadget logiciel de connexion, cliquez sur l](/docs/images/Preview (Aperçu)** .

<Frame>![Dashboard Branding Universal Login Classic Login Tab Custom Login Form](/images/fr-ca/cdy7uua7fh8z/4m3WA0sKMoR0C1KVnVmZ1G/9eb874ba2619b71f57e7fff80f84cc01/2025-02-26_15-23-14.png)</Frame>

1. Pour tester cette configuration, exécutez l’application et allez à `http://localhost:3000`. Inscrivez-vous en tant que nouvel utilisateur. Ensuite, accédez à [Auth0 Dashboard > User Management (Gestion des utilisateurs) > Users (Utilisateurs)](https://manage.auth0.com/#/users), et recherchez votre nouvel utilisateur. Accédez à **User Details (Détails de l’utilisateur)** et faites défiler l’écran vers le bas jusqu’à la section **Metadata (Métadonnées)**. Dans la zone de texte **user_metadata** vous devez voir les métadonnées `consentGiven` définies sur `true`.

## Option 2 : Utiliser l’API (base de données)

Si vous servez votre page de connexion à partir de votre propre serveur, alors vous pouvez appeler directement le point de terminaison [**Signup**](/docs/fr-ca/api/authentication#signup) d’Authentication API une fois l’utilisateur inscrit.

En ce qui concerne le même scénario dont nous avons discuté jusqu’à présent, une fois que vous inscrivez un nouvel utilisateur, vous pouvez utiliser le fragment de code suivant pour créer l’utilisateur dans Auth0 et définir les métadonnées. N’oubliez pas de remplacer la valeur du paramètre de requête `consentTimestamp` par la date/heure à laquelle l’utilisateur a donné son consentement.

<AuthCodeGroup>
```bash cURL
curl --request POST \
  --url 'https://{yourDomain}/dbconnections/signup' \
  --header 'content-type: application/json' \
  --data '{"client_id": "{yourClientId}","email": "YOUR_USER_EMAIL","password": "YOUR_USER_PASSWORD","user_metadata": {"consentGiven": "true", "consentTimestamp": "1525101183" }}'
```
```csharp C#
var client = new RestClient("https://{yourDomain}/dbconnections/signup");
var request = new RestRequest(Method.POST);
request.AddHeader("content-type", "application/json");
request.AddParameter("application/json", "{"client_id": "{yourClientId}","email": "YOUR_USER_EMAIL","password": "YOUR_USER_PASSWORD","user_metadata": {"consentGiven": "true", "consentTimestamp": "1525101183" }}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```
```go Go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/dbconnections/signup"

	payload := strings.NewReader("{"client_id": "{yourClientId}","email": "YOUR_USER_EMAIL","password": "YOUR_USER_PASSWORD","user_metadata": {"consentGiven": "true", "consentTimestamp": "1525101183" }}")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("content-type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java
HttpResponse response = Unirest.post("https://{yourDomain}/dbconnections/signup")
  .header("content-type", "application/json")
  .body("{"client_id": "{yourClientId}","email": "YOUR_USER_EMAIL","password": "YOUR_USER_PASSWORD","user_metadata": {"consentGiven": "true", "consentTimestamp": "1525101183" }}")
  .asString();
```
```javascript Node.JS
var axios = require("axios").default;

var options = {
  method: 'POST',
  url: 'https://{yourDomain}/dbconnections/signup',
  headers: {'content-type': 'application/json'},
  data: {
    client_id: '{yourClientId}',
    email: 'YOUR_USER_EMAIL',
    password: 'YOUR_USER_PASSWORD',
    user_metadata: {consentGiven: 'true', consentTimestamp: '1525101183'}
  }
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```objc Obj-C
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"content-type": @"application/json" };
NSDictionary *parameters = @{ @"client_id": @"{yourClientId}",
                              @"email": @"YOUR_USER_EMAIL",
                              @"password": @"YOUR_USER_PASSWORD",
                              @"user_metadata": @{ @"consentGiven": @"true", @"consentTimestamp": @"1525101183" } };

NSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/dbconnections/signup"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"POST"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```
```php PHP
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/dbconnections/signup",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "POST",
  CURLOPT_POSTFIELDS => "{"client_id": "{yourClientId}","email": "YOUR_USER_EMAIL","password": "YOUR_USER_PASSWORD","user_metadata": {"consentGiven": "true", "consentTimestamp": "1525101183" }}",
  CURLOPT_HTTPHEADER => [
    "content-type: application/json"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python
import http.client

conn = http.client.HTTPSConnection("")

payload = "{"client_id": "{yourClientId}","email": "YOUR_USER_EMAIL","password": "YOUR_USER_PASSWORD","user_metadata": {"consentGiven": "true", "consentTimestamp": "1525101183" }}"

headers = { 'content-type': "application/json" }

conn.request("POST", "/{yourDomain}/dbconnections/signup", payload, headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```
```ruby Ruby
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/dbconnections/signup")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Post.new(url)
request["content-type"] = 'application/json'
request.body = "{"client_id": "{yourClientId}","email": "YOUR_USER_EMAIL","password": "YOUR_USER_PASSWORD","user_metadata": {"consentGiven": "true", "consentTimestamp": "1525101183" }}"

response = http.request(request)
puts response.read_body
```
```swift Swift
import Foundation

let headers = ["content-type": "application/json"]
let parameters = [
  "client_id": "{yourClientId}",
  "email": "YOUR_USER_EMAIL",
  "password": "YOUR_USER_PASSWORD",
  "user_metadata": [
    "consentGiven": "true",
    "consentTimestamp": "1525101183"
  ]
] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/dbconnections/signup")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</AuthCodeGroup>

Notez que nous définissons la valeur des métadonnées sur une chaîne avec la valeur `true` et non sur une valeur booléenne en raison de la restriction d’API qui admet les chaînes comme valeurs et pas les booléens.

Si la définition de valeurs booléennes est une exigence pour vous, vous pouvez plutôt utiliser <Tooltip href="/docs/fr-ca/glossary?term=management-api" tip="Management API
Un produit permettant aux clients d’effectuer des tâches administratives." cta="Voir le glossaire">Management API</Tooltip>. Dans ce scénario, vous inscrivez votre utilisateur comme d’habitude puis vous appelez le point de terminaison [**Update User (Mettre à jour l’utilisateur)**](/docs/fr-ca/api/management/v2#!/Users/patch_users_by_id) de Management API pour définir les métadonnées requises après création de l’utilisateur. Pour plus d’informations sur la façon de procéder, lisez le paragraphe suivant.

## Option 3 : Utiliser l’API (social)

Si vous utilisez des connexions sociales, alors vous ne pouvez pas utiliser Authentication API pour créer l’utilisateur sur Auth0, vu que ce point de terminaison ne fonctionne que pour les connexions de base de données.

Ce que vous devez plutôt faire, c’est permettre à votre utilisateur de s’inscrire auprès du fournisseur social (ce qui créera un enregistrement d’utilisateur dans Auth0), puis utiliser Management API pour mettre à jour les informations de l’utilisateur.

Avant d’appeler Management API, vous devez disposer d’un jeton d’accès. Pour en savoir plus, lisez [Obtenir des jetons d’accès à Management API pour la production](/docs/fr-ca/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-access-tokens-for-production).

L’article cité utilise le Flux des identifiants client pour obtenir un jeton, que vous ne pouvez pas utiliser à partir d’une application fonctionnant sur le navigateur. Le flux Implicite est recommandé. Pour en savoir plus sur le Flux des identifiants client, consultez [Flux des identifiants client](/docs/fr-ca/get-started/authentication-and-authorization-flow/client-credentials-flow). Pour en savoir plus sur le flux Implicite, lisez [Flux implicite](/docs/fr-ca/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post).

Définissez le paramètre de requête **<Tooltip data-tooltip-id="react-containers-DefinitionTooltip-1" tip="">audience</Tooltip>** sur `https://YOUR_DOMAIN/api/v2/` et le paramètre **scope** sur la permission `create:current_user_metadata`. Vous pouvez utiliser le jeton d’accès que vous recevrez dans la réponse pour appeler le point de terminaison [**Mettre à jour l’utilisateur**](/docs/fr-ca/api/management/v2#!/Users/patch_users_by_id) de Management API.

Une fois que vous disposez d’un jeton valide, utilisez le fragment de code suivant pour mettre à jour les métadonnées de l’utilisateur.

<AuthCodeGroup>
```bash cURL
curl --request POST \
  --url 'https://{yourDomain}/api/v2/users/%7BUSER_ID%7D' \
  --header 'authorization: Bearer YOUR_ACCESS_TOKEN' \
  --header 'content-type: application/json' \
  --data '{"user_metadata": {"consentGiven":true, "consentTimestamp": "1525101183"}}'
```
```csharp C#
var client = new RestClient("https://{yourDomain}/api/v2/users/%7BUSER_ID%7D");
var request = new RestRequest(Method.POST);
request.AddHeader("authorization", "Bearer YOUR_ACCESS_TOKEN");
request.AddHeader("content-type", "application/json");
request.AddParameter("application/json", "{"user_metadata": {"consentGiven":true, "consentTimestamp": "1525101183"}}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```
```go Go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/api/v2/users/%7BUSER_ID%7D"

	payload := strings.NewReader("{"user_metadata": {"consentGiven":true, "consentTimestamp": "1525101183"}}")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("authorization", "Bearer YOUR_ACCESS_TOKEN")
	req.Header.Add("content-type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java
HttpResponse response = Unirest.post("https://{yourDomain}/api/v2/users/%7BUSER_ID%7D")
  .header("authorization", "Bearer YOUR_ACCESS_TOKEN")
  .header("content-type", "application/json")
  .body("{"user_metadata": {"consentGiven":true, "consentTimestamp": "1525101183"}}")
  .asString();
```
```javascript Node.JS
var axios = require("axios").default;

var options = {
  method: 'POST',
  url: 'https://{yourDomain}/api/v2/users/%7BUSER_ID%7D',
  headers: {authorization: 'Bearer YOUR_ACCESS_TOKEN', 'content-type': 'application/json'},
  data: {user_metadata: {consentGiven: true, consentTimestamp: '1525101183'}}
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```objc Obj-C
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"authorization": @"Bearer YOUR_ACCESS_TOKEN",
                           @"content-type": @"application/json" };
NSDictionary *parameters = @{ @"user_metadata": @{ @"consentGiven": @YES, @"consentTimestamp": @"1525101183" } };

NSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/users/%7BUSER_ID%7D"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"POST"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```
```php PHP
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/api/v2/users/%7BUSER_ID%7D",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "POST",
  CURLOPT_POSTFIELDS => "{"user_metadata": {"consentGiven":true, "consentTimestamp": "1525101183"}}",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer YOUR_ACCESS_TOKEN",
    "content-type: application/json"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python
import http.client

conn = http.client.HTTPSConnection("")

payload = "{"user_metadata": {"consentGiven":true, "consentTimestamp": "1525101183"}}"

headers = {
    'authorization': "Bearer YOUR_ACCESS_TOKEN",
    'content-type': "application/json"
    }

conn.request("POST", "/{yourDomain}/api/v2/users/%7BUSER_ID%7D", payload, headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```
```ruby Ruby
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/api/v2/users/%7BUSER_ID%7D")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Post.new(url)
request["authorization"] = 'Bearer YOUR_ACCESS_TOKEN'
request["content-type"] = 'application/json'
request.body = "{"user_metadata": {"consentGiven":true, "consentTimestamp": "1525101183"}}"

response = http.request(request)
puts response.read_body
```
```swift Swift
import Foundation

let headers = [
  "authorization": "Bearer YOUR_ACCESS_TOKEN",
  "content-type": "application/json"
]
let parameters = ["user_metadata": [
    "consentGiven": true,
    "consentTimestamp": "1525101183"
  ]] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/users/%7BUSER_ID%7D")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</AuthCodeGroup>

Notez que pour effectuer cet appel, vous devez connaître l’`user_id` unique. Vous pouvez le récupérer à partir de la demande `sub` du jeton d’ID, si vous en avez reçue une dans la réponse. Pour en savoir plus, lisez [Jetons d’ID](/docs/fr-ca/secure/tokens/id-tokens). Si vous ne disposez que de l’adresse courriel, vous pouvez récupérer l’ID en appelant un autre point de terminaison de Management API. Pour en savoir plus, lisez [Meilleures pratiques de recherche d’utilisateurs](/docs/fr-ca/manage-users/user-search/user-search-best-practices).

## Option 4 : Rediriger vers une autre page

Si vous souhaitez afficher plus d’informations à votre utilisateur, vous pouvez le rediriger vers une autre page lors de l’inscription, où vous demanderez son consentement et toute information supplémentaire, puis le rediriger à nouveau pour finaliser le processus d’authentification. Cela peut être fait avec des règles de redirection. Cette même règle peut être utilisée pour enregistrer les informations de consentement dans les métadonnées de l’utilisateur, afin que vous puissiez suivre ces informations et ne pas demander de consentement lors de la prochaine connexion. Pour en savoir plus, veuillez consulter l’article [Rediriger les utilisateurs à partir des règles](/docs/fr-ca/customize/rules/redirect-users).

Vous devrez héberger ce formulaire, et l’URL de ce formulaire devra être accessible publiquement. Vous allez devoir fournir l’URL où le formulaire peut être accessible à Auth0 à une étape ultérieure de ce tutoriel.

1. Ajoutez la règle de redirection. Accédez à [Auth0 Dashboard > Auth Pipeline (Pipeline Auth) > Rules (Règles)](https://manage.auth0.com/#/rules), et cliquez sur **Create Rule (Créer une règle)**. Dans **Rules Templates (Modèles de règles)**, sélectionnez **empty rule (règle vide)**. Changez le nom de la règle par défaut de `règle vide` à quelque chose de descriptif (par exemple, `Rediriger vers le formulaire de consentement`.
2. Ajoutez le code JavaScript suivant dans l’éditeur de scripts, puis sélectionnez **Save (Enregistrer)** vos modifications.

   ``` lines
   exports.onExecutePostLogin = async (event, api) => {
       const { consentGiven } = event.user.user_metadata || {};

       // redirect to consent form if user has not yet consented
       if (!consentGiven && api.redirect.canRedirect()) {
         const options = {
           query: {
             auth0_domain: `${event.tenant.id}.auth0.com`,
           },
         };
         api.redirect.sendUserTo(event.secrets.CONSENT_FORM_URL, options);
       }
   };

   // if user clicks 'I agree' on the consent form, save it to their profile so they don't get prompted again
   exports.onContinuePostLogin = async (event, api) => {
     if (event.request.body.confirm === "yes") {
       api.user.setUserMetadata("consentGiven", true);
       api.user.setUserMetadata("consentTimestamp", Date.now());
       return;
     } else {
       return api.access.deny("User did not consent");
     }
   };
   ```

   

   
3. Revenez à [Auth0 Dashboard > Auth0 Pipeline > Rules (Règles)](https://manage.auth0.com/#/rules) et faites défiler vers le bas de la page jusqu’à la section **Settings (Paramètres)**. Créez une paire clé/valeur comme suit :

   1. **Clé** : `CONSENT_FORM_URL`
   2. **Valeur** : `your-consent-form-url.com`

Veillez à fournir l’URL de votre formulaire de consentement accessible publiquement.

Lorsque vous définissez la redirection vers votre formulaire de consentement pour une utilisation en environnement de production, n’oubliez pas de consulter [URL de rappel de confiance](https://github.com/auth0/rules/tree/master/redirect-rules/simple#trusted-callback-urls) et [Intégrité des données](https://github.com/auth0/rules/tree/master/redirect-rules/simple#data-integrity) portant sur les questions de sécurité.

Si vous avez besoin d’une invite de consentement spécialisée, par exemple, le consentement parental, vous devez créer votre propre formulaire de consentement personnalisé. Sachez que les lois varient selon les pays.

Nous avons terminé la partie portant sur la configuration, passons au test!

## Tester la configuration

1. Exécutez l’application et allez à `https://localhost:3000`.
2. Inscrivez-vous en tant que nouvel utilisateur. Vous serez redirigé vers le formulaire de consentement.
3. Cochez l’option **I agree (J’accepte)** et cliquez sur **Submit (Soumettre)**.
4. Allez à [Auth0 Dashboard > User Management (Gestion des utilisateurs) > Users (Utilisateurs)](https://manage.auth0.com/#/users), et recherchez votre nouvel utilisateur.
5. Allez à **User Details (Détails de l’utilisateur)** et faites défiler l’écran vers le bas jusqu’à la section **Metadata (Métadonnées)**.
6. Dans la zone de texte **user_metadata**, vous devez voir les métadonnées `consentGiven`  définies sur `true` et `consentTimestamp` définies sur l’horodatage Unix du moment où l’utilisateur a consenti.

Vous avez terminé!