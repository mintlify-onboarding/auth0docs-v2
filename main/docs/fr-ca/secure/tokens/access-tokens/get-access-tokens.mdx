---
title: "Obtenir des jetons d’accès"
permalink: "get-access-tokens"
'description': "Découvrez comment demander des jetons d’accès à l’aide du point de terminaison Authorize lors de l’authentification des utilisateurs et incluez l'audience cible et la permission de l’accès demandés par l’application et accordés par l’utilisateur."
'og:title': "Obtenir des jetons d’accès"
'og:description': "Découvrez comment demander des jetons d’accès à l’aide du point de terminaison Authorize lors de l’authentification des utilisateurs et incluez l'audience cible et la permission de l’accès demandés par l’application et accordés par l’utilisateur."
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "Obtenir des jetons d’accès"
'twitter:description': "Découvrez comment demander des jetons d’accès à l’aide du point de terminaison Authorize lors de l’authentification des utilisateurs et incluez l'audience cible et la permission de l’accès demandés par l’application et accordés par l’utilisateur."
---
import {AuthCodeBlock} from "/snippets/AuthCodeBlock.jsx";

import {AuthCodeGroup} from "/snippets/AuthCodeGroup.jsx";

Pour accéder à votre API, vous devez demander un [jeton d’accès](/docs/fr-ca/secure/tokens/access-tokens) lors de l’authentification d’un utilisateur.

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Ces outils Auth0 vous aident à modifier votre application pour qu’elle authentifie des utilisateurs :

* Les [Quickstarts (Guides de démarrage rapide)](/docs/fr-ca/quickstarts) constituent la façon la plus facile d’implémenter l’authentification. Ils vous expliquent comment utiliser [Universal Login (Connexion universelle)](/docs/fr-ca/authenticate/login/auth0-universal-login/universal-login-vs-classic-login) et le language Auth0, ainsi que les trousses SDK spécifiques au cadre d’applications.
* [API d’authentification Auth0](/docs/fr-ca/api/authentication) est une référence pour ceux qui préfèrent écrire du code séparément. Tout d’abord, déterminez [le flux à utiliser](/docs/fr-ca/get-started/authentication-and-authorization-flow/which-oauth-2-0-flow-should-i-use). Ensuite, suivez les instructions d’implémentation de ce flux.

</Callout>

Pour demander un jeton d’accès, effectuez une requête POST au jeton [URL](/docs/fr-ca/api/authentication#client-credentials-flow).

#### Exemple de requête POST au jeton URL

<AuthCodeGroup>
```bash cURL
curl --request POST \
  --url 'https://{yourDomain}/oauth/token' \
  --header 'content-type: application/x-www-form-urlencoded' \
  --data grant_type=client_credentials \
  --data client_id={yourClientId} \
  --data client_secret={yourClientSecret} \
  --data audience=YOUR_API_IDENTIFIER
```
```csharp C#
var client = new RestClient("https://{yourDomain}/oauth/token");
var request = new RestRequest(Method.POST);
request.AddHeader("content-type", "application/x-www-form-urlencoded");
request.AddParameter("application/x-www-form-urlencoded", "grant_type=client_credentials&client_id={yourClientId}&client_secret={yourClientSecret}&audience=YOUR_API_IDENTIFIER", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```
```go Go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/oauth/token"

	payload := strings.NewReader("grant_type=client_credentials&client_id={yourClientId}&client_secret={yourClientSecret}&audience=YOUR_API_IDENTIFIER")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("content-type", "application/x-www-form-urlencoded")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java
HttpResponse<String> response = Unirest.post("https://{yourDomain}/oauth/token")
  .header("content-type", "application/x-www-form-urlencoded")
  .body("grant_type=client_credentials&client_id={yourClientId}&client_secret={yourClientSecret}&audience=YOUR_API_IDENTIFIER")
  .asString();
```
```javascript Node.JS
var axios = require("axios").default;

var options = {
  method: 'POST',
  url: 'https://{yourDomain}/oauth/token',
  headers: {'content-type': 'application/x-www-form-urlencoded'},
  data: new URLSearchParams({
    grant_type: 'client_credentials',
    client_id: '{yourClientId}',
    client_secret: '{yourClientSecret}',
    audience: 'YOUR_API_IDENTIFIER'
  })
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```objc Obj-C
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"content-type": @"application/x-www-form-urlencoded" };

NSMutableData *postData = [[NSMutableData alloc] initWithData:[@"grant_type=client_credentials" dataUsingEncoding:NSUTF8StringEncoding]];
[postData appendData:[@"&client_id={yourClientId}" dataUsingEncoding:NSUTF8StringEncoding]];
[postData appendData:[@"&client_secret={yourClientSecret}" dataUsingEncoding:NSUTF8StringEncoding]];
[postData appendData:[@"&audience=YOUR_API_IDENTIFIER" dataUsingEncoding:NSUTF8StringEncoding]];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/oauth/token"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"POST"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```
```php PHP
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/oauth/token",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "POST",
  CURLOPT_POSTFIELDS => "grant_type=client_credentials&client_id={yourClientId}&client_secret={yourClientSecret}&audience=YOUR_API_IDENTIFIER",
  CURLOPT_HTTPHEADER => [
    "content-type: application/x-www-form-urlencoded"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python
import http.client

conn = http.client.HTTPSConnection("")

payload = "grant_type=client_credentials&client_id={yourClientId}&client_secret={yourClientSecret}&audience=YOUR_API_IDENTIFIER"

headers = { 'content-type': "application/x-www-form-urlencoded" }

conn.request("POST", "/{yourDomain}/oauth/token", payload, headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```
```ruby Ruby
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/oauth/token")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Post.new(url)
request["content-type"] = 'application/x-www-form-urlencoded'
request.body = "grant_type=client_credentials&client_id={yourClientId}&client_secret={yourClientSecret}&audience=YOUR_API_IDENTIFIER"

response = http.request(request)
puts response.read_body
```
```swift Swift
import Foundation

let headers = ["content-type": "application/x-www-form-urlencoded"]

let postData = NSMutableData(data: "grant_type=client_credentials".data(using: String.Encoding.utf8)!)
postData.append("&client_id={yourClientId}".data(using: String.Encoding.utf8)!)
postData.append("&client_secret={yourClientSecret}".data(using: String.Encoding.utf8)!)
postData.append("&audience=YOUR_API_IDENTIFIER".data(using: String.Encoding.utf8)!)

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/oauth/token")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</AuthCodeGroup>

##### Paramètres

<table class="table"><thead>
<tr>
<th>Nom du paramètre</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>`grant_type`</td>
<td>Définissez sur « client_credentials ».</td>
</tr>
<tr>
<td>`client_id`</td>
<td>L’ID client de votre application. Vous pouvez trouver cette valeur dans <a href="https://manage.auth0.com/#/applications">l’onglet des paramètres de l’application</a>.</td>
</tr>
<tr>
<td>`client_secret`</td>
<td>Le secret client de votre application. Vous pouvez trouver cette valeur dans <a href="https://manage.auth0.com/#/applications">l’onglet des paramètres de l’application</a>.  Pour en savoir plus sur les méthodes d’authentification des applications disponibles, veuillez consulter <a href="/docs/fr-ca/secure/application-credentials">Informations d’identification de l’application </a>.</td>
</tr>
<tr>
<td>`audience`</td>
<td>L’audience du jeton, qui est votre API. Vous pouvez le trouver dans le champ <strong>Identifier</strong> de votre <a href="https://manage.auth0.com/#/apis">onglet Paramètres de l’API</a>.</td>
</tr>
<tr>
<td>`organization`</td>
<td>Facultatif. Le nom de l’organisation ou l’identifiant auquel vous souhaitez que la demande soit associée. Pour en savoir plus, lisez <a href="/docs/fr-ca/manage-users/organizations/organizations-for-m2m-applications">Accès de communication entre machines pour les Organizations</a>.</td>
</tr>
</tbody>
</table>

#### Response (Réponse)

Vous recevrez une réponse `HTTP 200` avec une charge utile contenant les valeurs `access_token`, `token_type` et `expires_in` :

```json lines
{
  "access_token":"eyJz93a...k4laUWw",
  "token_type":"Bearer",
  "expires_in":86400
}
```

<Warning>

Validez vos jetons avant de les enregistrer. Pour en savoir plus, lisez [Valider les jetons d’ID](/docs/fr-ca/secure/tokens/id-tokens/validate-id-tokens) et [Valider les jetons d’accès](/docs/fr-ca/secure/tokens/access-tokens/validate-access-tokens).

</Warning>

## Contrôler l'audiance du jeton d’accès

Lorsqu’un utilisateur s’authentifie, vous demandez un jeton d’accès et incluez l'<Tooltip data-tooltip-id="react-containers-DefinitionTooltip-0" tip="">audience</Tooltip> cible et la permission de l’accès dans votre demande. L’application utilise le point de terminaison `/authorize` pour demander l’accès. Cet accès est à la fois demandé par l’application et accordé par l’utilisateur lors de l’authentification.

Vous pouvez configurer votre locataire pour qu’il inclue toujours une audience par défaut.

<table class="table"><thead>
<tr>
<th>Utilisation des jetons</th>
<th>Format</th>
<th>Public demandé</th>
<th>Permission demandée</th>
</tr>
</thead>
<tbody>
<tr>
<td>Point de terminaison `/userinfo`</td>
<td>Opaque</td>
<td>Opaque</td>
<td>nom du locataire (`{yourDomain}`), aucune valeur pour le paramètre `audience`, aucun paramètre `audience` transmis</td>
</tr>
<tr>
<td>Auth0 Management API</td>
<td>JWT</td>
<td>Identifiant de l’Auth0 Management API v2 (`https://{tenant}.auth0.com/api/v2/`)</td>
<td></td>
</tr>
</tbody>
</table>

Dans une seule instance particulière, les jetons d’accès peuvent avoir plusieurs audiences cibles. Cela nécessite que l’algorithme de signature de votre API personnalisée soit défini sur **RS256**. Pour en savoir plus, consultez [Meilleures pratiques en matière de jetons](/docs/fr-ca/secure/tokens/token-best-practices).

### Audiences multiples

Si vous spécifiez une audience pour l’identifiant de votre API personnalisé et une permission `openid`, la demande `aud` du jeton d’accès résultant sera un tableau plutôt qu’une chaîne, et le jeton d’accès sera valide à la fois pour votre API personnalisée et pour le point de terminaison`/userinfo`. Vos jetons d’accès ne peuvent avoir deux audiences ou plus que si vous utilisez une seule API personnalisée ainsi que le point de terminaison `/userinfo` lié à Auth0.

### Domaines personnalisés et Management API Auth0

Auth0 émet des jetons avec une demande de l’émetteur (`iss)` du domaine que vous avez utilisé lors de la demande du jeton. [Les utilisateurs de domaines personnalisés](/docs/fr-ca/customize/custom-domains) peuvent utiliser leur domaine personnalisé ou leur domaine Auth0.

Par exemple, supposons que vous ayez un domaine personnalisé, `https://login.northwind.com`. Si vous demandez un jeton d’accès à partir de `https://login.northwind.com/authorize`, la demande `iss` de votre jeton sera `https://login.northwind.com/`. Cependant, si vous demandez un jeton d’accès à partir de `https://northwind.auth0.com/authorize`, la demande `iss` de votre jeton sera `https://northwind.auth0.com/`.

Si vous demandez un jeton d’accès à partir de votre domaine personnalisé avec l'audience cible de <Tooltip href="/docs/fr-ca/glossary?term=management-api" tip="Management API
Un produit permettant aux clients d’effectuer des tâches administratives." cta="Voir le glossaire">Management API</Tooltip> Auth0, vous **devez** appeler Management API Auth0 à partir de votre domaine personnalisé. Sinon, votre jeton d’accès est considéré comme invalide.

## Renouveler des jetons d’accès

Par défaut, un jeton d’accès pour une API personnalisée est valide pendant 86 400 secondes (24 heures). Vous pouvez [raccourcir la période de validité avant l’expiration du jeton](/docs/fr-ca/secure/tokens/access-tokens/update-access-token-lifetime).

Il est possible de renouveler un jeton d’accès qui a expiré. Pour ce faire, réauthentifiez l’utilisateur à l’aide d’Auth0 ou utilisez un [jeton d’actualisation](/docs/fr-ca/secure/tokens/refresh-tokens).

## En savoir plus

* [Valider les jetons d’accès](/docs/fr-ca/secure/tokens/access-tokens/validate-access-tokens)
* [Utiliser des jetons d'accès](/docs/fr-ca/secure/tokens/access-tokens/use-access-tokens)
* [Jetons Web JSON](/docs/fr-ca/secure/tokens/json-web-tokens)
* [Jetons d’actualisation](/docs/fr-ca/secure/tokens/refresh-tokens)
* [Jetons d’accès de fournisseur d’identité](/docs/fr-ca/secure/tokens/access-tokens/identity-provider-access-tokens)
* [Jetons d’accès à Management API](/docs/fr-ca/secure/tokens/access-tokens/management-api-access-tokens)