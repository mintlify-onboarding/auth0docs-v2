---
description: Learn how to authenticate users with the Client-Initiated Backchannel
  Authentication Flow using email notifications.
'og:image': https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
'og:title': Email Notifications with CIBA
'og:url': https://auth0.com/docs/
permalink: email-notifications-with-ciba
title: Email Notifications with CIBA
'twitter:description': Learn how to authenticate users with the Client-Initiated Backchannel
  Authentication Flow using email notifications.
'twitter:title': Email Notifications with CIBA
---

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">
To use Client-Initiated Backchannel Authentication (CIBA) features, you must have an Enterprise Plan or an appropriate add-on. Refer to [Auth0 Pricing](https://auth0.com/pricing/) for details.
</Callout>

When you use email notifications with CIBA, the user receives an email with a link that redirects them to authenticate or authorize a request in the browser.

When using email notifications with CIBA, the user logs in on the consumption device but completes authentication by clicking a link sent to their verified email address. When the user clicks the verification link, they are redirected to their browser, creating a session that Auth0 uses to track the authentication process and confirm the user's identity. This session is necessary to bridge the gap between the authentication device, in this case, the browser, and the consumption device, such as a Smart TV.

The following diagram explains the end-to-end CIBA with email notifications flow:

<Frame>![](/docs/images/ciba/email_notifications_with_ciba_diagram.png)</Frame>

The following sections dive step-by-step into how user authentication works with CIBA using email notifications.

* [Prerequisites](#prerequisites)
* [Step 1: Client application initiates a CIBA request](#step-1%3A-client-application-initiates-a-ciba-request)
* [Step 2: Auth0 tenant acknowledges the CIBA request](#step-2%3A-auth0-tenant-acknowledges-the-ciba-request)
* [Step 3: Client application polls for a response](#step-3%3A-client-application-polls-for-a-response)
* [Step 4: Auth0 sends a link to the user's email address](#step-4%3A-auth0-sends-a-link-to-the-user’s-email-address)
* [Step 5: User authenticates in the browser](#step-5%3A-user-authenticates-in-the-browser)
* [Step 6: Browser presents consent details to the user](#step-6%3A-browser-sends-the-user-response-back-to-auth0)
* [Step 7: Auth0 receives user response after the flow completes](#step-7%3A-auth0-receives-user-response-after-the-flow-completes)
* [Step 8: Auth0 returns access token to client application](#step-8%3A-auth0-returns-access-token-to-client-application)

## Prerequisites

To initiate a CIBA email request using Auth0, you must:

* [Configure Client-Initiated Backchannel Authentication](/docs/get-started/applications/configure-client-initiated-backchannel-authentication) for your tenant and application, including [email notifications](/docs/get-started/applications/configure-client-initiated-backchannel-authentication/#configure-email-notifications). 
* Set the `requested_expiry` parameter to a value between 301 to 259200 seconds (72 hours). To learn more, read [Configure notification channel](/docs/get-started/applications/configure-client-initiated-backchannel-authentication#configure-notification-channel). 
* If using email notifications with CIBA and Rich Authorization Requests (RAR) for [user authorization](/docs/get-started/authentication-and-authorization-flow/client-initiated-backchannel-authentication-flow/user-authorization-with-ciba), [set the customized consent prompt](/docs/get-started/apis/configure-rich-authorization-requests#set-customized-consent-prompt).

## Step 1: Client application initiates a CIBA request

Use the [User Search APIs](/docs/manage-users/user-search) to find the authorizing user for whom you’d like to initiate a CIBA request and obtain their user ID.

Once you have a user ID for the authorizing user, use the Authentication API or our [SDKs](/docs/libraries) to send a CIBA request to the `/bc-authorize` endpoint:

<Tabs><Tab title="cURL">

```bash lines
curl --location 'https://{yourDomain}.auth0.com/bc-authorize' \
  --header 'Content-Type: application/x-www-form-urlencoded' \
  --data-urlencode 'client_id=<CLIENT_ID>' \
  --data-urlencode 'client_secret=<CLIENT_SECRET>' \
  --data-urlencode 'login_hint={ "format": "iss_sub", "iss": "https://{yourDomain}.auth0.com/", "sub": "<USER_ID>" }' \
  --data-urlencode 'scope=<SCOPES>' \
  --data-urlencode 'binding_message=<BINDING_MESSAGE>'
```

</Tab><Tab title="C#">

```csharp lines
var response = await authenticationApiClient.ClientInitiatedBackchannelAuthorization(
            new ClientInitiatedBackchannelAuthorizationRequest()
            {
                ClientId = "<CLIENT_ID>",
                Scope = "<SCOPES>",
                ClientSecret = "<CLIENT_SECRET>",
                BindingMessage = "<BINDING_MESSAGE>",
                LoginHint = new LoginHint()
                {
                    Format = "iss_sub",
                    Issuer = "https://{yourDomain}.auth0.com/",
                    Subject = "<USER_ID>"
                }
            }
        );
```

</Tab><Tab title="Go">

```go lines
resp, err := authAPI.CIBA.Initiate(context.Background(), ciba.Request{
    ClientID:     mgmtClientID,
    ClientSecret: mgmtClientSecret,
    Scope:        "openid",
    LoginHint: map[string]string{
      "format": "iss_sub",
      "iss":    "https://{yourDomain}.auth0.com/",
      "sub":    "<USER_ID>",
    },
    BindingMessage: "<BINDING_MESSAGE>",
  })
```

</Tab><Tab title="Java">

```java lines
//Creating AuthClient Instance
AuthAPI auth = AuthAPI.newBuilder(domain, clientId, clientSecret).build();

//Authorize
Map<String, Object> loginHint = new HashMap<>();
        loginHint.put("format", "iss_sub");
        loginHint.put("iss", "https://{yourDomain}.auth0.com/");
        loginHint.put("sub", "<USER_ID>");

Request<BackChannelAuthorizeResponse> request = auth.authorizeBackChannel("openid", "<BINDING_MESSAGE>", loginHint);

BackChannelAuthorizeResponse resp = request.execute().getBody();
```

</Tab></Tabs>

<table class="table"><thead>
<tr>
<th><strong>Parameters</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>tenant</code></td>
<td>Tenant name. It can also be a custom domain. If the `iss_sub` format is used, then the tenant name is passed within the `iss` claim.</td>
</tr>
<tr>
<td><code>client_id</code></td>
<td>Client application identifier.</td>
</tr>
<tr>
<td><code>client_secret</code></td>
<td>Client authentication method used for user authentication with CIBA, such as Client Secret, Private Key JWT, or mTLS Authentication. If you're using Private Key JWT or mTLS, you don't need to include the client secret.</td>
</tr>
<tr>
<td><code>scope</code></td>
<td>Must include <code>openid</code>.<br/><br/>The scope can optionally include <code>offline_access</code> to request a refresh token. However, for one-time authorization of a transaction with the CIBA Flow, a refresh token is not needed and does not have any meaning in this context.<br/></td>
</tr>
<tr>
<td><code>user_id</code></td>
<td>User ID for the authorizing user that is passed within the <code>login_hint</code> structure. If <code>iss_sub</code> format is used, then the user ID is passed within the <code>sub</code> claim.<br/><br/>The user ID may have a different format depending on the external provider.<br/></td>
</tr>
<tr>
<td><code>requested_expiry</code></td>
<td>The maximum duration, in seconds, for which the CIBA session should be valid. The CIBA flow's requested expiry is between 1 and  259200 seconds (72 hours), and it defaults to 300 seconds. Include the <code>requested_expiry</code> parameter to set a custom expiry for the CIBA flow.<br/><br/>The <code>requested_expiry</code> parameter helps determine which notification channel CIBA uses:<ul><li>If you set your <code>requested_expiry</code> to a value of 300 or lower in seconds, CIBA uses the mobile push notification channel if enabled. If you have not configured MFA for your tenant, the CIBA request fails.</li><li>If you set your <code>requested_expiry</code> to a value between 301 to 259200 seconds (72 hours), CIBA uses the email notification channel if enabled.</li></ul></td>
</tr>
<tr>
<td><code>binding_message</code></td>
<td>Human-readable message used to bind the CIBA flow across the authentication and consumption devices. The binding message is required and up to 64 characters. Use only alphanumeric and <code>+-_.,:#</code> characters.</td>
</tr>
</tbody>
</table>

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

There is a user-specific rate limit where the authorizing user will not be sent more than 5 requests per minute.

</Callout>

## Step 2: Auth0 tenant acknowledges the CIBA request

If the Auth0 tenant successfully receives the `POST` request, you should receive a response containing an `auth-req-id` that references the request:

```json lines
{
    "auth_req_id": "eyJh...",
    "expires_in": 300,
    "interval": 5
}
```

The `auth_req_id` value is passed to the `/token` endpoint to poll for the completion of the CIBA flow.

## Step 3: Client application polls for a response

Use the Authentication API or our [SDKs](/docs/libraries) to call the `/token` endpoint using the `urn:openid:params:grant-type:ciba` grant type and the `auth_req_id` you received from the `/bc-authorize` endpoint:

<Tabs><Tab title="cURL">

```bash lines
curl --location 'https://{yourDomain}.auth0.com/oauth/token' \
  --header 'Content-Type: application/x-www-form-urlencoded' \
  --data-urlencode 'client_id=<CLIEND_ID>' \
  --data-urlencode 'client_secret=<CLIENT_SECRET>' \
  --data-urlencode 'auth_req_id=<AUTH_REQ_ID>' \
  --data-urlencode 'grant_type=urn:openid:params:grant-type:ciba'
```

</Tab><Tab title="C#">

```csharp lines
var token = await authenticationApiClient.GetTokenAsync(
            new ClientInitiatedBackchannelAuthorizationTokenRequest()
            {
                AuthRequestId = response.AuthRequestId,
                ClientId = "<CLIENT_ID>",
                ClientSecret = "<CLIENT_SECRET>"
            }
        );
```

</Tab><Tab title="Go">

```go lines
token, err := authAPI.OAuth.LoginWithGrant(context.Background(),
      "urn:openid:params:grant-type:ciba",
      url.Values{
        "auth_req_id":   []string{resp.AuthReqID},
        "client_id":     []string{clientID},
        "client_secret": []string{clientSecret},
      },
      oauth.IDTokenValidationOptions{})
```

</Tab><Tab title="Java">

```java lines
Request<BackChannelTokenResponse> tokenRequest = auth.getBackChannelLoginStatus(authReqId, "grant-type");

BackChannelTokenResponse tokenResponse = tokenRequest.execute().getBody();
```

</Tab></Tabs>

Until the authorizing user approves the transaction, you should receive the following response:

```json lines
{
    "error": "authorization_pending",
    "error_description": "The end-user authorization is pending"
}
```

There is approximately a five-second wait interval for polling. If you poll too frequently, you will receive the following response, where the description varies depending on the backoff interval:

```json lines
{
"error": "slow_down",
"error_description": "You are polling faster than allowed. Try again in 10 seconds."
"interval": 10
}
```

To resolve the error, wait until the next interval (in seconds) to poll the `/token` endpoint.

## Step 4: Auth0 sends a link to the user’s email address

The Auth0 Authorization Server uses the `login_hint`, which contains the user ID for the authorizing user, to initiate user authentication on the authentication device:

* The Auth0 Authorization Server sends an email to the user's verified email address.
* The email contains a verification link that the user must click to authenticate. The `binding_message` shows up as the request code. 
* The link directs the user to the browser through a request to the `/bc-verify` endpoint, where the `consent` query parameter references the CIBA request awaiting consent.

<Frame>
  <img
    src="/docs/images/ciba/ciba_with_email_verification_link.png"
    alt="Auth0 sends email to user's verified email address"
    style={{ width: '300px', height: 'auto' }}
  />
</Frame>

## Step 5: User authenticates in the browser

If no active session is found, the verification link will ask the user to authenticate. The user clicks the link to proceed with user authentication.

To authenticate, the user enters their verified email address and password. The user must use the credentials provided to the `login_hint` parameter sent to the `/bc-authorize` endpoint when the client application [initiates a CIBA request](#step-1%3A-client-application-initiates-a-ciba-request). Otherwise, the user is prompted with an error message and needs to log out and try again.

<Frame>
  <img
    src="/docs/images/ciba/user_authenticates_in_browser.png"
    alt="User authenticates in the browser"
    style={{ width: '300px', height: 'auto' }}
  />
</Frame>

Once authenticated, the browser presents the consent details to the user from the Auth0 Consent API, which includes the `binding_message`, `scope`, and `audience`. The scopes are filtered according to your RBAC policy. To learn more, read [Role-Based Access Control](/docs/manage-users/access-control/rbac).

The following code sample is an example response from the Auth0 Consent API:

```json lines
{
  "id": "cns_abc123",
  "requested_details": {
    "audience": "https://$tenant.auth0.com/userinfo",
    "scope": ["openid"],
    "binding_message": "21-49-38"
  },
  "created_at": 1746693720
  "expires_at": 1746693750
}
```

The user can accept or decline the authentication request at this point.

## Step 6: Browser sends the user response back to Auth0

The browser sends the user response back to Auth0. Depending on whether the user accepts or rejects the authentication request, Auth0 displays the following consent screens, which you need to customize by [setting the consent prompts](/docs/get-started/apis/configure-rich-authorization-requests#set-customized-consent-prompt):

### User accepts the authentication request

<Frame>
  <img 
    src="/docs/images/ciba/user_accepts_the_authentication_request.png" 
    alt="User accepts the authentication request" 
    style={{ width: '300px', height: 'auto' }}
  />
</Frame>

### User rejects the authentication request

<Frame>
  <img 
    src="/docs/images/ciba/user_rejects_authentication_request.png" 
    alt="User accepts the authentication request" 
    style={{ width: '300px', height: 'auto' }}
  />
</Frame>

## Step 7: Auth0 receives user response after the flow completes

The client application completes the polling upon receiving a response from the `/token` endpoint. A CIBA flow always requires a response, either an approval or decline, from the authorizing user, and existing grants are not checked.

## Step 8: Auth0 returns access token to client application

If the user rejects the email request, Auth0 returns an error response like the following to the client application:

```json lines
{
    "error": "access_denied",
    "error_description": "The end-user denied the authorization request or it has been expired"
}
```
If the user approves the email request, Auth0 returns an <Tooltip tip="Access Token: Authorization credential, in the form of an opaque string or JWT, used to access an API." cta="View Glossary" href="/docs/glossary?term=access+token">access token</Tooltip> like the following to the client application:

```json lines
{
    "access_token": "eyJh...",
    "id_token": "eyJh...",
    "expires_in": 86400,
    "scope": "openid",
    "token_type": "Bearer"
}
```

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">
The `refresh_token` will only be present if the `offline_access` scope was included in the initial `/bc-authorize` request.
</Callout>

## Learn more

* [Client-Initiated Backchannel Authentication Flow](/docs/get-started/authentication-and-authorization-flow/client-initiated-backchannel-authentication-flow)
* [Configure Client-Initiated Backchannel Authentication](/docs/get-started/applications/configure-client-initiated-backchannel-authentication)