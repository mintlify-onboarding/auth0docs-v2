---
title: "秘密鍵JWT認証の設定"
permalink: "configure-private-key-jwt"
'description': "秘密鍵JWT認証を使用するための新規および既存のアプリケーションの構成方法について説明します。"
'og:title': "秘密鍵JWT認証の設定"
'og:description': "秘密鍵JWT認証を使用するための新規および既存のアプリケーションの構成方法について説明します。"
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "秘密鍵JWT認証の設定"
'twitter:description': "秘密鍵JWT認証を使用するための新規および既存のアプリケーションの構成方法について説明します。"
---

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

秘密鍵JWTは、エンタープライズプランでのみ使用できます。アップグレードするには、「[Auth0の価格設定](https://auth0.com/pricing/)」からご連絡ください。

</Callout>

秘密鍵<Tooltip data-tooltip-id="react-containers-DefinitionTooltip-3" href="/docs/ja-jp/glossary?term=json-web-token" tip="JSON Web Token（JWT）: 二者間のクレームを安全に表現するために使用される標準IDトークン形式（および多くの場合、アクセストークン形式）。" cta="用語集の表示">JWT</Tooltip>認証は、非対称鍵ペアで署名されたJWTアサーションを使用して、[OIDC Connect Core Client Authentication 1.0](https://openid.net/specs/openid-connect-core-1_0.html#ClientAuthentication)によるクライアント認証をサポートします。新しいアプリケーションを作成して`private_key_jwt`を使用するか、既存のアプリケーションで認証に秘密鍵ペアを使用するように設定することができます。

## 前提条件

秘密鍵JWTを使用するようにアプリケーションを構成する前に、[RSA鍵ペアを生成する](/docs/ja-jp/secure/application-credentials/generate-rsa-key-pair)必要があります。

## 秘密鍵JWTを構成する

<Tabs><Tab title="Auth0 Dashboard">

Auth0 Dashboardを使用して、新しいアプリケーションを作成することができ、資格情報の構成や既存アプリケーションの更新にも使用できます。

秘密鍵JWTにアプリケーション資格情報方法を設定する前に、現在の`client_secret`パラメーターを安全に保存することをお勧めします。`client_secret`パラメーターは、秘密鍵JWTの構成が完了すると非表示になります。

#### `private_key_jwt`に対する新しいアプリケーションの構成

1. [**［Auth0 Dashboard］ > ［Applications（アプリケーション）］ > ［Application（アプリケーション）］**](https://manage.auth0.com/#/applications)に移動します。
2. **［Create Application（アプリケーションの作成）］** を選択します。
3. アプリケーションタイプを選択します。
4. アプリケーション設定の下にある、**［Credentials（資格情報）］** タブを選択します。
5. **［Authentication Methods（認証方法）］** の下にある、**［Private Key JWT（秘密鍵JWT）］** を選択します。

   <Frame>![秘密鍵JWT認証を構成する - Auth0 Dashboardの説明](/docs/images/ja-jp/cdy7uua7fh8z/33kfi48tkbMIOQJ8PBxj76/8909d19639a9dae5dbc7252ba17ddd3a/Default_App_-_Creds_-_Japanese.png)</Frame>

6. 資格情報の詳細を構成します。

   1. 資格情報の名前を入力します。
   2. PEMフォーマットまたはX.509証明書をアップロードします。
   3. アサーションに署名するアルゴリズムを選択します。
   4. 任意：カスタム有効期限を有効にします。**［Set an explicit expiry date for this Credential（この資格情報への明確な有効期限の設定）］** を選択し、未来の日付を設定します。

      <Warning>

      不正な形式のキーマテリアルを送信すると、無効な証明書のエラーを受け取る可能性があります。問題を回避するには、opensslで作成したファイルを直接アップロードしてください。

      </Warning>

7. **［Add Credential（資格情報の追加）］** を選択します。

#### 既存のアプリケーションの構成

1. [［Auth0 Dashboard］ > ［Applications（アプリケーション）］](http://manage.auth0.com/#/applications)に移動します。
2. 更新したいアプリケーションを選択します。
3. **［Credentials（資格情報）］** タブを選択します。
4. **［Private Key JWT（秘密鍵JWT）］** を選択します。
5. 資格情報の詳細を構成します。

   1. 資格情報の名前を入力します。
   2. PEMフォーマットまたはX.509証明書をアップロードします。
   3. アサーションに署名するアルゴリズムを選択します。
   4. 任意：カスタム有効期限を有効にします。**［Set an explicit expiry date for this Credential（この資格情報への明確な有効期限の設定）］** を選択し、未来の日付を設定します。
6. **［Add Credential（資格情報の追加）］** を選択します。

#### クライアントシークレット認証の使用のためのアプリケーションの構成

1. [［Auth0 Dashboard］ > ［Applications（アプリケーション）］ > ［Applications（アプリケーション）］](https://manage.auth0.com/dashboard/#/applications/)に移動し、更新したいアプリケーションを選択します。
2. **［Credentials（資格情報）］** タブを選択します。
3. **クライアントシークレット（Post）** または**クライアントシークレット（Basic）** を選択します。
4. **［Save（保存）］** を選択します。

#### 資格情報の有効期限の更新

Auth0 Dashboardで、既存の資格情報の有効期限を更新できます。

1. [［Auth0 Dashboard］ > ［Applications（アプリケーション）］ > ［Applications（アプリケーション）］](https://manage.auth0.com/dashboard/#/applications/)に移動し、更新したいアプリケーションを選択します。
2. **［Credentials（資格情報）］** タブを選択します。
3. 更新したい資格情報を選択し、**［Edit Credential（資格情報の編集）］** を選択します。

   <Frame>![Dashboard - Applications - Application Settings - Credentials - update expiry date](/docs/images/ja-jp/cdy7uua7fh8z/6858PTDkNCRZiIqtBVmciZ/489fea406e2bf399089b894b095bbc18/Credentials_-_Edit_Menu.png)</Frame>

4. **［Set an explicit expiry date for this Credential（この資格情報への明確な有効期限の設定）］** を選択し、未来の日付を設定します。
5. **［Update Credential（資格情報の更新）］** を選択します。

</Tab><Tab title="Management API">

#### `private_key_jwt`に対する新しいアプリケーションの構成

Management APIを使用して、認証方法を`private_key_jwt`に設定し、新しいアプリケーションを作成できます。次のペイロードで[`クライアントの作成`](https://auth0.com/docs/api/management/v2#!/Clients/get_clients)エンドポイントに`POST`を呼び出します。

```bash lines
curl --location --request POST 'https://{domain}/api/v2/clients' \
  --header 'Authorization: Bearer {managementApiAccessToken} \
  --header 'Content-Type: application/json' \
  --data-raw '{
 "name": "{clientName}",
 "app_type": "non_interactive",
 "client_authentication_methods": {
   "private_key_jwt": {
     "credentials": [
       { 
          "name": "{credentialName}", 
          "credential_type": "public_key", 
          "pem": "{credentialublicKey}",
          "alg": "{algorithm}",
          "expires_at": "{expiresAt}"
       }
     ]
   },
   "jwt_configuration": {
     "alg": "RS256"
   }
 }
}'
```

<table class="table"><thead>
<tr>
<th>パラメーター</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td>`algorithm`</td>
<td>アサーションに署名するために使用するアルゴリズム。サポート値はRS256、RS384、PS256です。指定しない場合、アルゴリズムはデフォルトのRS256になります。</td>
</tr>
<tr>
<td>`clientName`</td>
<td>新規クライアントの名前。</td>
</tr>
<tr>
<td>`credentialName`</td>
<td>公開鍵の名前。</td>
</tr>
<tr>
<td>`expires_at`</td>
<td>任意。ISO 8601形式の資格情報の有効期限。例えば、`2020-08-20T19:10:06.299Z`です。有効期限を過ぎると、資格情報は無効になります。</td>
</tr>
<tr>
<td>`managementApiAccessToken`</td>
<td>`create:credentials` スコープを持つ <a href="/docs/ja-jp/auth0.com/docs/ja-jp/secure/tokens/access-tokens/management-api-access-tokens">Management API のアクセストークン </a> 。</td>
</tr>
<tr>
<td>`pem`</td>
<td>PEM形式でエンコードされた公開鍵、またはx.509。</td>
</tr>
<tr>
<td>`parse_expiry_from_cert`</td>
<td>任意。証明書を与えられたときにAuth0が有効期限の構造解析をするべきブール値を示します。証明書が与えられない場合、Auth0はエラーを返します。また、`parse_expiry_from_cert`と`expires_at`も相互排他的です。その場合、Auth0はエラーを返します。</td>
</tr>
</tbody>
</table>



公開鍵のPEMは、Auth0に渡す前にJSONでエスケープ処理する必要があります。この例では、以下を渡す必要があります：

```
-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA53VzmIVVZZWyNm266l82
mnoDc9g/snXklax5kChEhqK/WnTUvuXP4Gd4THj8rchxgUGKXd4PF3SUcKyn/qPm
Tet0idVHk2PwP//FOVgYo5Lb04js0pgZkbyB/WjuMp1w+yMuSn0NYAP7Q9U7DfTb
jmox8OQt4tCB4m7UrJghGqT8jkPyZO/Ka6/XsyjTYPOUL3t3PD7JShVAgo1mAY6g
Sr4SORywIiuHsg+59ad7MXGy78LirhtqAcDECKF7VZpxMuEjMLg3o2yzNUeWI2Mg
IF+t0HbO1E387fvLcuSyai1yWbSr1PXyiB2aXyDpbD4u7d3ux4ahU2opH11lBqvx
+wIDAQAB
-----END PUBLIC KEY-----
```



応答には、`client_id`プロパティを含み、アプリケーションをリソースサーバーに紐づけます。また、応答には、資格情報のために作成した生成`kid`を含みます。これはのちほど、`client_assertion`を生成するために使用します。

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Auth0は、[JSON Web Key Thumbprint](https://datatracker.ietf.org/doc/html/rfc7638)規格に基づいて資格情報のkidを生成します。

kidは、JWK表記された公開鍵のSHA256ダイジェストをbase64URLエンコードしたもので構成されます。

</Callout>

#### 既存のアプリケーションの構成

また、既存のアプリケーションを構成し、Auth0 Management APIで秘密鍵JWT認証を使用できます。これには`token_endpoint_auth_method`フィールドのすべての値を削除し、`client_authentication_methods`フィールドに値を作成する必要があります。

<Warning>

既存の運用アプリケーションを`private_key_jwt`で認証するように更新する場合は、後で参照できるように現在の`client_secret`値を安全に保管することをお勧めします。

private_key_jwtを構成した後では、クライアントシークレットを使用するようにアプリケーションの構成を復元しない限り、client_secretの値にアクセスできなくなります。

</Warning>

#### 資格情報リソースの作成

キーペアを生成したら、資格情報リソースを作成します。Management APIの[`/clients`](https://auth0.com/docs/api/management/v2#!/Clients/post_clients)エンドポイントに次のPOST要求をします。

```bash lines
curl --location --request POST 'https://{domain}/api/v2/clients/{clientId}/credentials' \
  --header 'Authorization: Bearer {managementApiAccessToken} \
  --header 'Content-Type: application/json' \
  --data-raw '{
          "name": "{credentialName}", 
          "credential_type": "public_key", 
          "pem": "{credentialPublicKey}",
          "alg": "{algorithm}",
          "expires_at ": "{expiresAt}",
}'
```

| パラメーター | 説明 | 
| ---------- | ---------- | 
|`algorithm`| アサーションの署名に使用するアルゴリズム。サポート値はRS256、RS384、PS256です。指定されていない場合、アルゴリズムのデフォルトはRS256です。| 
|`clientId`| 更新されるアプリケーションのID。| 
|`credentialName`| 公開鍵の名前。| 
|`managementApiAccessToken`| `create:credentials`スコープを持つ［Management APIのアクセストークン］（/secure/tokens/access-tokens/management-api-access-tokens）。| 
|`pem`| PEM形式でエンコードされた公開鍵またはx.509証明書。| 
|`expires_at`| 任意。ISO 8601形式の資格情報の有効期限です。例えば、`2020-08-20T19:10:06.299Z`です。有効期限が過ぎると、資格情報は無効になります。| 
|`parse_expiry_from_cert`| 任意。証明書を指定されたときにAuth0が構造解析をする有効期限のブール値を示します。証明書が指定されない場合、Auth0はエラーを返します。また、`parse_expiry_from_cert`と`expires_at`は相互排他的です。その場合、Auth0はエラーを返します。|

::: ::: 注意 公開鍵
PEM公開鍵は、Auth0に渡す前にJSON-escapedである必要があります。この例では、渡す必要のあるコンテンツは次の通りです：

``` lines
----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA53VzmIVVZZWyNm266l82
mnoDc9g/snXklax5kChEhqK/WnTUvuXP4Gd4THj8rchxgUGKXd4PF3SUcKyn/qPm
Tet0idVHk2PwP//FOVgYo5Lb04js0pgZkbyB/WjuMp1w+yMuSn0NYAP7Q9U7DfTb
jmox8OQt4tCB4m7UrJghGqT8jkPyZO/Ka6/XsyjTYPOUL3t3PD7JShVAgo1mAY6g
Sr4SORywIiuHsg+59ad7MXGy78LirhtqAcDECKF7VZpxMuEjMLg3o2yzNUeWI2Mg
IF+t0HbO1E387fvLcuSyai1yWbSr1PXyiB2aXyDpbD4u7d3ux4ahU2opH11lBqvx
+wIDAQAB
-----END PUBLIC KEY-----
```

:::

資格情報IDが応答を返します。次のステップにIDを使用します。

#### 資格情報の関連付け

資格情報を作成したら、それをアプリケーションに関連付けます。`private_key_jwt`を使用した認証中に、アプリケーションはこれらの資格情報を使用します。

Management APIの[`クライアントの更新`](https://auth0.com/docs/api/management/v2#!/Clients/patch_clients_by_id)エンドポイントにPATCH要求を行います。

```bash lines
curl --location --request PATCH 'https://{domain}/api/v2/clients/{clientId} \
  --header 'Authorization: Bearer {managementApiAccessToken} \
  --header 'Content-Type: application/json' \
  --data-raw '{
          "token_endpoint_auth_method": null, 
          "client_authentication_methods": {
             "private_key_jwt": {
                "credentials": [{ "id": {credentialId} }]
             }
          }
   }​​'​​
```

<table class="table"><thead>
<tr>
<th>パラメーター</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td>`clientId`</td>
<td>更新されるアプリケーションのID。</td>
</tr>
<tr>
<td>`managementApiAccessToken`</td>
<td>`update:client`と`update:credentials`のスコープを持つ<a href="/docs/ja-jp/secure/tokens/access-tokens/management-api-access-tokens">Management APIのアクセストークン</a>。</td>
</tr>
<tr>
<td>`credentialId`</td>
<td>新しい資格情報のID。</td>
</tr>
<tr>
<td>`pem`</td>
<td>PEM形式の公開鍵。</td>
</tr>
</tbody>
</table>

<Warning>

Auth0はアプリケーションのJWT署名アルゴリズムとして、HS256の使用に対応していません。RS256アルゴリズムに`jwt_configuration.alg`フィールドを設定する必要があります。署名アルゴリズムを変更する方法については、「[アプリケーションの署名アルゴリズムを変更する](/docs/ja-jp/get-started/applications/change-application-signing-algorithms)」をご覧ください。

</Warning>

#### クライアントシークレット認証の使用のためのアプリケーションの構成

クライアントシークレットを使用するようにアプリケーション構成を復元するには、`client_authentication_methods`を無効にし、認証方法で`token_endpoint_auth_method`を再有効にする必要があります。

<Warning>

認証方法を`client_secret`に設定すると、`client_secret`を使用して認証するように更新するまで、アプリケーションは`private_key_jwt`を使用して認証することができなくなります。

</Warning>

**例**

```bash lines
curl --location --request PATCH 'https://{domain}/api/v2/clients/{clientId} \
  --header 'Authorization: Bearer {managementApiAccessToken} \
  --header 'Content-Type: application/json' \
  --data-raw '{
          "token_endpoint_auth_method": "{tokenEndpointAuthMethod}", 
          "client_authentication_methods": null
   }​​'​​
```

<table class="table"><thead>
<tr>
<th>パラメーター</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td>`clientId`</td>
<td>更新されたアプリケーションのID。</td>
</tr>
<tr>
<td>`managementApiAccessToken`</td>
<td>update:clients`とupdate:client`と`update:credentials`のスコープを持つ  <a href="/docs/ja-jp/secure/tokens/access-tokens/management-api-access-tokens">Management APIのアクセストークン</a> 。</td>
</tr>
<tr>
<td>`tokenEndpointAuthMethod`</td>
<td>最終の認証方法。例：`client_secret_basic`または`client_secret_post`。</td>
</tr>
</tbody>
</table>

#### 有効期限フィールドに資格情報をパッチする

Management APIの [資格情報の更新](https://auth0.com/docs/api/management/v2#!/Clients/patch_credentials_by_credential_id)エンドポイントで有効期限付きの既存の資格情報を更新できます。

```bash lines
curl --location --request PATCH 'https://{domain}/api/v2/clients/{clientId}/credentials/{credentialId} ' \
  --header 'Authorization: Bearer {managementApiAccessToken} \
  --header 'Content-Type: application/json' \
  --data-raw '{
          "expires_at": {expiresAt}
   }'
```

| パラメーター | 説明 | 
| ---------- | ---------- | 
|`managementApiAccessToken`|  `update:credentials`スコープを持つManagement APIのアクセストークン。| 
|`clientId`| 更新したいクライアント。| 
|`expires_at`|ISO 8601形式の資格情報の有効期限。たとえば、`2020-08-20T19:10:06.299Z`です。|

更新できる唯一のフィールドは`expires_at`フィールドです。残りの属性は不変で、変更するには資格情報をローテーションする必要があります。

</Tab></Tabs>

## 資格情報の制限

Auth0では、秘密鍵JWT認証の設定において、RSA鍵ペアの最小サイズを2048ビット、最大サイズを4096ビットと定めています。アプリケーションでは、最大2つの資格情報を構成できます。

## 資格情報のローテーションを行う

鍵の漏洩を防ぐために、Auth0では定期的に鍵ペアをローテーションすることを推奨しています。その方法については、「[資格情報のローテーションを行う](/docs/ja-jp/get-started/applications/rotate-credentials)」をお読みください。

## もっと詳しく

* [アプリケーションの資格情報](/docs/ja-jp/secure/application-credentials)
* [資格情報の設定](/docs/ja-jp/get-started/applications/credentials)
* [秘密鍵JWTで認証する](/docs/ja-jp/get-started/authentication-and-authorization-flow/authenticate-with-private-key-jwt)