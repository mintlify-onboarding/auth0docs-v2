---
title: "ソリューションの概要（モバイルアプリ + API）"
permalink: "part-1"
'description': "SPA + APIアーキテクチャシナリオでのソリューションの概要"
'og:title': "ソリューションの概要（モバイルアプリ + API）"
'og:description': "SPA + APIアーキテクチャシナリオでのソリューションの概要"
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "ソリューションの概要（モバイルアプリ + API）"
'twitter:description': "SPA + APIアーキテクチャシナリオでのソリューションの概要"
---

ExampleCoでは、認可されたユーザーとアプリケーションだけがタイムシートAPIにアクセスできるように、[OAuth 2.00の認可フレームワーク](https://tools.ietf.org/html/rfc6749)を使用することに決めました。このフレームワークは、異なる付与タイプを使用して、タイムシートAPIと通信する必要があるさまざまな種類のアプリケーションを簡単に認可できるため、同社が求めている柔軟性を提供しています。

## API認証と認可

APIは、アプリケーションの機能性を他のアプリケーションに公開する手段になります。アプリケーションは、APIエンドポイントにメッセージを送信することで要求を行い、応答として情報を受信することができます。

APIエンドポイントはセキュリティ保護されている場合と、そうでない場合があります。この例では、タイムシートAPI審査や財務情報などの機密情報であるため、認可されたユーザーとアプリケーションだけがAPIのエンドポイントを呼び出せるようにしなければなりません。クライアントアプリケーションがAPIの保護されたエンドポイントにアクセスしたい場合は、エンドポイントへの呼び出しに必要なアクセス許可を備えている証拠としてアクセストークンを提示する必要があります。

アクセストークンは認証サーバーでユーザーを認証することにより取得され、ユーザーはアプリケーションが自身の代理でAPIにアクセスすることを許可できます。

<Card title="アクセストークンとは">

アクセストークン（`access_token`とも呼ばれる）は、アプリケーションに対して発行された認可を表す、不透明な文字列です。この文字列は、認証情報の取得に使う識別子の場合もあれば、認証情報そのもの（たとえば、ユーザーのID、アクセス許可など）を検証可能な形で含んでいることもあります。

アクセストークンはたいていの場合、[JSON Web Token](https://auth0.com/docs/tokens/concepts/jwts)として実装されます。

Auth0アクセストークンの詳細については、「[アクセストークン](https://auth0.com/docs/tokens/concepts/access-tokens)」を参照してください。

</Card>

APIは、APIが公開するさまざまなエンドポイントに誰がアクセスを許可されるかについて、きめ細かい制御を行うことができます。これらのアクセス許可はスコープと呼ばれます。

ユーザーがクライアントアプリケーションを認可すると、アプリケーションは必要とされるアクセス許可も指定することができます。ユーザーはこれらのアクセス許可を確認して付与します。そして、これらのアクセス許可が`scope`クレームの一部としてアクセストークンに含まれます。

その後、クライアントがAPIへの要求でアクセストークンを渡すと、APIは`scope`クレームを調査し、特定のAPIエンドポイントを呼び出すために必要なアクセス許可が付与されていることを確認します。

<Card title="スコープとは">

それぞれのアクセストークンには、クライアントに付与されたアクセス権限のリストが含まれます。クライアントがAuth0で認証を行う際、要求するスコープ（アクセス許可）のリストを指定します。スコープが認可されると、アクセストークンに認可されたスコープのリストが含められます。

たとえば、タイムシートAPIは、タイムシートの読み取り（スコープ：`read:timesheets`）、タイムシートの作成（スコープ：`create:timesheets`）、タイムシートの削除（スコープ：`delete:timesheets`）、タイムシートの承認（スコープ：`approve:timesheets`）という異なる4レベルの認可を受け入れることができます。

クライアントがAPIに新しいタイムシートエントリーの作成を依頼するときは、アクセストークンに`create:timesheets`スコープが含まれなくてはなりません。同様に、既存のタイムシートを削除するには、アクセストークンに`delete:timesheets`スコープが含まれなくてはなりません。

スコープの詳細については、「[スコープ](https://auth0.com/docs/scopes)」を参照してください。

</Card>

<Tooltip data-tooltip-id="react-containers-DefinitionTooltip-1" href="/docs/ja-jp/glossary?term=oath2" tip="OAuth 2.0: 認可プロトコルとワークフローを定義する認可フレームワーク。" cta="用語集の表示">OAuth 2.0</Tooltip> Authorization Framework使用することで、独自のアプリケーションや社外の請負業者向けのサードパーティアプリケーションは、アプリケーション自体に代わってAPIに制限付きでアクセスできるようになります。Auth0を使用することで、OAuth 2.0/<Tooltip data-tooltip-id="react-containers-DefinitionTooltip-0" href="/docs/ja-jp/glossary?term=openid" tip="OpenID: アプリケーションがログイン情報を収集および保存することなくにユーザーのIDを検証できるようにする認証用のオープン標準。" cta="用語集の表示">OpenID</Tooltip> Connect（OIDC）の仕様や、API認証に関する他の多くの技術的側面を心配することなく、独自のAPIで異なる認証フローを簡単にサポートすることができます。

<Card title="OAuthロール">

OAuth 2.0フローでは、次のロールが識別されます：

* **リソース所有者（Resource Owner）** ：保護されたリソースへのアクセス権を付与できるエンティティ。通常は、エンドユーザーです。
* **リソースサーバー（Resource Server）** ：保護されたリソースをホストするサーバー。アクセスしたいAPIのことです。
* **クライアント（Client）** ：リソース所有者の代わりに保護されたリソースへのアクセス権を要求するアプリケーション。
* **認可サーバー（Authorization Server）** ：リソース所有者を認証し、適切な認可を得た後にアクセストークンを発行するサーバー。この場合、Auth0の認証APIになります。

[付与タイプ（またはフロー）](https://auth0.com/docs/api-auth/which-oauth-flow-to-use)は、これらの関係者がどのように作用し、ビルド中のAPIへの制限付きアクセスをアプリに付与するのかを決定します。そして、ユーザーの代わりにAPIを呼び出すためのアクセストークンをアプリが取得します。

</Card>

## Proof Key for Code Exchange（PKCE）

OAuth 2には、異なるユースケースにいくつかの付与タイプが用意されます。この特定のユースケースでは、モバイルアプリケーションからAPIにアクセスしたいとします。そのためには、[Proof Key for Code Exchange（PKCE）を使った認可コードフロー](/docs/ja-jp/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce)を使用します。

Proof Key for Code Exchange（PKCE）は、[RFC 7636](https://tools.ietf.org/html/rfc7636)で定義されており、悪意ある攻撃者がAuth0から返された`authorization_code`を横取りし、[アクセストークン](/docs/ja-jp/secure/tokens/access-tokens)（および場合によっては[リフレッシュトークン](/docs/ja-jp/secure/tokens/refresh-tokens)）と交換する、認可コード横取り攻撃を軽減するために使用される手法です。

アプリケーションはPKCEを使って、それぞれの認可要求に`code_verifier`と呼ばれる暗号的にランダムなキーと、それから生成される`code_challenge`と呼ばれる値を作成します。そして、このキーは`authorization_code`を取得するためにAuth0に送られます。アプリケーションが`authorization_code`を受け取ると、コードと`code_verifier`をAuth0のトークンエンドポイントに送信し、要求されたトークンと交換します。

1. アプリはフローを開始して、ユーザーをAuth0（具体的には[/authorize](/docs/ja-jp/api/authentication#authorization-code-grant-pkce-)エンドポイント）にリダイレクトし、`code_challenge`パラメーターと`code_challenge_method`パラメーターを送ります。アプリは、認証に成功した後に送信する`code_verifier`も生成します。
2. Auth0がユーザーを認証します。
3. ユーザーが認証に成功すると、Auth0は、クエリ文字列に`authorization_code`を持つアプリにユーザーをリダイレクトします。
4. アプリは`code_verifier`を`redirect_uri` と`client_id` と一緒にAuth0に送ります。これは、[/oauth/token endpoint](/docs/ja-jp/api/authentication?http#authorization-code-pkce-)を使って行われます。
5. Auth0はこの情報を検証し、アクセストークン（と任意でリフレッシュトークン）を返します。
6. アプリはアクセストークンを使って、ユーザーの代わりにAPIを呼び出します。

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

[［Refresh Token Rotation（リフレッシュトークンのローテーション）］](https://auth0.com/docs/tokens/concepts/refresh-token-rotation)を有効にした場合、要求ごとに新しいリフレッシュトークンが生成され、アクセストークンと共に発行されます。リフレッシュトークンが交換されると、前のリフレッシュトークンは失効しますが、関係についての情報は認可サーバーによって維持されます。

</Callout>

## 認可拡張機能

[Auth0認可拡張機能](https://auth0.com/docs/extensions/authorization-extension)を使うと、ロール、グループ、権限を構成し、ユーザーに割り当てることができます。

* 権限とは、ユーザーが行うことができるアクションです。ExampleCoの事業上のニーズに合わせ、タイムシートの読み取り、作成、削除、および承認の4つの権限が構成されます。
* ロールとは、権限の集合です。ExampleCoのタイムシートアプリは、それぞれ異なる権限を持つ2種類のユーザー（従業員とマネージャー）によって使用されるので、従業員とマネージャーという2つのロールが構成されます。

これで事業上のニーズはカバーされるため、この場合にはグループは作成しません。

認可拡張機能は、ユーザーに割り当てられたロール、グループ、および権限を読み取り、この情報を認証フローで[ユーザープロファイル](https://auth0.com/docs/rules/current#rule-syntax)に追加する[ルール](https://auth0.com/docs/rules)を作成します。この情報を使用して、ユーザーに発行されたアクセストークンに、認可拡張機能で定義された権限が許すスコープのみが含まれるようにします。後から、ユーザーに必要な権限がない場合はタイムシートの承認機能を無効にするなど、アプリのカスタマイズに進むことができます。