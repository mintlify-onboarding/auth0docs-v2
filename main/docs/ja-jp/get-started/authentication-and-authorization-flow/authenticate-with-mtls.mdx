---
title: "mTLSで認証する"
permalink: "authenticate-with-mtls"
'description': "mTLSを使用してクライアントを認証する方法について説明します。"
'og:title': "mTLSで認証する"
'og:description': "mTLSを使用してクライアントを認証する方法について説明します。"
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "mTLSで認証する"
'twitter:description': "mTLSを使用してクライアントを認証する方法について説明します。"
---

## OAuth/OIDCのmTLS

デフォルトの<Tooltip data-tooltip-id="react-containers-DefinitionTooltip-0" href="/docs/ja-jp/glossary?term=oath2" tip="OAuth 2.0: 認可プロトコルとワークフローを定義する認可フレームワーク。" cta="用語集の表示">OAuth</Tooltip>/OIDCフローは、以下の問題から、常に安全であるとは限りません。

* 共有クライアントシークレットがクライアント認証の形式に使用されている
* アクセストークンが意図しない当事者によって使用される

2020年に、Internet Engineering Task Force（IETF）は、こうした問題に対処するために、[RFC 8705](https://www.rfc-editor.org/rfc/rfc8705)の「Mutual-TLS (mTLS) Client Authentication」（相互TLS（mTLS）を利用したクライアント認証）をリリースしました。mTLSを利用した認証では、秘密鍵を持つクライアント証明書は、OAuth/OIDCフローのクライアントシークレットのように機能し、クライアントのIDを確認します。クライアントがネットワーク層ですでに認証されている場合、アプリケーション層でクライアントシークレットは必要ありません。さらに、クライアント証明書を複数のサーバーに使用することで、リソースサーバーにクライアントのIDを証明することができます。上記の問題を解決する方法はこの他にもあります。その名前は[秘密鍵JWT](/docs/ja-jp/get-started/authentication-and-authorization-flow/authenticate-with-private-key-jwt)と[DPoP](https://datatracker.ietf.org/doc/html/rfc9449)です。

OAuthフローをmTLSで保護するために、クライアントはTLS接続の確立時に、mTLS証明書を顧客のエッジネットワーク上のTLS終端ポイントに送信します。認可サーバーは要求を処理する前に、クライアントのmTLS証明書をまず確認する必要があります。

<Frame>![null](/docs/images/ja-jp/cdy7uua7fh8z/4SlprP2uTYMCoLIPLsOl4v/dc34f47fa69654ed2b15c1bbde46a56a/HRI_diagrams_-_mtls_diagram_1__2_.png)</Frame>

また、mTLSを使用すると、意図された当事者のみがアクセストークンを使用する（送信者制限またはトークンバインディングと呼ばれる）ことができます。クライアントがmTLS接続を使用して認可サーバーの`/oauth/token`エンドポイントを呼び出すと、クライアントのTLS証明書がアクセストークンの証明書に一致することを確認するためにリソースサーバーが使用する情報が、アクセストークンに含まれることになります。

<Frame>![null](/docs/images/ja-jp/cdy7uua7fh8z/7qocbfqySAnu85ph6WVSGU/558e40fe21a0284b9fcad7200da9f80e/HRI_diagrams_-_mtls_diagram_2__1_.png)</Frame>

**注意** ：mTLSクライアント認証とmTLSトークンバインディングは、それぞれ単独で使用することができます。mTLSクライアント認証はmTLSトークンバインディングなしで使用でき、mTLSトークンバインディングはクライアントシークレットや秘密鍵<Tooltip data-tooltip-id="react-containers-DefinitionTooltip-3" href="/docs/ja-jp/glossary?term=json-web-token" tip="JSON Web Token（JWT）: 二者間のクレームを安全に表現するために使用される標準IDトークン形式（および多くの場合、アクセストークン形式）。" cta="用語集の表示">JWT</Tooltip>など他の形式のクライアント認証と併用することができます。他の形式のクライアント認証を使用している場合でも、クライアントはクライアント証明書をmTLSトークンバインディングの認可サーバーに送信します。

## Auth0でのmTLS

Auth0のmTLSは[カスタムドメイン](/docs/ja-jp/customize/custom-domains)を使って構築され、証明書のプロビジョニングと検証には顧客に既存のmTLS基盤が活用されます。

クライアントシークレットを通常必要とするAuth0への認証済みクライアント呼び出しは、まず、カスタマーエッジに送信されます。このアクションは、顧客が管理する証明書を使用するカスタムドメインではすでに起こっています。カスタマーエッジはクライアントとmTLSハンドシェイクを実行し、クライアント証明書を検証します。クライアント証明書が検証されたら、カスタムドメインの機能に基づいて、要求がAuth0でテナントのエッジドメインに転送されます（HTTPヘッダー内の検証済みクライアント証明書と正しい`cname-api-key`を含む）。

<Frame>![null](/docs/images/ja-jp/cdy7uua7fh8z/7p3tqUtBeMAp4fBbbemhOh/f53eb8cab2a7c21ea3c5671f78168d44/HRI_diagrams_-_mtls_diagram_3__1_.png)</Frame>

## 認証サーバーを呼び出す

mTLSはクライアント認証とアクセストークンバインディングの両方を処理するため、クライアントはこれらの機能が認可サーバーで有効かどうか知っている必要があります。さらに、認可サーバーのmTLSエンドポイントと非mTLSエンドポイントは、異なるドメインに公開されることがあります。

認可サーバーの構成詳細を取得するために、クライアントはGET要求を[OpenID Connect Discovery](https://openid.net/specs/openid-connect-discovery-1_0.html)エンドポイント`https://<custom-domain>/.well-known/openid-configuration`に送信します。

応答に成功すると、OIDCディスカバリードキュメントまたはJSONオブジェクトが返され、認可サーバーのプロパティとエンドポイント（mTLSに関連するものを含む）が一覧表示されます。

mTLSクライアント認証が有効な場合、OIDCディスカバリードキュメントには`token_endpoint_auth_methods_supported`プロパティが含まれます。このプロパティには、`tls_client_auth`または`self_signed_tls_client_auth`が含まれています。

```json lines
{
  ...
  "token_endpoint_auth_methods_supported": ["tls_client_auth"]
  ...
}
```

mTLSトークンバインディングが有効な場合、OIDCディスカバリードキュメントは`tls_client_certificate_bound_access_tokens`プロパティを`true:`に設定します。

```json lines
{
  ...
  "tls_client_certificate_bound_access_tokens": true
  ...
}
```

mTLSエンドポイントエイリアスをサポートする環境では、mTLSをサポートするエンドポイントのリストを含む新しいプロパティ`mtls_endpoint_aliases`が公開されます。mTLSをサポートするクライアントの場合、`mtls_endpoint_aliases`に表示されたエンドポイントが、`mtls_endpoint_aliases`の外で公開された同じエンドポイントよりも優先されます。

以下のコードサンプルでは、`token_endpoint`プロパティが2回公開されています。mTLSの呼び出しに使用するエンドポイントは、`mtls_endpoint_aliases`または`https://mtls.auth.bank.com/oauth/token`に一覧表示されています。

```json lines
{
  ...
  "mtls_endpoint_aliases": {
"token_endpoint": "https://mtls.auth.bank.com/oauth/token"
  },
  "token_endpoint": "https://auth.bank.com/oauth/token",
  "pushed_authorization_request_endpoint": "https://auth.bank.com/oauth/par",
  ...
}
```

エンドポイントが`mtls_endpoint_aliases`に一覧表示されていない場合は、`mtls_endpoint_aliases`の外に一覧表示された同じエンドポイントを使用してください。上記の例では、`pushed_authorization_request_endpoint`は`mtls_endpoint_aliases`に一覧表示されていません。そのため、`mtls_endpoint_aliases`または`https://auth.bank.com/oauth/par`の外に公開された`pushed_authorization_request_endpoint`を使用します。

詳細については、RFC 8705の[エンドポイントに関するセクション](https://www.rfc-editor.org/rfc/rfc8705#name-metadata-for-mutual-tls-end)を参照してください。

## リソースサーバーを呼び出す

クライアントはアクセストークンを受け取ったら、リソースサーバーで保護されたリソースにアクセスすることができます。mTLSトークンバインディングが有効な場合、認可サーバーは`tls_client_certificate_bound_access_tokens`プロパティを含むOIDCディスカバリードキュメントを返します。

クライアントがmTLSバウンドアクセストークンを使ってリソースサーバーを呼び出す場合、リソースサーバーはTLSハンドシェイク中にクライアントからmTLS証明書を要求します。リソースサーバーは、クライアント証明書が401 HTTPステータスコードと`invalid_token`エラーコードに一致しないアクセストークンを持つ要求を拒否する必要があります。詳細については、「[送信者制限用にリソースサーバーを構成する](/docs/ja-jp/secure/sender-constraining/configure-sender-constraining/configure-resource-server-for-sender-constraining)」をお読みください。

## もっと詳しく

* [mTLS認証の設定](/docs/ja-jp/get-started/applications/configure-mtls)