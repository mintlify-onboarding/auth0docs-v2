---
title: "フォームPOSTを使った暗黙フロー"
permalink: "implicit-flow-with-form-post"
'description': "フォームPOSTを使った暗黙フローの動作と、ユーザーの認証にIDトークンのみを必要とする従来型のWebアプリでこのフローを使用するべき理由について理解します。"
'og:title': "フォームPOSTを使った暗黙フロー"
'og:description': "フォームPOSTを使った暗黙フローの動作と、ユーザーの認証にIDトークンのみを必要とする従来型のWebアプリでこのフローを使用するべき理由について理解します。"
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "フォームPOSTを使った暗黙フロー"
'twitter:description': "フォームPOSTを使った暗黙フローの動作と、ユーザーの認証にIDトークンのみを必要とする従来型のWebアプリでこのフローを使用するべき理由について理解します。"
---

<Warning>

「暗黙」という言葉を誤解しないよう注意してください。OAuthでは、現在、SPAでのアクセストークンの取得に暗黙の付与を使用することを奨励していませんが、フォームPOSTを使った暗黙フローで対処するシナリオは、これとはまったく異なり、SPAで使用する場合のような**セキュリティ上の問題が生じません** 。具体的に言うと、フォームPOSTを使った暗黙フローは、SPAとは対照的に従来型のWebアプリに適用されます。また、取得するのはアクセストークンではなく、使用目的のまったく異なるIDトークンです。このフローは、POSTを使用し、（SPAのように）トークン情報がブラウザー履歴攻撃やヘッダーのリダイレクトなどにさらされる可能性のあるURLフラグメントにトークンを配置することはありません。

</Warning>

従来型のWebアプリにWebサインインを実装するために、<Tooltip data-tooltip-id="react-containers-DefinitionTooltip-0" href="/docs/ja-jp/glossary?term=openid" tip="OpenID: アプリケーションがログイン情報を収集および保存することなくにユーザーのIDを検証できるようにする認証用のオープン標準。" cta="用語集の表示">OpenID</Tooltip> Connect（OIDC）を多くの異なるフローで使用することができます。典型的なフローでは、アプリのバックエンドで認可コードフローを実行することにより、IDトークンが取得されます。この方法は効果的で安定性も高い反面、アプリがシークレットを取得して管理する必要があります。目的がサインインを実装することだけで、APIの実行にアクセストークンを取得する必要がない場合には、この負荷を避けることができます。

フォームPOSTを使った暗黙フローはOIDCを使用して、<Tooltip data-tooltip-id="react-containers-DefinitionTooltip-1" href="/docs/ja-jp/glossary?term=security-assertion-markup-language" tip="Security Assertion Markup Language（SAML）: パスワードなしに二者間で認証情報を交換できる標準化プロトコル。" cta="用語集の表示">SAML</Tooltip>やWS-Federationに類似したWebサインインを実装します。Webアプリは、フロントチャネルを介してトークンを要求し、取得します。シークレットや追加でバックエンドを呼び出す必要はありません。この方法では、アプリケーションでシークレットの取得や管理、使用、保護を必要としません。

## 仕組み

<Warning>

このフローは、ログインのみのユースケースに使用します。ユーザーのログイン時にAPIを呼び出せるようにアクセストークンを要求する場合は、[PKCEを使った認可コードフロー](/docs/ja-jp/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce)または[ハイブリッドフロー](/docs/ja-jp/get-started/authentication-and-authorization-flow/hybrid-flow)を使用してください。

</Warning>

<Frame>![フロー - フォームPOSTフローで暗黙的モード - 認可シーケンスの図](/docs/images/ja-jp/cdy7uua7fh8z/6m0uE4E7Hpzbdhyh9dEuYK/c7659f6fda881d2ac61af6724adeb54f/auth-sequence-implicit-form-post.png)</Frame>

1. ユーザーはアプリで **［Login（ログイン）］** をクリックします。
2. Auth0の SDKは、ユーザーをAuth0認可サーバー (`/authorize` endpoint)にリダイレクトし、要求された資格情報の種類を示す`id_token`の`response_type`パラメータを渡します。また、セキュリティを確保するために `form_post`の`response_mode`パラメータも渡します。
3. Auth0の認可サーバーがユーザーをログインにリダイレクトして、認可を促します。
4. ユーザーは構成されたログインオプションの1つを使用して認証を行い、Auth0がアプリに与える許可をリストした同意ページが表示されることもあります。
5. Auth0認可サーバーは、IDトークンを添えて、ユーザーをリダイレクトでアプリへ戻します。

## 実装方法

[OktaのExpress OpenID Connect SDKを使用](https://www.npmjs.com/package/express-openid-connect)して、フォームポストを使用した暗黙フローを安全に実装することができます。

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

[Auth0 Single-Page App SDK](/docs/ja-jp/libraries/auth0-single-page-app-sdk)と[Single-Page Quickstarts](/docs/ja-jp/quickstart/spa)は、新しい推奨に従い、[PKCEを使った認可コードフロー](/docs/ja-jp/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce)を使用します。

</Callout>

最後に、チュートリアルに従って、APIエンドポイントを使用して、[フォームポストを使用した暗黙フローでのログインを追加](/docs/ja-jp/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post/add-login-using-the-implicit-flow-with-form-post)することができます。

## もっと詳しく

* [Auth0ルール](/docs/ja-jp/customize/rules)
* [Auth0のフック](/docs/ja-jp/customize/hooks)
* [トークン](/docs/ja-jp/secure/tokens)
* [トークンのベストプラクティス](/docs/ja-jp/secure/tokens/token-best-practices)
* [どちらのOAuth 2.0フローを使用するべきですか？](/docs/ja-jp/get-started/authentication-and-authorization-flow/which-oauth-2-0-flow-should-i-use)
* [暗黙フロー使用時にリプレイ攻撃を軽減する](/docs/ja-jp/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post/mitigate-replay-attacks-when-using-the-implicit-flow)