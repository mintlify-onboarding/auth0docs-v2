---
title: "一括ユーザーエクスポート"
permalink: "bulk-user-exports"
'description': "ユーザーリストとユーザーメタデータをエクスポートする方法を学びます。"
'og:title': "一括ユーザーエクスポート"
'og:description': "ユーザーリストとユーザーメタデータをエクスポートする方法を学びます。"
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "一括ユーザーエクスポート"
'twitter:description': "ユーザーリストとユーザーメタデータをエクスポートする方法を学びます。"
---
import {AuthCodeBlock} from "/snippets/AuthCodeBlock.jsx";

import {AuthCodeGroup} from "/snippets/AuthCodeGroup.jsx";

`POST /api/v2/jobs/users-exports`エンドポイントを使用して、[接続](/docs/ja-jp/identityproviders)に関連付けられているすべてのユーザー、またはテナント内のすべてのユーザーをエクスポートするジョブを作成できます。

エクスポートできるユーザープロファイルフィールドのリストについては、「[ユーザープロファイル構造](/docs/ja-jp/manage-users/user-accounts/user-profiles/user-profile-structure)」を参照してください。

ジョブを作成するときは、次の情報を提供する必要があります。

* ユーザーをエクスポートする[接続のID](/docs/ja-jp/authenticate/identity-providers/locate-the-connection-id)（オプション）
* エクスポートファイルの形式（CSVまたはJSON互換）
* エクスポートするユーザーレコードの最大数（オプション、省略するとすべてのレコードがエクスポートされます）
* エクスポートに含めるユーザー関連フィールド（ユーザーIDや名前など）

有効な[Management APIアクセストークン](/docs/ja-jp/api/management/v2/tokens)も必要です。

## 要求本文を作成する

必要に応じて、<Tooltip data-tooltip-id="react-containers-DefinitionTooltip-0" href="/docs/ja-jp/glossary?term=auth0-dashboard" tip="Auth0 Dashboard: サービスを構成するためのAuth0の主製品。" cta="用語集の表示">Auth0 Dashboard</Tooltip>で`connection_id`とAuth0テナントドメイン名を見つけます。以下の要求本文を含む新しいテキストファイルを作成します。

```json lines
{
   "connection_id":"connection_id",
   "format":"csv",
   "limit":20,
   "fields":[
      {
         "name":"user_id"
      },
      {
         "name":"email"
      },
      {
         "name":"user_metadata.country"
      }
   ]
}
```

`connection_id`をデータベース接続IDで更新するか、削除してテナント内のすべてのユーザーをエクスポートします。

## 要求例

必要なスコープ：`read:users`

<AuthCodeGroup>
```bash cURL
curl --request POST \
  --url 'https://{yourDomain}/api/v2/jobs/users-exports' \
  --header 'authorization: Bearer {yourMgmtAPIAccessToken}' \
  --header 'content-type: application/json' \
  --data '{"connection_id": "{yourConnectionId}", "format": "csv", "limit": 5, "fields": [{"name": "email"}, { "name": "identities[0].connection", "export_as": "provider" }]}'
```
```csharp C#
var client = new RestClient("https://{yourDomain}/api/v2/jobs/users-exports");
var request = new RestRequest(Method.POST);
request.AddHeader("authorization", "Bearer {yourMgmtAPIAccessToken}");
request.AddHeader("content-type", "application/json");
request.AddParameter("application/json", "{"connection_id": "{yourConnectionId}", "format": "csv", "limit": 5, "fields": [{"name": "email"}, { "name": "identities[0].connection", "export_as": "provider" }]}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```
```go Go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/api/v2/jobs/users-exports"

	payload := strings.NewReader("{"connection_id": "{yourConnectionId}", "format": "csv", "limit": 5, "fields": [{"name": "email"}, { "name": "identities[0].connection", "export_as": "provider" }]}")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("authorization", "Bearer {yourMgmtAPIAccessToken}")
	req.Header.Add("content-type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java
HttpResponse<String> response = Unirest.post("https://{yourDomain}/api/v2/jobs/users-exports")
  .header("authorization", "Bearer {yourMgmtAPIAccessToken}")
  .header("content-type", "application/json")
  .body("{"connection_id": "{yourConnectionId}", "format": "csv", "limit": 5, "fields": [{"name": "email"}, { "name": "identities[0].connection", "export_as": "provider" }]}")
  .asString();
```
```javascript Node.JS
var axios = require("axios").default;

var options = {
  method: 'POST',
  url: 'https://{yourDomain}/api/v2/jobs/users-exports',
  headers: {
    authorization: 'Bearer {yourMgmtAPIAccessToken}',
    'content-type': 'application/json'
  },
  data: {
    connection_id: '{yourConnectionId}',
    format: 'csv',
    limit: 5,
    fields: [{name: 'email'}, {name: 'identities[0].connection', export_as: 'provider'}]
  }
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```objc Obj-C
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"authorization": @"Bearer {yourMgmtAPIAccessToken}",
                           @"content-type": @"application/json" };
NSDictionary *parameters = @{ @"connection_id": @"{yourConnectionId}",
                              @"format": @"csv",
                              @"limit": @5,
                              @"fields": @[ @{ @"name": @"email" }, @{ @"name": @"identities[0].connection", @"export_as": @"provider" } ] };

NSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/jobs/users-exports"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"POST"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```
```php PHP
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/api/v2/jobs/users-exports",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "POST",
  CURLOPT_POSTFIELDS => "{"connection_id": "{yourConnectionId}", "format": "csv", "limit": 5, "fields": [{"name": "email"}, { "name": "identities[0].connection", "export_as": "provider" }]}",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer {yourMgmtAPIAccessToken}",
    "content-type: application/json"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python
import http.client

conn = http.client.HTTPSConnection("")

payload = "{"connection_id": "{yourConnectionId}", "format": "csv", "limit": 5, "fields": [{"name": "email"}, { "name": "identities[0].connection", "export_as": "provider" }]}"

headers = {
    'authorization': "Bearer {yourMgmtAPIAccessToken}",
    'content-type': "application/json"
    }

conn.request("POST", "/{yourDomain}/api/v2/jobs/users-exports", payload, headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```
```ruby Ruby
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/api/v2/jobs/users-exports")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Post.new(url)
request["authorization"] = 'Bearer {yourMgmtAPIAccessToken}'
request["content-type"] = 'application/json'
request.body = "{"connection_id": "{yourConnectionId}", "format": "csv", "limit": 5, "fields": [{"name": "email"}, { "name": "identities[0].connection", "export_as": "provider" }]}"

response = http.request(request)
puts response.read_body
```
```swift Swift
import Foundation

let headers = [
  "authorization": "Bearer {yourMgmtAPIAccessToken}",
  "content-type": "application/json"
]
let parameters = [
  "connection_id": "{yourConnectionId}",
  "format": "csv",
  "limit": 5,
  "fields": [
    ["name": "email"],
    [
      "name": "identities[0].connection",
      "export_as": "provider"
    ]
  ]
] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/jobs/users-exports")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</AuthCodeGroup>

応答はこのようになっているはずです。

```json lines
{
  "type": "users_export",
  "status": "pending",
  "connection_id": "con_0000000000000001",
  "format": "csv",
  "limit": 5,
  "fields": [
    {
      "name": "user_id"
    },
    {
      "name": "name"
    },
    {
      "name": "email"
    },
    {
      "name": "identities[0].connection",
      "export_as": "provider"
    }
  ],
  "connection": "Username-Password-Authentication",
  "created_at": "2017-11-02T23:34:03.803Z",
  "id": "job_coRQCC3MHztpuTlo"
}
```

## エクスポートされたCSVにユーザーメタデータを含める

ユーザーデータをCSV形式でエクスポートし、メタデータ情報を含める場合は、エクスポートする各メタデータフィールドを指定します。最大30個のフィールドをエクスポートできます。

<Warning>

`app_metadata`または`user_metadata`全体をCSV形式でエクスポートすることはできません。メタデータオブジェクトのフィールドを明確に指定する必要があります。

`app_metadata`または`user_metadata`を単一のオブジェクトとしてエクスポートするには、JSON互換の形式で要求ボディの`fields`パラメーターに目的のフィールドを含めます。例：

`{"name":"app_metadata"}`

最大30個のフィールドしかエクスポートできないため、ユーザーデータに多くのフィールドがある場合は、JSON形式を使用することをお勧めします。

</Warning>

たとえば、メタデータが次のように構造化されている場合。

```json lines
{
  "consent": {
      "given": true,
      "date": "01/23/2019",
      "text_details": "{yourURL}"
  }
}
```

エクスポート要求（3つのフィールドすべて）は次のようになります。

<AuthCodeGroup>
```bash cURL
curl --request POST \
  --url 'https://{yourDomain}/api/v2/jobs/users-exports' \
  --header 'authorization: Bearer {yourMgmtAPIAccessToken}' \
  --header 'content-type: application/json' \
  --data '{"connection_id": "{yourConnectionId}", "format": "csv", "limit": 5, "fields": [{"name": "email"}, {"name": "user_metadata.consent.given"}, {"name": "user_metadata.consent.date"}, {"name": "user_metadata.consent.text_details"}]}'
```
```csharp C#
var client = new RestClient("https://{yourDomain}/api/v2/jobs/users-exports");
var request = new RestRequest(Method.POST);
request.AddHeader("authorization", "Bearer {yourMgmtAPIAccessToken}");
request.AddHeader("content-type", "application/json");
request.AddParameter("application/json", "{"connection_id": "{yourConnectionId}", "format": "csv", "limit": 5, "fields": [{"name": "email"}, {"name": "user_metadata.consent.given"}, {"name": "user_metadata.consent.date"}, {"name": "user_metadata.consent.text_details"}]}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```
```go Go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/api/v2/jobs/users-exports"

	payload := strings.NewReader("{"connection_id": "{yourConnectionId}", "format": "csv", "limit": 5, "fields": [{"name": "email"}, {"name": "user_metadata.consent.given"}, {"name": "user_metadata.consent.date"}, {"name": "user_metadata.consent.text_details"}]}")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("authorization", "Bearer {yourMgmtAPIAccessToken}")
	req.Header.Add("content-type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java
HttpResponse<String> response = Unirest.post("https://{yourDomain}/api/v2/jobs/users-exports")
  .header("authorization", "Bearer {yourMgmtAPIAccessToken}")
  .header("content-type", "application/json")
  .body("{"connection_id": "{yourConnectionId}", "format": "csv", "limit": 5, "fields": [{"name": "email"}, {"name": "user_metadata.consent.given"}, {"name": "user_metadata.consent.date"}, {"name": "user_metadata.consent.text_details"}]}")
  .asString();
```
```javascript Node.JS
var axios = require("axios").default;

var options = {
  method: 'POST',
  url: 'https://{yourDomain}/api/v2/jobs/users-exports',
  headers: {
    authorization: 'Bearer {yourMgmtAPIAccessToken}',
    'content-type': 'application/json'
  },
  data: {
    connection_id: '{yourConnectionId}',
    format: 'csv',
    limit: 5,
    fields: [
      {name: 'email'},
      {name: 'user_metadata.consent.given'},
      {name: 'user_metadata.consent.date'},
      {name: 'user_metadata.consent.text_details'}
    ]
  }
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```objc Obj-C
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"authorization": @"Bearer {yourMgmtAPIAccessToken}",
                           @"content-type": @"application/json" };
NSDictionary *parameters = @{ @"connection_id": @"{yourConnectionId}",
                              @"format": @"csv",
                              @"limit": @5,
                              @"fields": @[ @{ @"name": @"email" }, @{ @"name": @"user_metadata.consent.given" }, @{ @"name": @"user_metadata.consent.date" }, @{ @"name": @"user_metadata.consent.text_details" } ] };

NSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/jobs/users-exports"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"POST"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```
```php PHP
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/api/v2/jobs/users-exports",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "POST",
  CURLOPT_POSTFIELDS => "{"connection_id": "{yourConnectionId}", "format": "csv", "limit": 5, "fields": [{"name": "email"}, {"name": "user_metadata.consent.given"}, {"name": "user_metadata.consent.date"}, {"name": "user_metadata.consent.text_details"}]}",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer {yourMgmtAPIAccessToken}",
    "content-type: application/json"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python
import http.client

conn = http.client.HTTPSConnection("")

payload = "{"connection_id": "{yourConnectionId}", "format": "csv", "limit": 5, "fields": [{"name": "email"}, {"name": "user_metadata.consent.given"}, {"name": "user_metadata.consent.date"}, {"name": "user_metadata.consent.text_details"}]}"

headers = {
    'authorization': "Bearer {yourMgmtAPIAccessToken}",
    'content-type': "application/json"
    }

conn.request("POST", "/{yourDomain}/api/v2/jobs/users-exports", payload, headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```
```ruby Ruby
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/api/v2/jobs/users-exports")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Post.new(url)
request["authorization"] = 'Bearer {yourMgmtAPIAccessToken}'
request["content-type"] = 'application/json'
request.body = "{"connection_id": "{yourConnectionId}", "format": "csv", "limit": 5, "fields": [{"name": "email"}, {"name": "user_metadata.consent.given"}, {"name": "user_metadata.consent.date"}, {"name": "user_metadata.consent.text_details"}]}"

response = http.request(request)
puts response.read_body
```
```swift Swift
import Foundation

let headers = [
  "authorization": "Bearer {yourMgmtAPIAccessToken}",
  "content-type": "application/json"
]
let parameters = [
  "connection_id": "{yourConnectionId}",
  "format": "csv",
  "limit": 5,
  "fields": [["name": "email"], ["name": "user_metadata.consent.given"], ["name": "user_metadata.consent.date"], ["name": "user_metadata.consent.text_details"]]
] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/jobs/users-exports")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</AuthCodeGroup>

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

ユーザーエクスポートのCSVファイルでは、CSVインジェクションのリスクを軽減するために、OWASP標準に準拠して以下のように文字列データ型のエスケープ処理を行います。

* 二重引用符の前に二重引用符を付加します。
* 文字列の先頭に一重引用符を付加します。
* 文字列を二重引用符で囲みます。

これは、Auth0が生成するISO 8601形式の日付には適用されません。

</Callout>

### JSON互換形式

データをJSON互換形式でエクスポートする場合は、ルートプロパティのみを指定する必要があります。個々の内部プロパティは自動的に含められるため、名前を付ける必要はありません。

Auth0のエクスポートファイルは、エクスポートファイルのサイズが大きいため[NDJSON](https://github.com/ndjson/ndjson-spec)形式を使用しますが、インポート機能ではJSONファイルが必要です。

Auth0によって生成されたエクスポートを使用してユーザーをインポートする前に、任意のライブラリ（[jq](https://stedolan.github.io/jq/)など）を使用して、ファイルをNDJSONからJSONに変換する必要があります。

この場合、前に使用したのと同じ例では、要求は次のようになります。

<AuthCodeGroup>
```bash cURL
curl --request POST \
  --url 'https://{yourDomain}/api/v2/jobs/users-exports' \
  --header 'authorization: Bearer {yourMgmtAPIAccessToken}' \
  --header 'content-type: application/json' \
  --data '{"connection_id": "{yourConnectionId}", "format": "json", "limit": 5, "fields": [{"name": "email"}, {"name": "user_metadata.consent"}]}'
```
```csharp C#
var client = new RestClient("https://{yourDomain}/api/v2/jobs/users-exports");
var request = new RestRequest(Method.POST);
request.AddHeader("authorization", "Bearer {yourMgmtAPIAccessToken}");
request.AddHeader("content-type", "application/json");
request.AddParameter("application/json", "{"connection_id": "{yourConnectionId}", "format": "json", "limit": 5, "fields": [{"name": "email"}, {"name": "user_metadata.consent"}]}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```
```go Go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/api/v2/jobs/users-exports"

	payload := strings.NewReader("{"connection_id": "{yourConnectionId}", "format": "json", "limit": 5, "fields": [{"name": "email"}, {"name": "user_metadata.consent"}]}")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("authorization", "Bearer {yourMgmtAPIAccessToken}")
	req.Header.Add("content-type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java
HttpResponse<String> response = Unirest.post("https://{yourDomain}/api/v2/jobs/users-exports")
  .header("authorization", "Bearer {yourMgmtAPIAccessToken}")
  .header("content-type", "application/json")
  .body("{"connection_id": "{yourConnectionId}", "format": "json", "limit": 5, "fields": [{"name": "email"}, {"name": "user_metadata.consent"}]}")
  .asString();
```
```javascript Node.JS
var axios = require("axios").default;

var options = {
  method: 'POST',
  url: 'https://{yourDomain}/api/v2/jobs/users-exports',
  headers: {
    authorization: 'Bearer {yourMgmtAPIAccessToken}',
    'content-type': 'application/json'
  },
  data: {
    connection_id: '{yourConnectionId}',
    format: 'json',
    limit: 5,
    fields: [{name: 'email'}, {name: 'user_metadata.consent'}]
  }
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```objc Obj-C
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"authorization": @"Bearer {yourMgmtAPIAccessToken}",
                           @"content-type": @"application/json" };
NSDictionary *parameters = @{ @"connection_id": @"{yourConnectionId}",
                              @"format": @"json",
                              @"limit": @5,
                              @"fields": @[ @{ @"name": @"email" }, @{ @"name": @"user_metadata.consent" } ] };

NSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/jobs/users-exports"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"POST"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```
```php PHP
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/api/v2/jobs/users-exports",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "POST",
  CURLOPT_POSTFIELDS => "{"connection_id": "{yourConnectionId}", "format": "json", "limit": 5, "fields": [{"name": "email"}, {"name": "user_metadata.consent"}]}",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer {yourMgmtAPIAccessToken}",
    "content-type: application/json"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python
import http.client

conn = http.client.HTTPSConnection("")

payload = "{"connection_id": "{yourConnectionId}", "format": "json", "limit": 5, "fields": [{"name": "email"}, {"name": "user_metadata.consent"}]}"

headers = {
    'authorization': "Bearer {yourMgmtAPIAccessToken}",
    'content-type': "application/json"
    }

conn.request("POST", "/{yourDomain}/api/v2/jobs/users-exports", payload, headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```
```ruby Ruby
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/api/v2/jobs/users-exports")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Post.new(url)
request["authorization"] = 'Bearer {yourMgmtAPIAccessToken}'
request["content-type"] = 'application/json'
request.body = "{"connection_id": "{yourConnectionId}", "format": "json", "limit": 5, "fields": [{"name": "email"}, {"name": "user_metadata.consent"}]}"

response = http.request(request)
puts response.read_body
```
```swift Swift
import Foundation

let headers = [
  "authorization": "Bearer {yourMgmtAPIAccessToken}",
  "content-type": "application/json"
]
let parameters = [
  "connection_id": "{yourConnectionId}",
  "format": "json",
  "limit": 5,
  "fields": [["name": "email"], ["name": "user_metadata.consent"]]
] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/jobs/users-exports")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</AuthCodeGroup>

## エクスポートステータスの確認

ユーザーをエクスポートするジョブを作成したら、[Get a Jobエンドポイント](/docs/ja-jp/api/management/v2#!/Jobs/get_jobs_by_id)を使用してそのステータスを確認できます。

ジョブのID（ジョブの作成時に応答で受け取ったID）を指定します。以下のサンプル要求を使用している場合は、プレースホルダー`{yourJobId}`をIDの値に置き換えます。

必要なスコープ: `create:users`, `read:users`, `create:passwords_checking_job`

<AuthCodeGroup>
```bash cURL
curl --request GET \
  --url 'https://{yourDomain}/api/v2/jobs/%7ByourJobId%7D' \
  --header 'authorization: Bearer {yourMgmtAPIAccessToken}'
```
```csharp C#
var client = new RestClient("https://{yourDomain}/api/v2/jobs/%7ByourJobId%7D");
var request = new RestRequest(Method.GET);
request.AddHeader("authorization", "Bearer {yourMgmtAPIAccessToken}");
IRestResponse response = client.Execute(request);
```
```go Go
package main

import (
	"fmt"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/api/v2/jobs/%7ByourJobId%7D"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("authorization", "Bearer {yourMgmtAPIAccessToken}")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java
HttpResponse<String> response = Unirest.get("https://{yourDomain}/api/v2/jobs/%7ByourJobId%7D")
  .header("authorization", "Bearer {yourMgmtAPIAccessToken}")
  .asString();
```
```javascript Node.JS
var axios = require("axios").default;

var options = {
  method: 'GET',
  url: 'https://{yourDomain}/api/v2/jobs/%7ByourJobId%7D',
  headers: {authorization: 'Bearer {yourMgmtAPIAccessToken}'}
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```objc Obj-C
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"authorization": @"Bearer {yourMgmtAPIAccessToken}" };

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/jobs/%7ByourJobId%7D"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"GET"];
[request setAllHTTPHeaderFields:headers];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```
```php PHP
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/api/v2/jobs/%7ByourJobId%7D",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "GET",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer {yourMgmtAPIAccessToken}"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python
import http.client

conn = http.client.HTTPSConnection("")

headers = { 'authorization': "Bearer {yourMgmtAPIAccessToken}" }

conn.request("GET", "/{yourDomain}/api/v2/jobs/%7ByourJobId%7D", headers=headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```
```ruby Ruby
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/api/v2/jobs/%7ByourJobId%7D")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Get.new(url)
request["authorization"] = 'Bearer {yourMgmtAPIAccessToken}'

response = http.request(request)
puts response.read_body
```
```swift Swift
import Foundation

let headers = ["authorization": "Bearer {yourMgmtAPIAccessToken}"]

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/jobs/%7ByourJobId%7D")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</AuthCodeGroup>

次のような応答が返されます。

```json lines
{
  "type": "users_export",
  "status": "completed",
  "connection_id": "con_lCvO...a",
  "format": "csv",
  "limit": 5,
  "fields": [
    {
      "name": "user_id"
    },
    {
      "name": "name"
    },
    {
      "name": "email"
    },
    {
      "name": "identities[0].connection",
      "export_as": "provider"
    }
  ],
  "location": "pus3-auth0-export-users-us-east-2.s3.us-east-2.amazonaws.com/job_coRQCC3MHztpuTlo/auth0docs2.csv.gz?Expires=1509725589&Key-Pair-Id=APKAJPL62IJALBDMSSCA&Signature=l2JaFXP~BATnfagb64PK-qbX9QaZREDYNW0q5QeHuV-MaDpZjpABDXfHHLh2SsCMQz~UO-QsCSfI81l0lvCKzZPZL6cZHK7f~ixlZOK~MHKJuvMqsUZMbNluNAwhFmgb2fZ86yrB1c-l2--H3lMELAk7hKUwwSrNBlsfbMgQ-i41nMNnsYdy3AVlNVQkwZyx~w-IEHfJDHsqyjia-jfDbIOLQvr8~D9PwZ-xOzROxDwgxrt3undtz80bkgP5hRKOAbHC7Y-iKWa2bzNZYHqzowTrlh7Ta60cblJR46NfF9cNqn9jqRGVv-lsvUD9FxnImCCk~DL6npJnzNLjHvn4-CaWq6KdQnwWgCnZ3LZkxXDVWLLIQQaoc6i~xbuGnnbtKRePFSnpqbt2mAUYasdxTOWuUVK8wHhtfZmRYtCpwZcElXFO9Qs~PTroYZEiS~UHH5byMLt2x4ChkHnTG7pIhLAHN~bCOLk8BN2lOkDBUASEVtuJ-1i6cKCDqI2Ro9YaKZcCYzeQvKwziX6cgnMchmaZW77~RMOGloi2EffYE31OJHKiSVRK7RGTykaYN5S2Sg7W0ZOlLPKBtCGRvGb8rJ6n3oPUiOC3lSp7v0~dkx1rm-jO8mKWZwVtC0~4DVaXsn8KXNbj0LB4mjKaDHwXs16uH1-aCfFnMK7sZC2VyCU_",
  "connection": "Username-Password-Authentication",
  "created_at": "2017-11-02T23:34:03.803Z",
  "id": "job_coRQCC3MHztpuTlo"
}
```

## エクスポートデータの検索

**location** パラメータの値として提供されたURLを使用することで、エクスポートファイルにアクセスできます。テナントの名前は、ファイルの名前でもあります。たとえば、テナント名が`auth0docs`の場合、ファイルは`auth0docs.csv`または`auth0docs.json`になります。URLに移動すると、ファイルのダウンロードが自動的に開始されます。

ダウンロードリンクは60秒間有効です。この期間が経過した場合、ジョブが期限切れになる前に24時間以内に再度呼び出すことができます。

## ジョブのクリーンアップ

ジョブ関連データはすべて24時間後に自動的に削除され、その後はアクセスできなくなります。そのため、**選択したストレージメカニズムを使用してジョブの結果を保存することを強くお勧めします** 。