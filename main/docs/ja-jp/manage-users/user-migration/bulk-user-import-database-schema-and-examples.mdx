---
title: "一括ユーザーインポートのデータベーススキーマと例"
permalink: "bulk-user-import-database-schema-and-examples"
'description': "Management APIを使用して一括ユーザーインポートを行う方法について説明します。"
'og:title': "一括ユーザーインポートのデータベーススキーマと例"
'og:description': "Management APIを使用して一括ユーザーインポートを行う方法について説明します。"
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "一括ユーザーインポートのデータベーススキーマと例"
'twitter:description': "Management APIを使用して一括ユーザーインポートを行う方法について説明します。"
---

ユーザーファイルには、ユーザーの情報をJSON形式の配列として含める必要があります。

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

一括インポートでのファイルサイズは、500 KBが上限です。データがこのサイズを上回る場合には、複数のインポートを開始する必要があります。

</Callout>

## ユーザーのJSONスキーマ

以下のJSONスキーマは有効なユーザーを記述しています。

```json lines
{
  "type": "object",
	"properties": {
		"email": {
			"type": "string",
			"description": "The user's email address.",
			"format": "email"
		},
		"email_verified": {
			"type": "boolean",
			"default": false,
			"description": "Indicates whether the user has verified their email address."
		},
		"user_id": {
			"type": "string",
			"description": "The user's unique identifier. This will be prepended by the connection strategy."
		},
		"username": {
			"type": "string",
			"description": "The user's username."
		},
		"given_name": {
			"type": "string",
			"description": "The user's given name."
		},
		"family_name": {
			"type": "string",
			"description": "The user's family name."
		},
		"name": {
			"type": "string",
			"description": "The user's full name."
		},
		"nickname": {
			"type": "string",
			"description": "The user's nickname."
		},
		"picture": {
			"type": "string",
			"description": "URL pointing to the user's profile picture."
		},
		"blocked": {
			"type": "boolean",
			"description": "Indicates whether the user has been blocked."
		},
		"password_hash": {
			"type": "string",
			"description": "Hashed password for the user. Passwords should be hashed using bcrypt $2a$ or $2b$ and have 10 saltRounds."
		},
		"custom_password_hash": {
			"type": "object",
			"description": "A more generic way to provide the users password hash. This can be used in lieu of the password_hash field when the users password hash was created with an alternate algorithm. Note that this field and password_hash are mutually exclusive.",
			"properties": {
				"algorithm": {
					"type": "string",
					"enum": [
						"argon2",
						"bcrypt",
						"hmac",
						"ldap",
						"md4",
						"md5",
						"sha1",
						"sha256",
						"sha512",
						"pbkdf2",
						"scrypt"
					],
					"description": "The algorithm that was used to hash the password."
				},
				"hash": {
					"type": "object",
					"properties": {
						"value": {
							"type": "string",
							"description": "The password hash."
						},
						"encoding": {
							"type": "string",
							"enum": [
								"base64",
								"hex",
								"utf8"
							],
							"description": "The encoding of the provided hash. Note that both upper and lower case hex variants are supported, as well as url-encoded base64."
						},
						"digest": {
							"type": "string",
							"description": "The algorithm that was used to generate the HMAC hash",
							"enum": [
								"md4",
								"md5",
								"ripemd160",
								"sha1",
								"sha224",
								"sha256",
								"sha384",
								"sha512",
								"whirlpool"
							]
						},
						"key": {
							"type": "object",
							"description": "The key that was used to generate the HMAC hash",
							"required": [
								"value"
							],
							"properties": {
								"value": {
									"type": "string",
									"description": "The key value"
								},
								"encoding": {
									"type": "string",
									"enum": [
										"base64",
										"hex",
										"utf8"
									],
									"default": "utf8",
									"description": "The key encoding"
								}
							}
						}
					}
				},
				"salt": {
					"type": "object",
					"properties": {
						"value": {
							"type": "string",
							"description": "The salt value used to generate the hash."
						},
						"encoding": {
							"type": "string",
							"enum": [
								"base64",
								"hex",
								"utf8"
							],
							"default": "utf8",
							"description": "The encoding of the provided salt. Note that both upper and lower case hex variants are supported, as well as url-encoded base64."
						},
						"position": {
							"type": "string",
							"enum": [
								"prefix",
								"suffix"
							],
							"default": "prefix",
							"description": "The position of the salt when the hash was calculated. For example; MD5('salt' + 'password') = '67A1E09BB1F83F5007DC119C14D663AA' would have \"position\":\"prefix\"."
						}
					},
					"required": [
						"value"
					]
				},
				"password": {
					"type": "object",
					"properties": {
						"encoding": {
							"type": "string",
							"enum": [
								"ascii",
								"utf8",
								"utf16le",
								"ucs2",
								"latin1",
								"binary"
							],
							"default": "utf8",
							"description": "The encoding of the password used to generate the hash. On login, the user-provided password will be transcoded from utf8 before being checked against the provided hash. For example; if your hash was generated from a ucs2 encoded string, then you would supply \"encoding\":\"ucs2\"."
						}
					}
				},
				"keylen" : {
					"type": "integer",
					"description": "Desired key length in bytes for the scrypt hash. Must be an integer greater than zero. Required when algorithm is set to scrypt."
				},
				"cost" : {
					"type": "integer",
					"default": 16384,
					"description": "CPU/memory cost parameter used for the scrypt hash. Must be a power of two greater than one. Only used when algorithm is set to scrypt."
				},
				"blockSize" : {
					"type": "integer",
					"default": 8,
					"description": "Block size parameter used for the scrypt hash. Must be a positive integer. Only used when algorithm is set to scrypt."
				},
				"parallelization" : {
					"type": "integer",
					"default": 1,
					"description": "Parallelization parameter used for the scrypt hash. Must be a positive integer. Only used when algorithm is set to scrypt."
				}
			},
			"required": [
				"algorithm",
				"hash"
			],
			"additionalProperties": false
		},
		"app_metadata": {
			"type": "object",
			"description": "Data related to the user that does affect the application's core functionality."
		},
		"user_metadata": {
			"type": "object",
			"description": "Data related to the user that does not affect the application's core functionality."
		},
		"mfa_factors": {
			"type": "array",
			"items": {
				"type": "object",
				"properties": {
					"totp": {
						"type": "object",
						"properties": {
							"secret": {
								"type": "string",
								"pattern": "^[A-Z2-7]+$",
								"description": "The OTP secret is used with authenticator apps (Google Authenticator, Microsoft Authenticator, Authy, 1Password, LastPass). It must be supplied in un-padded Base32 encoding, such as: JBTWY3DPEHPK3PNP"
							}
						},
						"additionalProperties": false,
						"required": [
							"secret"
						]
					},
					"phone": {
						"type": "object",
						"properties": {
							"value": {
								"type": "string",
								"pattern": "^\\+[0-9]{1,15}$",
								"description": "The phone number for SMS MFA. The phone number should include a country code and begin with +, such as: +12125550001"
							}
						},
						"additionalProperties": false,
						"required": [
							"value"
						]
					},
					"email": {
						"type": "object",
						"properties": {
							"value": {
								"type": "string",
								"format": "email",
								"description": "The email address for MFA"
							}
						},
						"additionalProperties": false,
						"required": [
							"value"
						]
					}
				},
				"maxProperties": 1,
				"additionalProperties": false
			},
			"minItems": 1,
			"maxItems": 10
		}
	},
	"required": [
		"email"
	],
	"additionalProperties": false
}
```

JSONスキーマの詳細については、[jsonschema.org](http://json-schema.org)をご覧ください。

## プロパティ

ユーザーは以下のプロパティを使用してインポートすることができます。

<table class="table"><thead>
<tr>
<th><strong>プロパティ</strong></th>
<th><strong>タイプ</strong></th>
<th><strong>説明</strong></th>
<th><strong>インポート中のアップサート？</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>`app_metadata`</td>
<td>オブジェクト</td>
<td>アプリケーションの主要な機能またはユーザーがアクセスできるものに影響を与えるデータ。`app_metadata`に保管されているデータをユーザーは編集できません。これには、サポートプラン、ロール、アクセスグループなどが含まれます。</td>
<td>Yes</td>
</tr>
<tr>
<td>`blocked`</td>
<td>ブール値</td>
<td>ユーザーがブロックされているかどうかを示します。</td>
<td>No</td>
</tr>
<tr>
<td>`email`</td>
<td>文字列</td>
<td>ユーザーのメールアドレス。</td>
<td>No</td>
</tr>
<tr>
<td>`email_verified`</td>
<td>ブール値</td>
<td>ユーザーがメールアドレスを検証したかどうかを示します。デフォルトで`email`がアップサートにより更新され、`email_verified`でない場合は`false`に設定されます。</td>
<td>Yes</td>
</tr>
<tr>
<td>`family_name`</td>
<td>文字列</td>
<td>ユーザーの姓。</td>
<td>Yes</td>
</tr>
<tr>
<td>`given_name`</td>
<td>文字列</td>
<td>ユーザーの名。</td>
<td>Yes</td>
</tr>
<tr>
<td>`name`</td>
<td>文字列</td>
<td>ユーザーのフルネーム。</td>
<td>Yes</td>
</tr>
<tr>
<td>`nickname`</td>
<td>文字列</td>
<td>ユーザーのニックネーム。</td>
<td>Yes</td>
</tr>
<tr>
<td>`picture`</td>
<td>文字列</td>
<td>ユーザーのプロファイル画像を指すURL</td>
<td>Yes</td>
</tr>
<tr>
<td>`user_id`</td>
<td>文字列</td>
<td>ユーザーの一意の識別子。これは、接続戦略によりプリペンドされます。</td>
<td>No</td>
</tr>
<tr>
<td>`user_metadata`</td>
<td>オブジェクト</td>
<td>勤務先住所、自宅住所、ユーザーのお気に入りなど、ユーザーのアクセスに影響を与えないデータ。</td>
<td>Yes</td>
</tr>
<tr>
<td>`username`</td>
<td>文字列</td>
<td>ユーザーのユーザー名。</td>
<td>No</td>
</tr>
<tr>
<td>`password_hash`</td>
<td>文字列</td>
<td>ユーザーの接続のためにハッシュ化されたパスワード。ユーザーが作成されると、Auth0は[bcrypt]（https://auth0.com/blog/hashing-in-action-understanding-bcrypt/）を使用してパスワードを保護します。ハッシュ化されたパスワードをインポートすることで、ユーザーはパスワードを保持できるようになるため、スムーズなエクスペリエンスを提供できます。互換性のあるパスワードは、bcrypt $2a$または$2b$を使ってハッシュ化し、saltRoundsを10回繰り返したものでなければなりません。このプロパティはユーザーが最初にインポートされたときのみ提供され、後で更新できません。</td>
<td>No</td>
</tr>
<tr>
<td>`custom_password_hash`</td>
<td>オブジェクト</td>
<td>ユーザーのパスワードハッシュを提供するより一般的な方法。これは、ユーザーのパスワードハッシュが他のアルゴリズムで作成された場合に、`password_hash`フィールドの代わりに使用できます。ユーザーが最初にインポートされた`custom_password_hash`を使ってログインしなかった場合、一括インポートの処理中に`custom_password_hash`を更新できます。</td>
<td>Yes</td>
</tr>
<tr>
<td>`mfa_factors`</td>
<td>配列</td>
<td>このユーザーを認証するために使用できるMFA要素</td>
<td>No</td>
</tr>
</tbody>
</table>

`app_metadata`と`user_metadata`の詳細については、「[ユーザープロファイルでのメタデータの使い方](/docs/ja-jp/manage-users/user-accounts/metadata)」をお読みください。

## アプリメタデータ

`user.app_metadata`オブジェクトには、以下のいずれのプロパティも含めては**いけません** 。

* `__tenant`
* `_id`
* `blocked`
* `clientID`
* `created_at`
* `email_verified`
* `email`
* `globalClientID`
* `global_client_id`
* `identities`
* `lastIP`
* `lastLogin`
* `loginsCount`
* `metadata`
* `multifactor_last_modified`
* `multifactor`
* `updated_at`
* `user_id`

## カスタムパスワードハッシュ

`user.custom_password_hash`オブジェクトは、ユーザーのパスワードハッシュが他のアルゴリズムで作成された場合に、`user.password_hash`プロパティの代わりに使用できます。このフィールドと`password_hash`が相互に排他的であることに注意してください。

`user.custom_password_hash`オブジェクトは以下のプロパティに対応しています。

<table class="table"><thead>
<tr>
<th>プロパティ</th>
<th>タイプ</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td>`algorithm`</td>
<td>string</td>
<td>パスワードをハッシュするために使用されるアルゴリズム。以下のうちの１つである必要があります： <ul><li>`argon2`</li><li>`bcrypt`</li><li>`hmac`</li><li>`ldap`</li><li>`md4`</li><li>`md5`</li><li>`sha1`</li><li>`sha256`</li><li>`sha512`</li><li>`pbkdf2`</li><li>`scrypt`</li></ul></td>
</tr>
<tr>
<td>`hash`</td>
<td>オブジェクト</td>
<td></td>
</tr>
<tr>
<td>`hash.value`</td>
<td>文字列</td>
<td>パスワードハッシュ。</td>
</tr>
<tr>
<td>`hash.encoding`</td>
<td>文字列</td>
<td>提供されたハッシュのエンコーディング。以下のうちの１つである必要があります：<ul><li>`base64`</li><li>`hex`</li><li>`utf8`</li></ul>16進数の大文字と小文字のバリエーションと、URLエンコードされたbase64がサポートされています。</td>
</tr>
<tr>
<td>`hash.digest`</td>
<td>文字列</td>
<td>HMACハッシュを生成するために使用されるアルゴリズム。以下のうちの１つである必要があります：<ul><li>`md4`</li><li>`md5`</li><li>`ripemd160`</li><li>`sha1`</li><li>`sha224`</li><li>`sha256`</li><li>`sha384`</li><li>`sha512`</li><li>`whirlpool`</li></ul></td>
</tr>
<tr>
<td>`hash.key`</td>
<td>オブジェクト</td>
<td>HMACハッシュを生成するために使用される鍵。</td>
</tr>
<tr>
<td>`hash.key.value`</td>
<td>文字列</td>
<td>鍵値。</td>
</tr>
<tr>
<td>`hash.key.encoding`</td>
<td>文字列</td>
<td>鍵エンコーディング。以下のうちの１つである必要があります：<ul><li>`base64`</li><li>`hex`</li><li>`utf8`</li></ul>デフォルトで、`hash.key.encoding`は`utf8`です。</td>
</tr>
<tr>
<td>`salt`</td>
<td>object</td>
<td></td>
</tr>
<tr>
<td>`salt.value`</td>
<td>文字列</td>
<td>ハッシュを生成するために使用されるソルト値。</td>
</tr>
<tr>
<td>`salt.encoding`</td>
<td>文字列</td>
<td>提供されたソルトのエンコーディング。以下のうちの１つである必要があります：<ul><li>`base64`</li><li>`hex`</li><li>`utf8`</li></ul>16進数の大文字と小文字のバリエーションと、URLエンコードされたbase64がサポートされています。デフォルトで、`salt.encoding`は`utf8`です。</td>
</tr>
<tr>
<td>`salt.position`</td>
<td>文字列</td>
<td>ハッシュが計算されたときのソルトの位置。デフォルトで、`salt.position`は`prefix`です。</td>
</tr>
<tr>
<td>`password.encoding`</td>
<td>文字列</td>
<td>ハッシュを生成するために使用されるパスワードのエンコーディング。以下のうちの１つである必要があります：<ul><li>`ascii`</li><li>`utf8`</li><li>`utf16le`</li><li>`ucs2`</li><li>`latin1`</li><li>`binary`</li></ul>ログイン時、ユーザーが提供したパスワードは、提供されたハッシュと照合される前に、`password.encoding`からトランスコードされます。たとえば、ハッシュが`ucs2`エンコードされた文字列から生成された場合は、次のように設定します： ` "encoding":  "ucs2"`</td>
</tr>
<tr>
<td>`keylen`</td>
<td>整数</td>
<td>スクリプトハッシュのバイト単位での望ましい鍵長。ゼロよりも大きい整数でなければなりません。<br/>`algorithm`が`scrypt`に設定されている場合、このアルゴリズムが必要です。</td>
</tr>
<tr>
<td>`cost`</td>
<td>整数</td>
<td>スクリプトハッシュに使用されるCPU/メモリーコストパラメーター。1より大きい2の冪でなければなりません。デフォルトで、`cost`は16384です。<br/>`algorithm`が`scrypt`に設定されている場合のみ、このアルゴリズムが使用されます。</td>
</tr>
<tr>
<td>`blockSize`</td>
<td>整数</td>
<td>スクリプトハッシュに使用されるブロックサイズパラメーター。正の整数でなければなりません。デフォルトで、`blockSize`は8です。<br/>`algorithm`が`scrypt`に設定されている場合のみ、このアルゴリズムが使用されます。</td>
</tr>
<tr>
<td>`parallelization`</td>
<td>整数</td>
<td>スクリプトハッシュに使用される並列化パラメーター。正の整数でなければなりません。デフォルトで、`parallelization`は1です。<br/>`algorithm`が`scrypt`に設定されている場合のみ、このアルゴリズムが使用されます。</td>
</tr>
</tbody>
</table>

### カスタムパスワードハッシュを更新する

ユーザーが最初にインポートされた`custom_password_hash`を使ってログインしなかった場合、一括インポートの処理中に`custom_password_hash`を更新できます。たとえば、以下のJSONは、`custom_password_hash`に異なる値を指定して、[`/api/v2/jobs/users-imports`](https://auth0.com/docs/api/management/v2?_ga=2.169020323.346193905.1601302257-746691936.1587131255#!/Jobs/post_users_imports)エンドポイントに2回送信することができます。2回目の送信では、`upsert`フラグを`true`に設定します。

```javascript lines
[
    {
    	"user_id": "2000",
        "email": "examplecouser20@gmail.com",
        "given_name": "ExampleCo User",
        "name" : "ExampleCoUser20",
        "custom_password_hash": {
            "algorithm": "bcrypt",
            "hash": {
                "value": "$2a$10$aHF7mbpWT6tZ7PJVtwtjNelaKbszikcYBCB2jibvbFcGFmOsu/s4K"
            }
        }
    }
]
```

browserling.comで[Bcryptパスワードジェネレーター](https://www.browserling.com/tools/bcrypt)を使用して、bcryptパスワードハッシュを生成することができます。

### 対応しているハッシュアルゴリズム

Auth0は現在、以下のユーザーパスワードハッシュのインポートに対応しています。

* [Argon2](https://github.com/p-h-c/phc-winner-argon2)
* [bcrypt](https://auth0.com/blog/hashing-in-action-understanding-bcrypt/)
* [LDAP](https://tools.ietf.org/html/rfc2307#section-5.3)（`RFC-2307 "userPassword"`）
* [HMAC](https://tools.ietf.org/html/rfc2104)
* [MD4](https://tools.ietf.org/html/rfc1320)
* [MD5](https://tools.ietf.org/html/rfc1321)
* [SHA1](https://tools.ietf.org/html/rfc3174)
* [SHA256およびSHA512](https://tools.ietf.org/html/rfc4634)
* [PBKDF2](https://tools.ietf.org/html/rfc2898#section-5.2)
* [scrypt](https://datatracker.ietf.org/doc/rfc7914/)

`custom_password_hash`を提供する際には、以下のセクションを考慮してください。

#### Argon2

`algorithm`が`argon2`に設定されている場合には：

* `hash.encoding`は`utf8`でなければなりません。
* `hash.salt`は使用できません。
* `hash.value`は、GitHubの[P-H-C / phc-string-format](https://github.com/P-H-C/phc-string-format/blob/master/phc-sf-spec.md)で指定されているように、PHC文字列形式でなければなりませんまた、GitHubの[Auth0 / magic](https://github.com/auth0/magic#magicpasswordhash--magicverifypassword)で指定されている要件に従う必要があります。
* `hash.value`にはbase64エンコードされたソルトが含まれなければなりません（`PHC`のドキュメントで指定されています）。

#### bcrypt

`algorithm`が`bcrypt`に設定されている場合には：

* `hash.encoding`は`utf8`でなければなりません。
* `hash.salt`は使用できません。
* `hash.value`には以下の1つのプレフィックスが含まれなければなりません。

  + `$2a$`
  + `$2b$`
  + `$2y$`

  `$2$`、`$sha1$`や`$2x$`など、他のプレフィックスには現在対応していません。

たとえば、次はコストパラメーターの値を10に指定して「`hello`」の文字列から生成したものです：

`$2b$10$nFguVi9LsCAcvTZFKQlRKeLVydo8ETv483lkNsSFI/Wl1Rz1Ypo1K`

`algorithm`が`hmac`に設定されている場合には：

`algorithm`が`ldap`に設定されている場合には：

#### HMAC

`algorithm`が`md4`、`md5`、`sha1`、`sha256`、または`sha512`に設定されている場合には：

* `hash.encoding`は`hex`または`base64`でなければなりません。
* `hash.digest`は必須で、以下のいずれかでなければなりません。

  + `md4`
  + `md5`
  + `ripemd160`
  + `sha1`
  + `sha224`
  + `sha256`
  + `sha384`
  + `sha512`
  + `whirlpool`
* `hash.key.value`は必須です。
* `hash.key.encoding`は`base64`、`hex`、または`utf8`でなければなりません。

#### LDAP

`algorithm`が`pbkdf2`に設定されている場合には：

* `hash.encoding`は`utf8`でなければなりません。
* `salt`は使用できません。
* `hash.value`では、IETF Datatrackerに掲載の[RFC-2307セクション5.3](https://tools.ietf.org/html/rfc2307#section-5.3)で説明されている形式を厳守する必要があります。
* スキーマは`md5|smd5|sha*|ssha*`のいずれかになります。詳細については[こちら](https://www.openldap.org/faq/data/cache/347.html)を参照してください。
* [crypt](https://www.openldap.org/faq/data/cache/344.html)スキーマは、動作がシステムや実装に依存するため、**非対応** であることに注意してください。詳細については、[Open LDAPが提供するAdmin Guideの「4.4.2.CRYPT password storage scheme」](https://www.openldap.org/doc/admin24/guide.html#CRYPT%20password%20storage%20scheme)をお読みください。

#### MDおよびSHA

`algorithm`が`scrypt`に設定されている場合には：

* `hash.encoding`は`hex`または`base64`でなければなりません。

#### PBKDF2

`user.mfa_factors`配列には、ユーザーの<Tooltip data-tooltip-id="react-containers-DefinitionTooltip-0" href="/docs/ja-jp/glossary?term=multifactor-authentication" tip="多要素認証（MFA）: ユーザー名とパスワードに加えて、SMS経由のコードなどの要素を使用するユーザー認証プロセス。" cta="用語集の表示">MFA</Tooltip>登録が含まれます。詳細については、「[Auth0での多要素認証](/docs/ja-jp/secure/multi-factor-authentication)」をお読みください。登録をインポートすると、インポート後にユーザーがMFAに再登録する必要がなくなります。以下の登録タイプに対応しています。

* `hash.encoding`は`utf8`でなければなりません。
* `hash.salt`は使用できません。
* `hash.value`は、GitHubの[P-H-C / phc-string-format](https://github.com/P-H-C/phc-string-format/blob/master/phc-sf-spec.md)で指定されているように、PHC文字列形式でなければなりません
* `hash.value`にはB64エンコードされたソルトが含まれなければなりません（埋め込み文字「`=`」を省略したbase64で、`PHC`のドキュメントで指定されています）。
* `hash.value`には、`i`（iterations）と`l`（keylen）パラメーターが含まれなければなりません。これらのパラメーターを省略すると、デフォルトの`i=100000`および`l=64`が使用されます。
* `id`は`pbkdf2-<digest>`形式（`pbkdf2-sha512`、`pbkdf2-md5`など）でなければなりません。以下のダイジェストに対応しています。

  + `RSA-MD4`
  + `RSA-MD5`
  + `RSA-MDC2`
  + `RSA-RIPEMD160`
  + `RSA-SHA1`
  + `RSA-SHA1-2`
  + `RSA-SHA224`
  + `RSA-SHA256`
  + `RSA-SHA384`
  + `RSA-SHA512`
  + `md4`
  + `md4WithRSAEncryption`
  + `md5`
  + `md5WithRSAEncryption`
  + `mdc2`
  + `mdc2WithRSA`
  + `ripemd`
  + `ripemd160`
  + `ripemd160WithRSA`
  + `rmd160`
  + `sha1`
  + `sha1WithRSAEncryption`
  + `sha224`
  + `sha224WithRSAEncryption`
  + `sha256`
  + `sha256WithRSAEncryption`
  + `sha384`
  + `sha384WithRSAEncryption`
  + `sha512`
  + `sha512WithRSAEncryption`
  + `ssl3-md5`
  + `ssl3-sha1`
  + `whirlpool`

#### scrypt

<table class="table"><thead>
<tr>
<th>プロパティ</th>
<th>タイプ</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td>`email`</td>
<td>オブジェクト</td>
<td></td>
</tr>
<tr>
<td>`email.value`</td>
<td>文字列</td>
<td>MFAのメールアドレス。</td>
</tr>
<tr>
<td>`phone`</td>
<td>オブジェクト</td>
<td></td>
</tr>
<tr>
<td>`phone.value`</td>
<td>文字列</td>
<td>SMS MFAの電話番号。国コードがあり、先頭が`+`でなければなりません。例：`"+12125550001"`</td>
</tr>
<tr>
<td>`totp`</td>
<td>オブジェクト</td>
<td></td>
</tr>
<tr>
<td>`totp.secret`</td>
<td>文字列</td>
<td>Authenticatorアプリ（Google Authenticator、Microsoft Authenticator、Authy、1Password, LastPass）を使ったMFA認証のOTPシークレット。パッドなしのBase32エンコーディングで指定する必要があります。例： `"JBTWY3DPEHPK3PNP"`</td>
</tr>
</tbody>
</table>

* `hash.encoding`は`hex`または`base64`でなければなりません。
* `keylen`パラメーターは必須です。
* `cost`パラメーターを使用することができます。指定しない場合には、デフォルトの16384が使用されます。
* `blockSize`パラメーターを使用することができます。指定しない場合には、デフォルトの8が使用されます。
* `parallelization`パラメーターを使用することができます。指定しない場合には、デフォルトの1が使用されます。

### MFA要素

以下の内容のあるファイルが有効です。

```json lines
[
  {
    "email": "john.doe@contoso.com",
    "email_verified": false,
    "app_metadata": {
        "roles": ["admin"],
        "plan": "premium"
    },
    "user_metadata": {
        "theme": "light"
    }
  }
]
```

## 例

### 基本例

以下は、提供されたハッシュのあるユーザーの例です。

```json lines
[
    {
        "email": "antoinette@contoso.com",
        "email_verified": false,
        "custom_password_hash": {
            "algorithm": "md4",
            "hash": {
                "value": "AbuUujgF0pPPkJPSFRTpmA==",
                "encoding": "base64"
            }
        }
    },
    {
        "email": "mary@contoso.com",
        "email_verified": false,
        "custom_password_hash": {
            "algorithm": "sha256",
            "hash": {
                "value": "d24e794fce503c3ddb1cd1ba1dd5d9b250cf9917336a0316fefd87fecf79200f",
                "encoding": "hex"
            },
            "salt": {
                "value": "abc123",
                "position": "prefix"
            }
        }
    },
    {
        "email": "velma@contoso.com",
        "email_verified": false,
        "custom_password_hash": {
            "algorithm": "bcrypt",
            "hash": {
                "value": "$2b$10$C9hB01.YxRSTcn/ZOOo4j.TW7xCKKFKBSF.C7E0xiUwumqIDqWUXG"
            }
        }
    },
    {
        "email": "edward@contoso.com",
        "email_verified": false,
        "custom_password_hash": {
            "algorithm": "argon2",
            "hash": {
                "value": "$argon2id$v=19$m=65536,t=2,p=1$J6Q/82PCyaNpYKRELJyTZg$m04qUAB8rexWDR4+/0f+SFB+4XMFxt7YAvAq2UycYos"
            }
        }
    },
    {
        "email": "terrell@contoso.com",
        "email_verified": false,
        "custom_password_hash": {
            "algorithm": "pbkdf2",
            "hash": {
                "value": "$pbkdf2-md4$i=100000,l=64$+N375B8q0Fw$fp2R9KAM4hK/votGHC5Fu+jhqbxUD8+Nic/EMSGvNC3UP/k7wSHI0uXluHRSkZfl/BOheYqNOemayG90ZaSSQw",
                "encoding": "utf8"
            }
        }
    },
    {
        "email": "cecil@contoso.com",
        "email_verified": false,
        "custom_password_hash": {
            "algorithm": "pbkdf2",
            "hash": {
                "value": "$pbkdf2-sha512$i=100000,l=64$KNyFsA2rWoE$I2CQGI9H0JxdDf3kERRI97kPCGxh0KWBIV3MxyaS191gDGfzVBGyS4BibhgqWQ0/ails8mHuU9ckASxHOOq58w"
            }
        }
    },
    {
        "email": "sean@contoso.com",
        "email_verified": false,
        "custom_password_hash": {
            "algorithm": "ldap",
            "hash": {
                "value": "{SSHA384}/cgEjdoZh85DhurDeOQEMO1rMlAur93SVPbYe5XSD4lF7nNuvrBju5hUeg9A6agRemgSXGl5YuE=",
                "encoding": "utf8"
            }
        }
    },
    {
        "email": "peter@contoso.com",
        "email_verified": false,
        "custom_password_hash": {
            "algorithm": "hmac",
            "hash": {
                "value": "cg7f42jH39/2EaAU4wNd4s2lKIk=",
                "encoding": "base64",
                "digest": "sha1",
                "key": {
                    "value": "736868",
                    "encoding": "hex"
                }
            }
        }
    },
    {
        "email": "carmella@contoso.com",
        "email_verified": false,
        "custom_password_hash": {
            "algorithm": "scrypt",
            "hash": {
                "value": "097f6197e1b41538f723e32aa7a68e8d76227d8e432ce5faa4882a913032db29",
                "encoding": "hex"
            },
            "salt": {
                "value": "abc123",
                "encoding": "utf8"
            },
            "keylen": 32,
            "cost": 4096
        }
    }
]
```

### カスタムパスワードハッシュの例

ご推察のとおり、`user.mfa_factors`配列は、ユーザーのMFA登録を提供できるようにします。以下の登録タイプに対応しています。

以下は、MFA要素のあるユーザーの例です。

### MFA要素の例

```json lines
[
    {
        "email": "antoinette@contoso.com",
        "mfa_factors": [
            {
                "totp": {
                    "secret": "2PRXZWZAYYDAWCD"
                }
            },
            {
                "phone": {
                    "value": "+15551112233"
                }
            },
            {
                "email": {
                    "value": "antoinette@antoinette.biz"
                }
            }
        ]
    },
    {
        "email": "mary@contoso.com",
        "mfa_factors": [
            {
                "totp": {
                    "secret": "JBTWY3DPEHPK3PNP"
                }
            }
        ]
    },
    {
        "email": "velma@contoso.com",
        "mfa_factors": [
            {
                "phone": {
                    "value": "+15551234567"
                }
            },
        ]
    },
    {
        "email": "edward@contoso.com",
        "mfa_factors": [
            {
                "email": {
                    "value": "edward@edward.biz"
                }
            }
        ]
    }
]
```

* 電話：SMSベースの検証に使用されます。
* TOTP：MFAタイプのアプリ（Google Authenticator、Microsoft Authenticator、Authy、1Password、LastPass）で使用するOTPシークレットです。
* メール：メールベースの検証に使用されます。

以下は、MFA要素のあるユーザーの例です。

```json lines
[
    {
        "email": "antoinette@contoso.com",
        "mfa_factors": [
            {
                "totp": {
                    "secret": "2PRXZWZAYYDAWCD"
                }
            },
            {
                "phone": {
                    "value": "+15551112233"
                }
            },
            {
                "email": {
                    "value": "antoinette@antoinette.biz"
                }
            }
        ]
    },
    {
        "email": "mary@contoso.com",
        "mfa_factors": [
            {
                "totp": {
                    "secret": "JBTWY3DPEHPK3PNP"
                }
            }
        ]
    },
    {
        "email": "velma@contoso.com",
        "mfa_factors": [
            {
                "phone": {
                    "value": "+15551234567"
                }
            },
        ]
    },
    {
        "email": "edward@contoso.com",
        "mfa_factors": [
            {
                "email": {
                    "value": "edward@edward.biz"
                }
            }
        ]
    }
]
```

## もっと詳しく

* [一括ユーザーインポート](/docs/ja-jp/manage-users/user-migration/bulk-user-imports)
* [一括ユーザーエクスポート](/docs/ja-jp/manage-users/user-migration/bulk-user-exports)
* [データベースからの自動移行を構成する](/docs/ja-jp/manage-users/user-migration/configure-automatic-migration-from-your-database)