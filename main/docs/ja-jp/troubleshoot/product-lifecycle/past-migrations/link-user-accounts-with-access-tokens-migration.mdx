---
title: "アカウントリンクに向けてアクセストークンに移行する"
permalink: "link-user-accounts-with-access-tokens-migration"
'description': "ユーザーアカウントをリンクするに当たり、IDトークンの使用からアクセストークンの使用へ移行する方法を説明します。"
'og:title': "アカウントリンクに向けてアクセストークンに移行する"
'og:description': "ユーザーアカウントをリンクするに当たり、IDトークンの使用からアクセストークンの使用へ移行する方法を説明します。"
'og:image': "https://cdn2.auth0.com/docs/1.14567.0/img/share-image.png"
'twitter:title': "アカウントリンクに向けてアクセストークンに移行する"
'twitter:description': "ユーザーアカウントをリンクするに当たり、IDトークンの使用からアクセストークンの使用へ移行する方法を説明します。"
---
import {AuthCodeBlock} from "/snippets/AuthCodeBlock.jsx";

import {AuthCodeGroup} from "/snippets/AuthCodeGroup.jsx";

export const codeExample1 = `https://{yourDomain}/authorize?
  scope=openid
  &response_type=id_token
  &client_id={yourClientId}
  &redirect_uri=https://{yourApp}/callback
  &nonce=NONCE
  &state=OPAQUE_VALUE
`;

export const codeExample2 = `https://{yourDomain}/authorize?
  audience=https://{yourDomain}/api/v2/
  &scope=update:current_user_identities
  &response_type=token%20id_token
  &client_id={yourClientId}
  &redirect_uri=https://{yourApp}/callback
  &nonce={nonce}
  &state={opaqueValue}`;

export const codeExample3 = `{
  "method": "POST",
  "url": "https://{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities",
  "httpVersion": "HTTP/1.1",
  "headers": [
    {
      "name": "Authorization",
      "value": "Bearer ACCESS_TOKEN"
    },
    {
      "name": "content-type",
      "value": "application/json"
    }
  ],
  "postData" : {
    "mimeType": "application/json",
    "text": "{\\"link_with\\":\\"SECONDARY_ACCOUNT_ID_TOKEN\\"}"
  }
}`;

export const codeExample4 = `// get an ID Token
var webAuth = new auth0.WebAuth({
  clientID: '{yourClientId}',
  domain: '{yourDomain}',
  redirectUri: 'https://{yourApp}/callback',
  scope: 'openid',
  responseType: 'id_token'
});
// create a new instance
var auth0Manage = new auth0.Management({
  domain: '{yourDomain}',
  token: '{yourIdToken}'
});
`;

export const codeExample5 = `// get an Access Token
var webAuth = new auth0.WebAuth({
  clientID: '{yourClientId}',
  domain: '{yourDomain}',
  redirectUri: 'https://{yourApp}/callback',
  audience: 'https://{yourDomain}/api/v2/',
  scope: 'update:current_user_identities',
  responseType: 'token id_token'
});
// create a new instance
var auth0Manage = new auth0.Management({
  domain: '{yourDomain}',
  token: '{yourMgmtApiAccessToken}'
});
`;

export const codeExample16 = `https://{yourDomain}/authorize?
  scope=openid
  &response_type=id_token
  &client_id={yourClientId}
  &redirect_uri=https://{yourApp}/callback
  &nonce={nonce}
  &state={opaqueValue}
`;

export const codeExample17 = `https://{yourDomain}/authorize?
  audience=https://{yourDomain}/api/v2/
  &scope=update:current_user_identities
  &response_type=token%20id_token
  &client_id={yourClientId}
  &redirect_uri=https://{yourApp}/callback
  &nonce={nonce}
  &state={opaqueValue}
`;

export const codeExample18 = `DELETE https://{yourDomain}/api/v2/users/{primaryAccountUserId}/identities/{secondaryAccountProvider}/{secondaryAccountUserId}
  Authorization: 'Bearer {yourMgmtApiAccessToken}'
`;

以前は、一部のケースで、IDトークンを使ってユーザーアカウントのリンクやリンク解除ができました。この機能は、廃止されます。今後は、すべてのケースでアクセストークンを使う必要があります。

<Warning>

この廃止は潜在的なセキュリティ脆弱性に対応して行われます。できる限り早急にコードを更新することを強くお勧めします。

</Warning>

## 影響のある機能

アカウントリンクにおける変更点は以下のとおりです：

* `Authorization`ヘッダーでIDトークンを使用できなくなりました。代わりにアクセストークンを使用する必要があります。
* `Authorization`ヘッダーでアクセストークンを使用し、付与されたアクセス許可が`update:users`の場合、要求のボディにはセカンダリアカウントの`user_id`またはIDトークンのいずれかを送信できます。
* `Authorization`ヘッダーでアクセストークンを使用し、付与されたアクセス許可が`update:current_user_metadata`の場合、要求のボディにはセカンダリアカウントのIDトークンのみ送信できます。
* 要求の本文でセカンダリアカウントのIDトークンを送信する場合（上記2つのポイントで紹介したユースケース）、以下のような条件があります。

  + IDトークンは`RS256`を使用して署名される必要があります（この値は、**［Dashboard］>［Clients（クライアント）］>［Client Settings（クライアントの設定）］>［Advanced Settings（高度な設定）］>［OAuth］** から設定できます。
  + IDトークンの`aud`クレームは、クライアントを特定し、アクセストークンの`azp`クレームと同じ値でなければいけません。
* `Authorization`ヘッダーでアカウントのリンクを解除する目的です。代わりにアクセストークンを使用しなければなりません。

アカウントをリンクする方法、リンクを解除する方法はいくつかあります。次のリストで、ユースケースと変更が及ぼす影響を確認してください。

<table class="table"><thead>
<tr>
<th>ユースケース</th>
<th>ステータス</th>
</tr>
</thead>
<tbody>
<tr>
<td>Management APIの`POST /api/v2/users/{id}/identities`エンドポイントを使用し、プライマリアカウントのIDトークンを`Authorization`ヘッダーで送信する。</td>
<td>影響あり</td>
</tr>
<tr>
<td>Management APIの`POST /api/v2/users/{id}/identities`エンドポイントを使用し、（`update:users`スコープ付きの）アクセストークンを`authorization`ヘッダーで、セカンダリアカウントの`user_id`をペイロードとして送信する。</td>
<td>影響なし</td>
</tr>
<tr>
<td>Management APIの`POST /api/v2/users/{id}/identities`エンドポイントを使用し、（`update:current_user_identities`スコープ付きの）アクセストークンを`Authorization`ヘッダーで、セカンダリアカウントの`user_id`をペイロードとして送信する。</td>
<td>影響あり</td>
</tr>
<tr>
<td>Management APIの`POST /api/v2/users/{id}/identities`エンドポイントを使用し、アクセストークンを`Authorization`ヘッダーで、セカンダリアカウントのIDトークンをペイロードとして送信する。</td>
<td>新しいユースケース</td>
</tr>
<tr>
<td>`auth0.Management`のインスタンスを作成するために、auth0.jsライブラリーとプライマリアカウントのIDトークンを使用する。</td>
<td>影響あり</td>
</tr>
<tr>
<td>`auth0.Management`のインスタンスを作成するために、auth0.jsライブラリーと（`update:users`スコープ付きの）アクセストークンを使用する。</td>
<td>影響なし</td>
</tr>
<tr>
<td>`auth0.Management`のインスタンスを作成するために、auth0.jsライブラリーと（`update:current_user_identities`スコープ付きの）アクセストークンを使用する。</td>
<td>影響あり</td>
</tr>
<tr>
<td>Management APIの`DELETE /api/v2/users/{id}/identities/{provider}/{user_id}`エンドポイントを使用し、プライマリアカウントのIDトークンを`Authorization`ヘッダーで送信する。</td>
<td>影響あり</td>
</tr>
<tr>
<td>Management APIの`DELETE /api/v2/users/{id}/identities/{provider}/{user_id}`エンドポイントを使用し、アクセストークンを`Authorization`ヘッダーで送信する。</td>
<td>影響なし</td>
</tr>
</tbody>
</table>

## アクション

[IDエンドポイント](/docs/ja-jp/api/management/v2/#!/Users/post_identities)にリンクするアカウントへのすべての呼び出しを確認し、上記の脆弱なフローを利用する呼び出しを更新します。呼び出しを更新する方法には、次のようなものがあります。

* **クライアント側/ユーザー開始のリンクシナリオ:** クライアント側のリンク シナリオの場合、`update:current_user_identities`スコープのアクセス トークンを使用してIdentitiesエンドポイントへの呼び出しを行い、ペイロード（`link_with`）でセカンダリ アカウントの ID トークンを提供します。IDトークンは、<Tooltip data-tooltip-id="react-containers-DefinitionTooltip-0" href="/docs/ja-jp/glossary?term=oath2" tip="OAuth 2.0: 認可プロトコルとワークフローを定義する認可フレームワーク。" cta="用語集の表示">OAuth</Tooltip>/OIDC準拠のフローを通じて取得しなければなりません。
* **サーバー側リンクシナリオ** :サーバー側リンクシナリオの場合は、`update:users`スコープのアクセス トークンを使用してIdentitiesエンドポイントへの呼び出しを行い、ペイロードでセカンダリ アカウントの`user_id`を指定します。

詳細については、[ユーザーアカウントのリンク](/docs/ja-jp/manage-users/user-accounts/user-account-linking/link-user-accounts)を参照してください。

### ユーザーアカウントをリンクする

ユーザーアカウントをリンクするには、<Tooltip data-tooltip-id="react-containers-DefinitionTooltip-0" href="/docs/ja-jp/glossary?term=management-api" tip="Management API: 顧客が管理タスクを実行できるようにするための製品。" cta="用語集の表示">Management API</Tooltip>の[ユーザーアカウントのリンクエンドポイント](https://auth0.com/docs//api/management/v2#!/Users/post_identities)を呼び出すか、[Auth0.jsライブラリ](/docs/ja-jp/libraries/auth0js)を使用します。

#### Management APIで現在のユーザーアカウントをリンクする

一般的なユースケースは、ログインしたユーザーに、アプリを使ってのアカウントのリンクを許可する、というものです。

非推奨になる前は、プライマリユーザーのIDトークンまたはアクセストークン（`update:current_user_identities`スコープを含む) を使用してManagement APIで認証し、[ユーザーアカウントのリンクエンドポイント](https://auth0.com/docs/api/management/v2#!/Users/post_identities)を使用できました。

次に、アクセストークン（`update:current_user_identities`スコープを含む）を取得し、それを使用してAPIで認証し、ユーザーアカウントのリンクエンドポイントを使用する必要があります。ペイロードは、セカンダリユーザーのIDトークンでなければなりません。

1. 次の例に示すように、`update:current_user_identities`スコープでアクセストークンを取得します。この例では[暗黙的フロー](/docs/ja-jp/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post)を使用していますが、任意の種類のアプリケーションの[アクセストークンを取得](/docs/ja-jp/secure/tokens/access-tokens/get-access-tokens)できます。
2. 以前の、IDトークンを使う方法では、コードは次のようになります：

   <AuthCodeBlock children={codeExample1} language="http" lines />

   アクセストークンを使う新しい方法だと、コードは次のようになります：

   <AuthCodeBlock children={codeExample2} language="http" lines />

3. Management APIにアクセスできるアクセストークンを取得するには以下を行います。

   1. `audience`を`https://{yourDomain}/api/v2/`に設定する
   2. `スコープ``${scope}`を要求する
   3. `response_type`を`id_token token`に設定し、Auth0がIDトークンとアクセストークンの両方を送るようにするアクセストークンをデコードすると、次のような内容になります：

      ```json
      {
          "iss": "https://{yourDomain}/",
          "sub": "auth0|5a620d29a840170a9ef43672",
          "aud": "https://{yourDomain}/api/v2/",
          "iat": 1521031317,
          "exp": 1521038517,
          "azp": "{yourClientId}",
          "scope": "${scope}"
      }
      ```

      `aud`はテナントのAPI URI、`スコープ`は`${scope}`、`sub`はログインユーザーのユーザーIDに設定されています。
4. 次のような条件があります。

   1. セカンダリアカウントのIDトークンは`RS256`で署名されている必要があります。
   2. セカンダリアカウントのIDトークンの`aud`クレームはクライアントを識別し、要求の作成に使用されたアクセス トークンの`azp`クレームと同じ値を保持する必要があります。
5. アクセストークンを取得したら、それを使ってユーザーアカウントをリンクします。この部分は同じで、要求のうち、`Bearer`トークンとして使用する値を除き変更はありません。応答も同じです。

   <AuthCodeBlock children={codeExample3} language="json" />

#### auth0.jsを使って現在のユーザーアカウントをリンクする

[auth0.jsライブラリ](/docs/ja-jp/libraries/auth0js)を使用してManagement APIにアクセスし、アカウントをリンクする場合は、おそらくユーザーのプライマリ ID の ID トークンを使用して`auth0.Management`をインスタンス化し、それを使用してアカウントをリンクします。

1. `update:current_user_identities`スコープのアクセス トークンを取得し、このトークンを使用して `auth0.Management`をインスタンス化します。`linkUser`への最後の呼び出しは変わりません。
2. 以前の、IDトークンを使う方法では、コードは次のようになります：

   <AuthCodeBlock children={codeExample4} language="javascript" />

   アクセストークンを使う新しい方法だと、コードは次のようになります：

   <AuthCodeBlock children={codeExample5} language="javascript" />

   1. 応答でIDトークンとアクセストークンの両方を求めます（`responseType: `token id_token``）。
   2. Management APIを意図したトークンのオーディエンスとして設定します（`audience: `https://{yourDomain}/api/v2/``）。
   3. 必要な許可を要求します（`scope: `update:current_user_identities``）。
   4. アクセストークンを使ってManagement APIで認証します。

#### Management APIで任意のユーザーアカウントをリンクする

`update:users`スコープを含むアカウント リンク用のアクセス トークンを取得し、要求でセカンダリーアカウントの `user_id`と`プロバイダー`を送信する場合は、何も変更する必要はありません。

ただ、ここで紹介している新しいメソッドはその代わりになります。APIでの認証には引き続き`update:users`スコープを含むアクセストークンを使用しますが、要求のペイロードでセカンダリのアカウントIDトークンを（`user_id`および`プロバイダー`の代わりに）送信できます。

<AuthCodeGroup>
```bash cURL lines
curl --request POST \
  --url 'https://{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities' \
  --header 'authorization: Bearer ACCESS_TOKEN' \
  --header 'content-type: application/json' \
  --data '{"link_with":"SECONDARY_ACCOUNT_ID_TOKEN"}'
```
```csharp C# lines
var client = new RestClient("https://{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities");
var request = new RestRequest(Method.POST);
request.AddHeader("authorization", "Bearer ACCESS_TOKEN");
request.AddHeader("content-type", "application/json");
request.AddParameter("application/json", "{"link_with":"SECONDARY_ACCOUNT_ID_TOKEN"}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```
```go Go lines
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities"

	payload := strings.NewReader("{"link_with":"SECONDARY_ACCOUNT_ID_TOKEN"}")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("authorization", "Bearer ACCESS_TOKEN")
	req.Header.Add("content-type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java lines
HttpResponse<String> response = Unirest.post("https://{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities")
  .header("authorization", "Bearer ACCESS_TOKEN")
  .header("content-type", "application/json")
  .body("{"link_with":"SECONDARY_ACCOUNT_ID_TOKEN"}")
  .asString();
```
```javascript Node.JS lines
var axios = require("axios").default;

var options = {
  method: 'POST',
  url: 'https://{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities',
  headers: {authorization: 'Bearer ACCESS_TOKEN', 'content-type': 'application/json'},
  data: {link_with: 'SECONDARY_ACCOUNT_ID_TOKEN'}
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C lines
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"authorization": @"Bearer ACCESS_TOKEN",
                           @"content-type": @"application/json" };
NSDictionary *parameters = @{ @"link_with": @"SECONDARY_ACCOUNT_ID_TOKEN" };

NSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"POST"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```
```php PHP lines
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "POST",
  CURLOPT_POSTFIELDS => "{"link_with":"SECONDARY_ACCOUNT_ID_TOKEN"}",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer ACCESS_TOKEN",
    "content-type: application/json"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python lines
import http.client

conn = http.client.HTTPSConnection("")

payload = "{"link_with":"SECONDARY_ACCOUNT_ID_TOKEN"}"

headers = {
    'authorization': "Bearer ACCESS_TOKEN",
    'content-type': "application/json"
    }

conn.request("POST", "/{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities", payload, headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```
```ruby Ruby lines
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Post.new(url)
request["authorization"] = 'Bearer ACCESS_TOKEN'
request["content-type"] = 'application/json'
request.body = "{"link_with":"SECONDARY_ACCOUNT_ID_TOKEN"}"

response = http.request(request)
puts response.read_body
```
```swift Swift lines
import Foundation

let headers = [
  "authorization": "Bearer ACCESS_TOKEN",
  "content-type": "application/json"
]
let parameters = ["link_with": "SECONDARY_ACCOUNT_ID_TOKEN"] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</AuthCodeGroup>

次のような条件があります。

* セカンダリアカウントのIDトークンは`RS256`で署名されている必要があります。
* セカンダリアカウントのIDトークンの`aud`クレームはクライアントを識別し、要求の作成に使用されたアクセス トークンの`azp`クレームと同じ値を保持する必要があります。

### ユーザーアカウントのリンクを解除する

IDトークンを使ってアカウントのリンクを解除するには、アクセストークンを使うようコードを更新しなければなりません。

1. まず、`update:current_user_identities`スコープのアクセストークンを取得する必要があります。
2. 以前の、IDトークンを使う方法では、コードは次のようになります：

   <AuthCodeBlock children={codeExample16} language="text" lines />

   アクセストークンを使う新しい方法だと、コードは次のようになります：

   <AuthCodeBlock children={codeExample17} language="text" lines />
   
3. Management APIにアクセスできるアクセストークンを取得するには以下を行います。

   1. `audience`を`https://{yourDomain}/api/v2/`に設定する
   2. `スコープ``${scope}`を要求する
   3. `response_type`を`id_token token`に設定し、Auth0がIDトークンとアクセストークンの両方を送るようにするアクセストークンをデコードすると、次のような内容になります：

      ```json
      {
          "iss": "https://{yourDomain}/",
          "sub": "auth0|5a620d29a840170a9ef43672",
          "aud": "https://{yourDomain}/api/v2/",
          "iat": 1521031317,
          "exp": 1521038517,
          "azp": "{yourClientId}",
          "scope": "update:current_user_identities"
      }
      ```

      `aud`はテナントのAPI URI、`スコープ`は`update:current_user_identities`、`sub`はログインユーザーのユーザーIDに設定されています。
4. アクセストークンを取得したら、`Authorization`ヘッダーでそれを使用して、Management API の[ユーザーIDエンドポイントのリンク解除](https://auth0.com/docs/api/management/v2#!/Users/delete_user_identity_by_user_id)を呼び出すことができます。
5. 以前の方法では、呼び出しは次のようになります：

   ```http lines
   DELETE https://YOUR_DOMAIN/api/v2/users/{primaryAccountUserId}/identities/{secondaryAccountProvider}/{secondaryAccountUserId}
       Authorization: 'Bearer {yourIdTokenOrMgmtApiAccessToken}'
   ```

   新しい方法では、呼び出しは次のようになります：

   <AuthCodeBlock children={codeExample18} language="http" lines />

## セキュリティに関する考慮事項

ある特定のアカウントリンクフローに、特殊な状況において悪用される可能性のある弱点が見つかりました。実際に悪用された証拠はありませんが、予防策としてこのフローを廃止することが決まりましたので、

当該のアカウントリンクフローを使用している方は、2018年10月19日までに安全な実装へと移行するようお願いしています。このガイドでご紹介している移行パスをご利用いただけば、どの機能も失われません。

2018年10月19日以降、当該のアカウントリンクフローは無効になり、ランタイムエラーが生じます。

Authorizationヘッダーにスコープ`update:current_user_identities`を含むトークン（IDまたはアクセストークン）を使用して[Post Identitiesエンドポイント](https://auth0.com/docs/api/management/v2#!/Users/post_identities)を呼び出し、ペイロードにセカンダリアカウントの`user_id`を含めると、影響を受けます。その他のユースケースは影響を受けません。

## もっと詳しく

* [アクセストークンを使用するManagement APIエンドポイントに移行する](/docs/ja-jp/troubleshoot/product-lifecycle/past-migrations/migrate-to-calling-api-with-access-tokens)