---
description: Learn how to configure and implement multi-resource refresh token
'og:image': https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
'og:title': Configure and Implement Multi-Resource Refresh Token
'og:url': https://auth0.com/docs/
permalink: configure-and-implement-multi-resource-refresh-token
title: Configure and Implement Multi-Resource Refresh Token
'twitter:description': Learn how to configure and implement multi-resource refresh
  token
'twitter:title': Configure and Implement Multi-Resource Refresh Token
---
<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

Multi-Resource Refresh Token support is currently available in Early Access. To learn more about Auth0's product release cycle, review [Product Release Stages](/docs/troubleshoot/product-lifecycle/product-release-stages).

</Callout>

## Configure applications for MRRT

To use Multi-Resource <Tooltip tip="Refresh Token: Token used to obtain a renewed Access Token without forcing users to log in again." cta="View Glossary" href="/docs/glossary?term=Refresh+Tokens">Refresh Tokens</Tooltip> (MRRT), configure your application’s refresh token policies using the Auth0 [Management API](https://auth0.com/docs/api/management/v2/clients/patch-clients-by-id). These policies will specify which API and scopes the application is allowed to request during a refresh token exchange.

You can define MRRT policies in the `refresh_token.policies` property of the application.

<table class="table"><thead>
<tr>
<th><strong>Property</strong></th>
<th><strong>Type</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>audience</code></td>
<td>string</td>
<td>The Auth0 API <a href="/docs/get-started/apis/api-settings#general-settings">identifier</a> of the application that will have access to using the refresh token.</td>
</tr>
<tr>
<td><code>scope</code></td>
<td>Array of strings</td>
<td>The list of scopes allowed when requesting an access token for the specified audience. The scope must be equal to or narrower than the scopes defined on the API.</td>
</tr>
</tbody>
</table>

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

The audience and scope properties must correspond to an existing application in your tenant, otherwise the refresh token exchange will silently ignore them.

</Callout>

For existing applications, make a PATCH call to the [Update a Client](https://auth0.com/docs/api/management/v2/clients/patch-clients-by-id) endpoint. To create a new application, make a POST call to the [Create a Client](https://auth0.com/docs/api/management/v2/clients/post-clients) endpoint:

<CodeGroup>
```bash cURL lines
curl --request PATCH \
  --url 'https://{yourDomain}/api/v2/clients//{yourClientId}' \
  --header 'authorization: Bearer {yourMgmtApiAccessToken}' \
  --header 'content-type: application/json' \
  --data '{
  "refresh_token": {
    "expiration_type": "expiring",
    "rotation_type": "rotating",
    "token_lifetime": 31557600,
    "idle_token_lifetime": 2592000,
    "leeway": 0,
    "infinite_token_lifetime": false,
    "infinite_idle_token_lifetime": false,
    "policies": [
      {
        "audience": "https://api.example.com",
        "scope": ["read:data"]
      },
      {
        "audience": "https://billing.example.com",
        "scope": ["read:billing"]
      }
    ]
  }
}'
```
```csharp C# lines
var client = new RestClient("https://{yourDomain}/api/v2/clients//{yourClientId}");
var request = new RestRequest(Method.PATCH);
request.AddHeader("authorization", "Bearer {yourMgmtApiAccessToken}");
request.AddHeader("content-type", "application/json");
request.AddParameter("application/json", "{\n  \"refresh_token\": {\n    \"expiration_type\": \"expiring\",\n    \"rotation_type\": \"rotating\",\n    \"token_lifetime\": 31557600,\n    \"idle_token_lifetime\": 2592000,\n    \"leeway\": 0,\n    \"infinite_token_lifetime\": false,\n    \"infinite_idle_token_lifetime\": false,\n    \"policies\": [\n      {\n        \"audience\": \"https://api.example.com\",\n        \"scope\": [\"read:data\"]\n      },\n      {\n        \"audience\": \"https://billing.example.com\",\n        \"scope\": [\"read:billing\"]\n      }\n    ]\n  }\n}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```go Go lines expandable
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/api/v2/clients//{yourClientId}"

	payload := strings.NewReader("{\n  \"refresh_token\": {\n    \"expiration_type\": \"expiring\",\n    \"rotation_type\": \"rotating\",\n    \"token_lifetime\": 31557600,\n    \"idle_token_lifetime\": 2592000,\n    \"leeway\": 0,\n    \"infinite_token_lifetime\": false,\n    \"infinite_idle_token_lifetime\": false,\n    \"policies\": [\n      {\n        \"audience\": \"https://api.example.com\",\n        \"scope\": [\"read:data\"]\n      },\n      {\n        \"audience\": \"https://billing.example.com\",\n        \"scope\": [\"read:billing\"]\n      }\n    ]\n  }\n}")

	req, _ := http.NewRequest("PATCH", url, payload)

	req.Header.Add("authorization", "Bearer {yourMgmtApiAccessToken}")
	req.Header.Add("content-type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java lines
HttpResponse<String> response = Unirest.patch("https://{yourDomain}/api/v2/clients//{yourClientId}")
  .header("authorization", "Bearer {yourMgmtApiAccessToken}")
  .header("content-type", "application/json")
  .body("{\n  \"refresh_token\": {\n    \"expiration_type\": \"expiring\",\n    \"rotation_type\": \"rotating\",\n    \"token_lifetime\": 31557600,\n    \"idle_token_lifetime\": 2592000,\n    \"leeway\": 0,\n    \"infinite_token_lifetime\": false,\n    \"infinite_idle_token_lifetime\": false,\n    \"policies\": [\n      {\n        \"audience\": \"https://api.example.com\",\n        \"scope\": [\"read:data\"]\n      },\n      {\n        \"audience\": \"https://billing.example.com\",\n        \"scope\": [\"read:billing\"]\n      }\n    ]\n  }\n}")
  .asString();
```

```javascript Node.JS lines expandable
var axios = require("axios").default;

var options = {
  method: 'PATCH',
  url: 'https://{yourDomain}/api/v2/clients//{yourClientId}',
  headers: {
    authorization: 'Bearer {yourMgmtApiAccessToken}',
    'content-type': 'application/json'
  },
  data: {
    refresh_token: {
      expiration_type: 'expiring',
      rotation_type: 'rotating',
      token_lifetime: 31557600,
      idle_token_lifetime: 2592000,
      leeway: 0,
      infinite_token_lifetime: false,
      infinite_idle_token_lifetime: false,
      policies: [
        {audience: 'https://api.example.com', scope: ['read:data']},
        {audience: 'https://billing.example.com', scope: ['read:billing']}
      ]
    }
  }
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C lines expandable
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"authorization": @"Bearer {yourMgmtApiAccessToken}",
                           @"content-type": @"application/json" };
NSDictionary *parameters = @{ @"refresh_token": @{ @"expiration_type": @"expiring", @"rotation_type": @"rotating", @"token_lifetime": @31557600, @"idle_token_lifetime": @2592000, @"leeway": @0, @"infinite_token_lifetime": @NO, @"infinite_idle_token_lifetime": @NO, @"policies": @[ @{ @"audience": @"https://api.example.com", @"scope": @[ @"read:data" ] }, @{ @"audience": @"https://billing.example.com", @"scope": @[ @"read:billing" ] } ] } };

NSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/api/v2/clients//{yourClientId}"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"PATCH"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```

```php PHP lines expandable
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/api/v2/clients//{yourClientId}",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "PATCH",
  CURLOPT_POSTFIELDS => "{\n  \"refresh_token\": {\n    \"expiration_type\": \"expiring\",\n    \"rotation_type\": \"rotating\",\n    \"token_lifetime\": 31557600,\n    \"idle_token_lifetime\": 2592000,\n    \"leeway\": 0,\n    \"infinite_token_lifetime\": false,\n    \"infinite_idle_token_lifetime\": false,\n    \"policies\": [\n      {\n        \"audience\": \"https://api.example.com\",\n        \"scope\": [\"read:data\"]\n      },\n      {\n        \"audience\": \"https://billing.example.com\",\n        \"scope\": [\"read:billing\"]\n      }\n    ]\n  }\n}",
  CURLOPT_HTTPHEADER => [
    "authorization: Bearer {yourMgmtApiAccessToken}",
    "content-type: application/json"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python lines
import http.client

conn = http.client.HTTPSConnection("")

payload = "{\n  \"refresh_token\": {\n    \"expiration_type\": \"expiring\",\n    \"rotation_type\": \"rotating\",\n    \"token_lifetime\": 31557600,\n    \"idle_token_lifetime\": 2592000,\n    \"leeway\": 0,\n    \"infinite_token_lifetime\": false,\n    \"infinite_idle_token_lifetime\": false,\n    \"policies\": [\n      {\n        \"audience\": \"https://api.example.com\",\n        \"scope\": [\"read:data\"]\n      },\n      {\n        \"audience\": \"https://billing.example.com\",\n        \"scope\": [\"read:billing\"]\n      }\n    ]\n  }\n}"

headers = {
    'authorization': "Bearer {yourMgmtApiAccessToken}",
    'content-type': "application/json"
    }

conn.request("PATCH", "/{yourDomain}/api/v2/clients//{yourClientId}", payload, headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```

```ruby Ruby lines
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/api/v2/clients//{yourClientId}")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Patch.new(url)
request["authorization"] = 'Bearer {yourMgmtApiAccessToken}'
request["content-type"] = 'application/json'
request.body = "{\n  \"refresh_token\": {\n    \"expiration_type\": \"expiring\",\n    \"rotation_type\": \"rotating\",\n    \"token_lifetime\": 31557600,\n    \"idle_token_lifetime\": 2592000,\n    \"leeway\": 0,\n    \"infinite_token_lifetime\": false,\n    \"infinite_idle_token_lifetime\": false,\n    \"policies\": [\n      {\n        \"audience\": \"https://api.example.com\",\n        \"scope\": [\"read:data\"]\n      },\n      {\n        \"audience\": \"https://billing.example.com\",\n        \"scope\": [\"read:billing\"]\n      }\n    ]\n  }\n}"

response = http.request(request)
puts response.read_body
```
```swift Swift lines expandable
import Foundation

let headers = [
  "authorization": "Bearer {yourMgmtApiAccessToken}",
  "content-type": "application/json"
]
let parameters = ["refresh_token": [
    "expiration_type": "expiring",
    "rotation_type": "rotating",
    "token_lifetime": 31557600,
    "idle_token_lifetime": 2592000,
    "leeway": 0,
    "infinite_token_lifetime": false,
    "infinite_idle_token_lifetime": false,
    "policies": [
      [
        "audience": "https://api.example.com",
        "scope": ["read:data"]
      ],
      [
        "audience": "https://billing.example.com",
        "scope": ["read:billing"]
      ]
    ]
  ]] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/api/v2/clients//{yourClientId}")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "PATCH"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</CodeGroup>

Sample response:

```json lines
{
  "client_id": "abc123xyz",
  "name": "My Native App",
  "refresh_token": {
    "rotation_type": "rotating",
    "policies": [
      {
        "audience": "https://api.example.com",
        "scope": ["read:data"]
      },
      {
        "audience": "https://billing.example.com",
        "scope": ["read:billing"]
      }
    ]
  }
}
```






## Implement multi-resource refresh token

Once you configure your application’s refresh token with MRRT policies, you can start to  exchange a single refresh token for <Tooltip tip="Access Token: Authorization credential, in the form of an opaque string or JWT, used to access an API." cta="View Glossary" href="/docs/glossary?term=access+tokens">access tokens</Tooltip> across multiple APIs.
To facilitate this, your application needs to initiate a login flow using either the [Authorization Code Flow](/docs/get-started/authentication-and-authorization-flow/authorization-code-flow) or the [Resource Owner Password Grant](/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-rop-flow).

### Step 1: Authenticate and request a refresh token

To receive a refresh token, include the `offline_access` scope when initiating the authentication request. To learn more, read [Get Refresh Tokens](/docs/secure/tokens/refresh-tokens/get-refresh-tokens).

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

If you do not receive a refresh token, confirm that:

* The API has [Allow Offline Access](/docs/get-started/apis/api-settings#access-settings) enabled in its settings.
* `offline_access` is included in the scope.
* The `audience` used in the request matches a configured API in your tenant.

</Callout>

### Step 2: Exchange the refresh token for a different API

Once the refresh token is issued, you can request access tokens for any API and scopes defined in both the initial authentication and the MRRT policy. For example:

<CodeGroup>
```bash cURL lines
curl --request POST \
  --url 'https://{yourDomain}/oauth/token' \
  --header 'content-type: application/json' \
  --data '{
  "grant_type": "refresh_token",
  "client_id": "{yourClientId}",
  "refresh_token": "${refreshToken}",
  "audience": "https://billing.example.com",
  "scope": "read:billing write:billing"
}'
```
```csharp C# lines
var client = new RestClient("https://{yourDomain}/oauth/token");
var request = new RestRequest(Method.POST);
request.AddHeader("content-type", "application/json");
request.AddParameter("application/json", "{\n  \"grant_type\": \"refresh_token\",\n  \"client_id\": \"{yourClientId}\",\n  \"refresh_token\": \"${refreshToken}\",\n  \"audience\": \"https://billing.example.com\",\n  \"scope\": \"read:billing write:billing\"\n}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```go Go lines expandable
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io/ioutil"
)

func main() {

	url := "https://{yourDomain}/oauth/token"

	payload := strings.NewReader("{\n  \"grant_type\": \"refresh_token\",\n  \"client_id\": \"{yourClientId}\",\n  \"refresh_token\": \"${refreshToken}\",\n  \"audience\": \"https://billing.example.com\",\n  \"scope\": \"read:billing write:billing\"\n}")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("content-type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```
```java Java lines
HttpResponse<String> response = Unirest.post("https://{yourDomain}/oauth/token")
  .header("content-type", "application/json")
  .body("{\n  \"grant_type\": \"refresh_token\",\n  \"client_id\": \"{yourClientId}\",\n  \"refresh_token\": \"${refreshToken}\",\n  \"audience\": \"https://billing.example.com\",\n  \"scope\": \"read:billing write:billing\"\n}")
  .asString();
```

```javascript Node.JS lines
var axios = require("axios").default;

var options = {
  method: 'POST',
  url: 'https://{yourDomain}/oauth/token',
  headers: {'content-type': 'application/json'},
  data: {
    grant_type: 'refresh_token',
    client_id: '{yourClientId}',
    refresh_token: '${refreshToken}',
    audience: 'https://billing.example.com',
    scope: 'read:billing write:billing'
  }
};

axios.request(options).then(function (response) {
  console.log(response.data);
}).catch(function (error) {
  console.error(error);
});
```
```obj-c Obj-C lines expandable
#import <Foundation/Foundation.h>

NSDictionary *headers = @{ @"content-type": @"application/json" };
NSDictionary *parameters = @{ @"grant_type": @"refresh_token",
                              @"client_id": @"{yourClientId}",
                              @"refresh_token": @"${refreshToken}",
                              @"audience": @"https://billing.example.com",
                              @"scope": @"read:billing write:billing" };

NSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://{yourDomain}/oauth/token"]
                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy
                                                   timeoutInterval:10.0];
[request setHTTPMethod:@"POST"];
[request setAllHTTPHeaderFields:headers];
[request setHTTPBody:postData];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request
                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                                                if (error) {
                                                    NSLog(@"%@", error);
                                                } else {
                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
                                                    NSLog(@"%@", httpResponse);
                                                }
                                            }];
[dataTask resume];
```

```php PHP lines expandable
$curl = curl_init();

curl_setopt_array($curl, [
  CURLOPT_URL => "https://{yourDomain}/oauth/token",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_ENCODING => "",
  CURLOPT_MAXREDIRS => 10,
  CURLOPT_TIMEOUT => 30,
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
  CURLOPT_CUSTOMREQUEST => "POST",
  CURLOPT_POSTFIELDS => "{\n  \"grant_type\": \"refresh_token\",\n  \"client_id\": \"{yourClientId}\",\n  \"refresh_token\": \"${refreshToken}\",\n  \"audience\": \"https://billing.example.com\",\n  \"scope\": \"read:billing write:billing\"\n}",
  CURLOPT_HTTPHEADER => [
    "content-type: application/json"
  ],
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}
```
```python Python lines
import http.client

conn = http.client.HTTPSConnection("")

payload = "{\n  \"grant_type\": \"refresh_token\",\n  \"client_id\": \"{yourClientId}\",\n  \"refresh_token\": \"${refreshToken}\",\n  \"audience\": \"https://billing.example.com\",\n  \"scope\": \"read:billing write:billing\"\n}"

headers = { 'content-type': "application/json" }

conn.request("POST", "/{yourDomain}/oauth/token", payload, headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
```

```ruby Ruby lines
require 'uri'
require 'net/http'
require 'openssl'

url = URI("https://{yourDomain}/oauth/token")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Post.new(url)
request["content-type"] = 'application/json'
request.body = "{\n  \"grant_type\": \"refresh_token\",\n  \"client_id\": \"{yourClientId}\",\n  \"refresh_token\": \"${refreshToken}\",\n  \"audience\": \"https://billing.example.com\",\n  \"scope\": \"read:billing write:billing\"\n}"

response = http.request(request)
puts response.read_body
```
```swift Swift lines expandable
import Foundation

let headers = ["content-type": "application/json"]
let parameters = [
  "grant_type": "refresh_token",
  "client_id": "{yourClientId}",
  "refresh_token": "${refreshToken}",
  "audience": "https://billing.example.com",
  "scope": "read:billing write:billing"
] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://{yourDomain}/oauth/token")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
</CodeGroup>

 To learn more, read [Use Refresh tokens](/docs/secure/tokens/refresh-tokens/use-refresh-tokens).

If you are using the Auth0 Swift SDK, you can exchange the refresh token using the following code:

```swift lines
credentialsManager.apiCredentials(forAudience: "https://example.com/me",
                                  scope: "create:me:authentication_methods") { result in
    switch result {
    case .success(let apiCredentials):
        print("Obtained API credentials: \(apiCredentials)")
    case .failure(let error):
        print("Failed with: \(error)")
    }
}
```






To learn more, read [Auth0 Swift SDK](https://github.com/auth0/Auth0.swift/blob/master/EXAMPLES.md#api-credentials-ea).

If you are using the Auth0 Android SDK, you can exchange the refresh token using the following code:

```swift lines
credentialsManager.getApiCredentials(
    audience = "https://example.com/me", scope = " create:me:authentication_methods",
    callback = object : Callback<APICredentials, CredentialsManagerException> {
        override fun onSuccess(result: APICredentials) {
            print("Obtained API credentials: $result")
        }
        override fun onFailure(error: CredentialsManagerException) {
            print("Failed with: $error")
        }
    })
```






To learn more, read [Auth0 Android SDK](https://github.com/auth0/Auth0.Android/blob/main/EXAMPLES.md#api-credentials-ea).

### Step 3: Call the API using the access token

Use the access token to call the secured API using the [Bearer HTTP authorization scheme](https://datatracker.ietf.org/doc/html/rfc6750). To learn more, read [Use Access Tokens](/docs/secure/tokens/access-tokens/use-access-tokens).

<Callout icon="file-lines" color="#0EA5E9" iconType="regular">

You can decode the access token on [jwt.io](https://jwt.io) to verify:

* The `aud` claim matches the requested API. (for example: https://billing.example.com).
* The `scope` claim includes only permitted values.

</Callout>

## Use Multi-resource refresh token with Actions

Using MRRT with [Actions](/docs/customize/actions) allows you to configure dynamic decision-making based on the application’s MRRT policies. To facilitate this, post-login Actions features the [`event.client.refresh_token.policies`](/docs/customize/actions/explore-triggers/signup-and-login-triggers/login-trigger/post-login-event-object) object that provides relevant information including <Tooltip tip="Audience: Unique identifier of the audience for an issued token. Named aud in a token, its value contains the ID of either an application (Client ID) for an ID Token or an API (API Identifier) for an Access Token." cta="View Glossary" href="/docs/glossary?term=audience">audience</Tooltip> and scope.

You can use the `event.client.refresh_token.policies` object to evaluate the application's audience and scope, when issuing or exchanging a refresh token, and to ensure precise control over API access and scopes.

```js lines
exports.onExecutePostLogin = async (event, api) => {
  // return the list of allowed APIs in the client
  const allowedAPIsInTheClient = event.client.refresh_token?.policies;

  if(allowedAPIsInTheClient?.some(policy => policy?.audience?.includes('https://myapi'))){
    // custom logic
  }
};
```






#### Evaluation logic

MRRT acts as an extension of the original authentication, not a replacement. When exchanging a refresh token, Auth0 evaluates the exchange request using the following logic:

* **If the audience parameter is omitted**, Auth0 returns an access token with the original audience and any of its additional scopes configured in the MRRT policy.
* **If a new audience parameter is specified**, Auth0 verifies that the audience is included in the MRRT policy and returns an access token for the new audience with its configured scopes.
* **If the scope parameter is omitted**, Auth0 combines all allowed scopes from the original request and the MRRT policy.
* **If a new scope parameter is specified**, Auth0 validates the requested scopes and returns an access token with the scopes included in the MRTT policy. Invalid or unauthorized scopes requested are silently ignored.
* **If the audience parameter is the same as from the original request**, Auth0 applies the MRRT policy and returns an access token for the audience with all MRRT configured scopes and original authentication scopes.

MRRT allows you to extend user access to new APIs without issuing new refresh tokens or requiring user login again.

#### Examples

A user logs in requesting the following audience and scope:

```json lines
{
"audience": "https://api.example.com",  
"scope": "openid profile read:messages"
}
```






The application’s MRRT policy is configured to add an additional scope:

```json lines
{
  "audience": "https://api.example.com",
  "scope": ["write:messages"]
}
```






A refresh token exchange using the same audience and no scopes would result in an access token containing all configured scopes:

```json lines
{
  "aud": "https://api.example.com",
  "scope": "openid profile read:messages write:messages"
}
```



