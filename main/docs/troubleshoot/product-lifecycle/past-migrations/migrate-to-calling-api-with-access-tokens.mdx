---
'og:description': Describes the deprecation of using ID tokens as credentials for
  the Management API and how to migrate your configuration to use access tokens.
'og:image': https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
'og:title': Migrate to Management API Endpoints with Access Tokens
'og:url': https://auth0.com/docs/
permalink: migrate-to-calling-api-with-access-tokens
title: Migrate to Management API Endpoints with Access Tokens
'twitter:description': Describes the deprecation of using ID tokens as credentials
  for the Management API and how to migrate your configuration to use access tokens.
'twitter:title': Migrate to Management API Endpoints with Access Tokens
---
Using <Tooltip tip="ID Token: Credential meant for the client itself, rather than for accessing a resource." cta="View Glossary" href="/docs/glossary?term=ID+tokens">ID tokens</Tooltip> to call <Tooltip tip="ID Token: Credential meant for the client itself, rather than for accessing a resource." cta="View Glossary" href="/docs/glossary?term=Management+API">Management API</Tooltip> endpoints is being deprecated. You must use <Tooltip tip="Management API: A product to allow customers to perform administrative tasks." cta="View Glossary" href="/docs/glossary?term=access+tokens">access tokens</Tooltip>. The grace period for this migration started on **March 31, 2018**.

After you complete your migration to access tokens, turn off the **Allow ID Tokens for Management API v2 Authentication** toggle in the Dashboard.

If you use ID tokens to call any of the following endpoints, then you are affected by this migration. These endpoints can now accept regular access tokens. Nothing else changes in how the endpoints work. You should expect the same request and response schemas and only need to update the token that you use for authorization.

## Endpoints affected

<table class="table"><thead>
<tr>
<th>Endpoint</th>
<th>Use Case</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET /api/v2/users/{id}</td>
<td>Retrieve a user's information</td>
</tr>
<tr>
<td>GET /api/v2/users/{id}/enrollments</td>
<td>Retrieve all Guardian MFA enrollments for a user</td>
</tr>
<tr>
<td>PATCH /api/v2/users/{id}</td>
<td>Update a user's information</td>
</tr>
<tr>
<td>DELETE /api/v2/users/{id}/multifactor/{provider}</td>
<td>Delete the MFA provider settings for a user</td>
</tr>
<tr>
<td>POST /api/v2/device-credentials</td>
<td>Create a public key for a device</td>
</tr>
<tr>
<td>DELETE /api/v2/device-credentials/{id}</td>
<td>Delete a device credential</td>
</tr>
<tr>
<td>POST/api/v2/users/{id}/identities</td>
<td>Link user accounts from various identity providers</td>
</tr>
<tr>
<td>DELETE /api/v2/users/{id}/identities/{provider}/{user_id}</td>
<td>Unlink user accounts</td>
</tr>
</tbody>
</table>

## Actions

### Scope changes

The actions you can perform with the Management API depend on the scopes that your access token contains. With this migration, you can either get a limited access token that can update only the logged-in user's data or an access token that can update the data of any user. In the following matrix, you can see the scopes that your token needs to have per case and per endpoint.

For example, if you get an access token that contains the scope `read:users`, you can retrieve the data of any user using the `GET /api/v2/users/{id}` endpoint. However, if your token contains the scope `read:current_user`, you can only retrieve the information of the currently logged-in user (the one that the token was issued for).

<table class="table"><thead>
<tr>
<th>Endpoint</th>
<th>Scope for current user</th>
<th>Scope for any user</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET /api/v2/users/{id}</td>
<td><code>read:current_user</code></td>
<td><code>read:users</code></td>
</tr>
<tr>
<td>GET /api/v2/users/{id}/enrollments</td>
<td><code>read:current_user</code></td>
<td><code>read:users</code></td>
</tr>
<tr>
<td>POST/api/v2/users/{id}/identities</td>
<td><code>update:current_user_identities</code></td>
<td><code>update:users</code></td>
</tr>
<tr>
<td>DELETE /api/v2/users/{id}/identities/{provider}/{user_id}</td>
<td><code>update:current_user_identities</code></td>
<td><code>update:users</code></td>
</tr>
<tr>
<td>PATCH /api/v2/users/{id}</td>
<td><code>update:current_user_metadata</code></td>
<td><code>update:users</code></td>
</tr>
<tr>
<td>PATCH /api/v2/users/{id}</td>
<td><code>create:current_user_metadata</code></td>
<td><code>update:users</code></td>
</tr>
<tr>
<td>DELETE /api/v2/users/{id}/multifactor/{provider}</td>
<td><code>delete:current_user_metadata</code></td>
<td><code>update:users</code></td>
</tr>
<tr>
<td>POST /api/v2/device-credentials</td>
<td><code>create:current_user_device_credentials</code></td>
<td><code>create:device_credentials</code></td>
</tr>
<tr>
<td>DELETE /api/v2/device-credentials/{id}</td>
<td><code>delete:current_user_device_credentials</code></td>
<td><code>delete:device_credentials</code></td>
</tr>
</tbody>
</table>

### Get access tokens

Auth0 has changed how you get a token for the previously mentioned endpoints. There are several variations on how you authenticate a user and get tokens, depending on the technology and the <Tooltip tip="OAuth 2.0: Authorization framework that defines authorization protocols and workflows." cta="View Glossary" href="/docs/glossary?term=OAuth+2.0">OAuth 2.0</Tooltip> flow you use to authenticate:

* **SPA running in a browser**: Use the Authorization endpoint.
* **Web app running on a server, a mobile app, a server process, or a highly trusted app**: Use the <Tooltip tip="Token Endpoint: Endpoint on the Authorization Server that is used to programmatically request tokens." cta="View Glossary" href="/docs/glossary?term=Token+endpoint">Token endpoint</Tooltip>.
* **Cross-authentication**: Use embedded Lock or auth0.js to authenticate users when the requests come from different domains.

#### Authorization endpoint

In this section, we will use an example to show the differences in how you get a token with the Authorization endpoint. Keep in mind that no matter which endpoint you want to migrate, the changes are the same, the only thing that differs is the scopes that you specify in the request.

In the example below, you use the `GET User by ID` endpoint to retrieve the full profile information of the logged-in user. To do so, first, we will authenticate the user using the Implicit grant and retrieve the token(s). Below you can see an implementation of the old approach that gets an ID Token and then uses it to call the endpoint.

```http lines
https://{yourDomain}/authorize?
      scope=openid
      &response_type=id_token
      &client_id={yourClientId}
      &redirect_uri=https://{yourApp}/callback
      &nonce={nonce}
      &state={opaqueValue}
```






In the example below, you can see the new approach that gets an access token.


```http lines
https://{yourDomain}/authorize?
      audience=https://{yourDomain}/api/v2/
      &scope=read:current_user
      &response_type=token%20id_token
      &client_id={yourClientId}
      &redirect_uri=https://{yourApp}/callback
      &nonce={nonce}
      &state={opaqueValue}
```






To get an access token that can access the Management API:

* Set the `audience` to `https://{yourDomain}/api/v2/`
* Ask for the scope `${scope}`
* Set the `response_type` to `id_token token` so Auth0 will send both an ID token and an access token

If you decode the received access token and review its contents you will see the following:

```json lines
{
      "iss": "https://{yourDomain}/",
      "sub": "auth0|5a620d29a840170a9ef43672",
      "aud": "https://{yourDomain}/api/v2/",
      "iat": 1521031317,
      "exp": 1521038517,
      "azp": "{yourClientId}",
      "scope": "${scope}"
    }
```






Notice that `aud` is set to your tenant's API URI, `scope` is set to `${scope}`, and `sub` is set to the user ID of the logged-in user.

Once you have the access token you can use it to call the endpoint. This part remains the same, nothing else changes in the request except for the value you use as `Bearer` token. The response remains also the same.

#### Token endpoint

In this section, we will use an example to show the differences in how you get a token with the Token endpoint. Keep in mind though that no matter which endpoint you want to migrate, the changes are the same, the only thing that differs is the scopes that you specify in the request.

In the example below, you want to use the `GET User by ID` endpoint to retrieve the full profile information of the logged-in user. First, authenticate the user using the Password Exchange grant and then retrieve the token(s). Below you can see an implementation of the old approach that gets an ID Token (and then uses it to call the endpoint).


```json lines
POST https://{yourDomain}/oauth/token
    Content-Type: application/x-www-form-urlencoded
    {
      "grant_type": "password",
      "username": "{yourUsername}",
      "password": "{yourPassword}",
      "scope": "openid",
      "client_id": "{yourClientId}",
      "client_secret": "{yourClientSecret}",
    }
```






In the example below, you can see the new approach that gets an access token as well.

```json lines
POST https://{yourDomain}/oauth/token
    Content-Type: application/x-www-form-urlencoded
    {
      "grant_type": "password",
      "username": "{yourUsername}",
      "password": "{yourPassword}",
      "audience": "https://{yourDomain}/api/v2/",
      "scope": "read:current_user",
      "client_id": "{yourClientId}",
      "client_secret": "{yourClientSecret}",
    }
```






In order to get an Access Token that can access the Management API:

* Set the `aud` to `https://{yourDomain}/api/v2/`
* Ask for the scope `read:current_user`

Once you have the access token you can use it to call the endpoint. This part remains the same, nothing else changes in the request except for the value you use as `Bearer` token. The response remains also the same.

#### Embedded Lock or auth0.js

If you embed either Lock or auth0.js v9 in your application, then you are using cross-origin authentication. This is used to authenticate users when the requests come from different domains.

If you use auth0.js to access the Management API and manage your users, then your script will have to be updated.

In the example below, you can see the old approach.

```javascript lines
// get an ID Token
    var webAuth = new auth0.WebAuth({
      clientID: '{yourClientId}',
      domain: '{yourDomain}',
      redirectUri: 'https://{yourApp}/callback',
      scope: 'openid',
      responseType: 'id_token'
    });
    // create a new instance
    var auth0Manage = new auth0.Management({
      domain: '{yourDomain}',
      token: '{yourIdToken}'
    });
```


In this example, you can see the new approach.

```javascript lines
// get an Access Token
    var webAuth = new auth0.WebAuth({
      clientID: '{yourClientId}',
      domain: '{yourDomain}',
      redirectUri: 'https://{yourApp}/callback',
      audience: 'https://{yourDomain}/api/v2/',
      scope: 'read:current_user',
      responseType: 'token id_token'
    });
    // create a new instance
    var auth0Manage = new auth0.Management({
      domain: '{yourDomain}',
      token: '{yourMgmtApiAccessToken}'
    });
```






* Ask for both an ID token and an access token in the response

  `responseType: 'token id_token'`
* Set the Management API as the intended <Tooltip tip="Audience: Unique identifier of the audience for an issued token. Named aud in a token, its value contains the ID of either an application (Client ID) for an ID Token or an API (API Identifier) for an Access Token." cta="View Glossary" href="/docs/glossary?term=audience">audience</Tooltip> of the token

  `audience: 'https://YOUR_DOMAIN/api/v2/'`
* Ask for the required permission

  `scope: 'read:current_user'`
* Authenticate with the Management API using the access token

### Account Linking changes

The changes in this functionality are the following:

* You can no longer use an ID Token at the `Authorization` header
* If you use an access token at the `Authorization` header, with `update:users` as the granted permission, then you can send at the request's body either the `user_id` or the ID Token of the secondary account
* If you use an access token at the `Authorization` header, with `update:current_user_metadata` as the granted permission, then you can only send the ID Token of the secondary account in the request's body. The following must apply:

  + The ID token must be signed using `RS256` (you can set this value at **Dashboard > Applications > Application Settings > Advanced Settings > OAuth**)
  + The claim `aud` of the ID token, must identify the application, and be the same value with the `azp` claim of the access token

## Restrictions

The access tokens used to access the Management API must only hold one value at the `aud` claim. If your token contains more than one value, then your request to the Management API will error out.

## Learn more

* [Migrate to Access Tokens for Account Linking](/docs/troubleshoot/product-lifecycle/past-migrations/link-user-accounts-with-access-tokens-migration)