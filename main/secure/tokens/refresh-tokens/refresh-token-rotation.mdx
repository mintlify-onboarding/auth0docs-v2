---
description: Describes how refresh token rotation provides greater security by
  issuing a new refresh token with each request made to Auth0 for a new access token
  by a client using refresh tokens.
'og:image': https://cdn2.auth0.com/docs/1.14553.0/img/share-image.png
'og:title': Refresh Token Rotation
'og:url': https://auth0.com/docs/
permalink: refresh-token-rotation
title: Refresh Token Rotation
'twitter:description': Describes how refresh token rotation provides greater security
  by issuing a new refresh token with each request made to Auth0 for a new access
  token by a client using refresh tokens.
'twitter:title': Refresh Token Rotation
---
<Tooltip tip="Refresh Token: Token used to obtain a renewed Access Token without forcing users to log in again." cta="View Glossary" href="/glossary?term=Refresh+token">Refresh token</Tooltip> rotation is a technique for getting new <Tooltip tip="Refresh Token: Token used to obtain a renewed Access Token without forcing users to log in again." cta="View Glossary" href="/glossary?term=access+tokens">access tokens</Tooltip> using refresh tokens that goes beyond [silent authentication](/authenticate/login/configure-silent-authentication). Refresh tokens are typically longer-lived and can be used to request new access tokens after the shorter-lived access tokens expire. Refresh tokens are often used in native applications on mobile devices in conjunction with short-lived access tokens to provide seamless UX without having to issue long-lived access tokens.

With <Tooltip tip="Refresh Token Rotation: Strategy of frequently replacing refresh tokens to minimize vulnerability. With refresh token rotation, every time your application exchanges a refresh token to get a new access token, Auth0 also returns a new refresh token." cta="View Glossary" href="/glossary?term=refresh+token+rotation">refresh token rotation</Tooltip> enabled in the <Tooltip tip="Refresh Token Rotation: Strategy of frequently replacing refresh tokens to minimize vulnerability. With refresh token rotation, every time your application exchanges a refresh token to get a new access token, Auth0 also returns a new refresh token." cta="View Glossary" href="/glossary?term=Auth0+Dashboard">Auth0 Dashboard</Tooltip>, every time an application exchanges a refresh token to get a new access token, a new refresh token is also returned. Therefore, you no longer have a long-lived refresh token that, if compromised, could provide illegitimate access to resources. As refresh tokens are continually exchanged and invalidated, the threat is reduced.

The way refresh token rotation works in Auth0 conforms with the [OAuth 2.0 BCP](https://tools.ietf.org/html/draft-ietf-oauth-security-topics-13#section-4.12) and works with the following flows:

* [Authorization Code Flow](/get-started/authentication-and-authorization-flow/authorization-code-flow)
* [Authorization Code Flow with Proof Key for Code Exchange](/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce)
* [Device Authorization Flow](/get-started/authentication-and-authorization-flow/device-authorization-flow)
* [Resource Owner Password Flow](/get-started/authentication-and-authorization-flow/resource-owner-password-flow)

## Maintain user sessions in SPAs

Until very recently, SPAs maintained the user’s session by using the Authorization Code Flow with PKCE in conjunction with silent authentication. Recent developments in browser privacy technology, such as Intelligent Tracking Prevention (ITP) prevent access to the Auth0 <Tooltip tip="Session Cookie: Entity that, when present, allows the user to be considered authenticated." cta="View Glossary" href="/glossary?term=session+cookie">session cookie</Tooltip>, thereby requiring users to reauthenticate.

<Frame>![Refresh Token Rotation Maintain User Sessions in SPAs diagram](/images/cdy7uua7fh8z/3sf7RRsy81bt3zcXMnHUSe/2171fdab4ffeb0987c329aa897038abc/rt-and-at.png)</Frame>

Unfortunately, long-lived refresh tokens are not suitable for SPAs because there is no persistent storage mechanism in a browser that can assure access by the intended application only. As there are vulnerabilities that can be exploited to obtain these high-value artifacts and grant malicious actors access to protected resources, using refresh tokens in SPAs has been strongly discouraged.

Refresh token rotation offers a remediation to end-user sessions being lost due to side-effects of browser privacy mechanisms. Because refresh token rotation does not rely on access to the Auth0 session cookie, it is not affected by ITP or similar mechanisms.

The following state diagram illustrates how refresh token rotation is used in conjunction with the Authorization Code Flow with PKCE, but the general principle of getting a new refresh token with each exchange applies to all supported flows.

<Frame>![Refresh Token Rotation Maintain User Sessions in SPAs State diagram](/images/cdy7uua7fh8z/41avsR2u0B4fSP3Bwh0WZz/d803a9057ea6e606d602c7c97d99fc3a/rtr-state-diagram.png)</Frame>

This means you can safely use refresh tokens to mitigate the adverse effects of browser privacy tools and provide continuous access to end-users without disrupting the user experience.

## Automatic reuse detection

When a client needs a new access token, it sends the refresh token with the request to Auth0 to get a new token pair. As soon as the new pair is issued by Auth0, the refresh token used in the request is invalidated. This safeguards your app from replay attacks resulting from compromised tokens.

Without enforcing sender-constraint, it’s impossible for the <Tooltip tip="Authorization Server: Centralized server that contributes to defining the boundaries of a user’s access. For example, your authorization server can control the data, tasks, and features available to a user." cta="View Glossary" href="/glossary?term=authorization+server">authorization server</Tooltip> to know which actor is legitimate or malicious in the event of a replay attack. So it’s important that the most recently issued refresh token is also immediately invalidated when a previously-used refresh token (already invalidated) is sent to the authorization server. This prevents any refresh tokens in the same token family (all refresh tokens descending from the original refresh token issued for the client) from being used to get new access tokens.

For example, consider the following scenario:

<Frame>![Refresh Token Rotation Reuse Detection state diagram](/images/cdy7uua7fh8z/33fe73R81Cpm6eTmOWfAnm/e7d168edc27861507a121910b32f1ee2/reuse-detection1.png)</Frame>

1. Legitimate Client has **refresh token 1**, and it is leaked to or stolen by Malicious Client.
2. Legitimate Client uses **refresh token 1** to get a new refresh token/access token pair.
3. Auth0 returns **refresh token 2/access token 2**.
4. Malicious Client then attempts to use **refresh token 1** to get an access token. Auth0 recognizes that refresh token 1 is being reused, and immediately invalidates the refresh token family, including **refresh token 2**.
5. Auth0 returns an access denied response to Malicious Client.
6. **Access token 2** expires and Legitimate Client attempts to use **refresh token 2** to request a new token pair. Auth0 returns an access denied response to Legitimate Client.
7. Re-authentication is required.

This protection mechanism works regardless of whether the legitimate client or the malicious client is able to exchange **refresh token 1** for a new token pair before the other. As soon as reuse is detected, all subsequent requests will be denied until the user re-authenticates. When reuse is detected, Auth0 captures detected reuse [events](/deploy-monitor/logs/log-event-type-codes) (such as `ferrt` indicating a failed exchange) in logs. This can be especially useful in conjunction with Auth0’s [log streaming](/customize/log-streams) capabilities to detect suspicious activity.

Another example is where the malicious client steals **refresh token 1** and successfully uses it to acquire an access token before the legitimate client attempts to use **refresh token 1**. In this case, the malicious client’s access would be short-lived because **refresh token 2** (or any subsequently issued refresh tokens) is automatically revoked when the legitimate client tries to use **refresh token 1**, as shown in the following diagram:

<Frame>![Refresh Token Rotation Reuse Detection State diagram](/images/cdy7uua7fh8z/36rAUgLOAqW7k7Fdl1eRN1/c1a57be5093416b50d42ec41a1e3a233/reuse-detection2.png)</Frame>

## SDK support

The following SDKs include support for refresh token rotation and automatic reuse detection.

* Auth0 SPA SDK
* Flutter (Web)
* Swift (iOS) SDK
* Android SDK
* Flutter
* React Native SDK
* WPF / Winforms
* Xamarin

For documentation specific to these SDKs, visit the [Auth0 SDK Libraries](/libraries) page.

You can choose to store tokens in either local storage or browser memory. The default is in browser memory. See [Token Best Practices](/secure/tokens/token-best-practices) for recommendations about token storage. You must enable offline access and request the offline access scope in the client SDK.

## Learn more

* [Configure Refresh Token Rotation](/secure/tokens/refresh-tokens/configure-refresh-token-rotation)
* [Disable Refresh Token Rotation](/secure/tokens/refresh-tokens/disable-refresh-token-rotation)
* [Configure Refresh Token Expiration](/secure/tokens/refresh-tokens/configure-refresh-token-expiration)
* [Token Best Practices](/secure/tokens/token-best-practices)